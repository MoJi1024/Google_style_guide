

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Google 开源项目风格指南</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="contents.html#document-contents" class="icon icon-home"> Google 开源项目风格指南
          

          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-index">Google 开源项目风格指南——中文版</a></li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/contents">C++ 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/index">0. 扉页</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">0.1 译者前言</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">0.2 背景</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/headers">1. 头文件</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#self-contained">1.1. Self-contained 头文件</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#define">1.2. #define 保护</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">1.3. 前置声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">1.4. 内联函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#include">1.5. <code class="docutils literal notranslate"><span class="pre">#include</span></code> 的路径及顺序</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/scoping">2. 作用域</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">2.1. 命名空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">2.2. 匿名命名空间和静态变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">2.3. 非成员函数、静态成员函数和全局函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">2.4. 局部变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">2.5. 静态和全局变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/classes">3. 类</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">3.1. 构造函数的职责</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">3.2. 隐式类型转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">3.3. 可拷贝类型和可移动类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#vs">3.4. 结构体 VS. 类</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">3.5. 继承</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">3.6. 多重继承</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">3.7. 接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-8">3.8. 运算符重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">3.9. 存取控制</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">3.10. 声明顺序</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/functions">4. 函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">4.1. 输入和输出</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">4.2. 编写简短函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">4.3. 引用参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">4.4. 函数重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">4.5. 缺省参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">4.6. 函数返回类型后置语法</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/magic">5. 来自 Google 的奇技</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">5.1. 所有权与智能指针</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#cpplint">5.2. Cpplint</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/others">6. 其他 C++ 特性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">6.1. 引用参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">6.2. 右值引用</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">6.3. 函数重载</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">6.4. 缺省参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#alloca">6.5. 变长数组和 alloca()</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">6.6. 友元</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">6.7. 异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">6.8. 运行时类型识别</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-8">6.9. 类型转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">6.10. 流</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">6.11. 前置自增和自减</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#const">6.12. <code class="docutils literal notranslate"><span class="pre">const</span></code> 用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#constexpr">6.13. <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 用法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">6.14. 整型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">6.15. 64 位下的可移植性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">6.16. 预处理宏</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#nullptr-null">6.17. 0, <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">NULL</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#sizeof">6.18. sizeof</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#auto">6.19. auto</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-14">6.20. 列表初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lambda">6.21. Lambda 表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-15">6.22. 模板编程</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#boost-1">6.23. Boost 库</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#c-11">6.24. C++11</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/naming">7. 命名约定</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">7.1. 通用命名规则</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">7.2. 文件命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">7.3. 类型命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">7.4. 变量命名</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-6">普通变量命名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-7">类数据成员</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">结构体变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">7.5. 常量命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">7.6. 函数命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">7.7. 命名空间命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">7.8. 枚举命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">7.9. 宏命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-14">7.10. 命名规则的特例</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/comments">8. 注释</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">8.1. 注释风格</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">8.2. 文件注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-4">法律公告和作者信息</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-5">文件内容</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">8.3. 类注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">8.4. 函数注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">函数声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-9">函数定义</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">8.5. 变量注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-11">类数据成员</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-12">全局变量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">8.6. 实现注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-14">代码前注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-15">行注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-16">函数参数注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-17">不允许的行为</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-18">8.7. 标点, 拼写和语法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#todo">8.8. TODO 注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-19">8.9. 弃用注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/formatting">9. 格式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">9.1. 行长度</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#ascii">9.2. 非 ASCII 字符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">9.3. 空格还是制表位</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">9.4. 函数声明与定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lambda">9.5. Lambda 表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">9.6. 函数调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">9.7. 列表初始化格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">9.8. 条件语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-8">9.9. 循环和开关选择语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">9.10. 指针和引用表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">9.11. 布尔表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">9.12. 函数返回值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">9.13. 变量及数组初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">9.14. 预处理指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-14">9.15. 类格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-15">9.16. 构造函数初始值列表</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-16">9.17. 命名空间格式化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-17">9.18. 水平留白</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-18">通用</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-19">循环和条件语句</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-20">操作符</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-21">模板和转换</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-22">9.19. 垂直留白</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#yulefox">译者 (YuleFox) 笔记</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#acgtyrant">译者（acgtyrant）笔记</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/exceptions">10. 规则特例</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">10.1. 现有不合规范的代码</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#windows">10.2. Windows 代码</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-cpp-styleguide/end">11. 结束语</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-objc-styleguide/contents">Objective-C 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/index">Google Objective-C Style Guide 中文版</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">译者的话</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#ewanke">ewanke</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#yang-y-1">Yang.Y</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">背景介绍</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">例子</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/spacing">留白和格式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#vs">空格 vs. 制表符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">行宽</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">方法声明和定义</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">方法调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#public-private"><code class="docutils literal notranslate"><span class="pre">&#64;public</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">协议名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">块（闭包）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/naming">命名</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">文件名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#objective-c">Objective-C++</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">类名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">类别名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#objective-c-1">Objective-C 方法名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">变量名</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-6">普通变量名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-7">实例变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">常量</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/comments">注释</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">文件注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-3">版权信息及作者</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">声明部分的注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">实现部分的注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">对象所有权</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/features">Cocoa 和 Objective-C 特性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#private">成员变量应该是 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">明确指定构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">重载指定构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#nsobject">重载 <code class="docutils literal notranslate"><span class="pre">NSObject</span></code> 的方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#new">避免 <code class="docutils literal notranslate"><span class="pre">+new</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#api">保持公共 API 简单</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#import-and-include"><code class="docutils literal notranslate"><span class="pre">#import</span></code> and <code class="docutils literal notranslate"><span class="pre">#include</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">使用根框架</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#autorelease">构建时即设定 <code class="docutils literal notranslate"><span class="pre">autorelease</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#autorelease-retain"><code class="docutils literal notranslate"><span class="pre">autorelease</span></code> 优先 <code class="docutils literal notranslate"><span class="pre">retain</span></code> 其次</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#init-dealloc"><code class="docutils literal notranslate"><span class="pre">init</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 内避免使用访问器</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">按声明顺序销毁实例变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#setter-nsstrings"><code class="docutils literal notranslate"><span class="pre">setter</span></code> 应复制 NSStrings</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">避免抛异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#nil">nil 检查</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#bool">BOOL 若干陷阱</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#property">属性（Property）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-7">命名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">位置</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#copy-attribute">字符串应使用 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 属性（Attribute）</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-9">原子性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-10">点引用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">没有实例变量的接口</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#synthesize">自动 <code class="docutils literal notranslate"><span class="pre">synthesize</span></code> 实例变量</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-objc-styleguide/patterns">Cocoa 模式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">委托模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#mvc">模型/视图/控制器（MVC）</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-python-styleguide/contents">Python 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/index">扉页</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/background">背景</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/python_language_rules">Python语言规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lint">Lint</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">导入</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">包</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">全局变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">嵌套/局部/内部类和函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">推导式和生成式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">默认迭代器和操作符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-8">生成器</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lambda">Lambda函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">条件表达式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">默认参数值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#properties">特性 (properties)</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#true-false">True/False的求值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#lexical-scoping">词法作用域(Lexical Scoping, 又名静态作用域)</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">函数与方法装饰器</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">线程</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">威力过大的特性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#python-from-future-imports">现代python: from __future__ imports</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-14">代码类型注释</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/python_style_rules">Python风格规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">分号</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">行宽</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">括号</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">缩进</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">序列的尾部要添加逗号吗?</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#shebang">Shebang行</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#docstring">注释和文档字符串 (docstring)</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">标点符号、拼写和语法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">字符串</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#socket">文件、套接字 (socket) 和类似的有状态资源</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#todo">TODO (待办) 注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#import">导入 (import) 语句的格式</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-8">语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#getter-setter-1">访问器 (getter) 和设置器 (setter)</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">主程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">函数长度</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#type-annotation">类型注解 (type annotation)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-python-styleguide/parting_words">临别赠言</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-shell-styleguide/contents">Shell 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/index">扉页</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/background">背景</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#shell">使用哪一种Shell</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#shell-1">什么时候使用Shell</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/shell_files_and_interpreter_invocation">Shell文件和解释器调用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">文件扩展名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#suid-sgid">SUID / SGID</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/environment">环境</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#stdout-vs-stderr">STDOUT vs STDERR</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/comments">注释</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">文件头</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">功能注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">实现部分的注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#todo">TODO注释</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/formatting">格式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">缩进</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">行的长度和长字符串</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">管道</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#case">case语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">变量扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">引用</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/features_and_bugs">特性及错误</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">命令替换</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#test">test，[和[[</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">测试字符串</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">文件名的通配符扩展</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#eval">Eval</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#while">管道导向while循环</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/naming_conventions">命名约定</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">函数名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">变量名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">常量和环境变量名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">源文件名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">只读变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">使用本地变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-8">函数位置</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#main">主函数main</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/calling_commands">调用命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">检查返回值</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">内建命令和外部命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-shell-styleguide/conclusion">结论</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-javascript-styleguide/contents">Javascript 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-javascript-styleguide/background">背景</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-javascript-styleguide/javascript_language_rules">Javascript语言规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#var">var关键字</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-1">描述</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">常量</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-3">描述</a><ul>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-4">常量值</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-5">常量指针（变量和属性）</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-6">例子</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">分号</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">发生了什么？</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-9">为什么？</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-10">澄清：分号和函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">嵌套函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">块内函数声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-14">自定义异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-15">标准功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-16">原始类型的包装对象</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-17">多重的原型继承</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-18">方法和属性定义</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-19">为什么？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-20">删除</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-21">闭包</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#eval">eval()函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#with">with() {}</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#this">this</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#for-in">for-in 循环</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-22">关联数组</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-23">多行的字符串字面量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-24">数组和对象字面量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-25">修改内置对象原型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#internet-explorer">Internet Explorer中的条件注释</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-javascript-styleguide/javascript_style_rules">Javascript风格规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">命名</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-2">属性和方法</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-3">方法和函数参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#gettersetter">getter和setter</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-4">存取函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-5">命名空间</a><ul>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-6">为全局代码使用命名空间</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-7">尊重命名空间所有权</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-8">外部代码和内部代码使用不同的命名空间</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-9">为长类型的名称提供别名提高可读性</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-10">文件名</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#tostring">自定义 toString() 方法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">延时初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">明确作用域</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">代码格式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-14">大括号</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-15">数组和对象初始化表达式</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-16">函数参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-17">匿名函数传递</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#goog-scope-1">使用goog.scope命名别名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-18">更多的缩进</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-19">空行</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-20">二元和三元操作符</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-21">括号</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-22">字符串</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-23">可见性（私有和保护类型字段）</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#javascript-1">JavaScript类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#javascript-2">JavaScript类型语言</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#javascript-3">JavaScript中的类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-24">类型转换</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-25">可为空与可选的参数和属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-26">类型定义</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-27">模板类型</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-28">注释</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-29">注释语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#jsdoc-1">JSDoc 缩进</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#jsdochtml">JSDoc中的HTML</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-30">顶层/文件层注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#class">Class评论</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-31">方法和功能注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-32">属性评论</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#jsdoc-2">JSDoc标签参考</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#goog-provide">为goog.provide提供依赖</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-33">编译</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-34">技巧和诀窍</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#truefalse">True和False布尔表达式</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-35">条件（三元）操作符（？：）</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-36">&amp;&amp; 和 ||</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-37">遍历节点列表</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-typescript-styleguide/contents">TypeScript 风格指南</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-typescript-styleguide/preface">1. 前言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">1.1. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">1.2. 翻译信息</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-4">1.2.1. 上次更新日期</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-5">1.2.2. 作者</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-6">1.2.3. 原文链接</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-7">1.2.4. 中文版链接</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">1.2.5. 修订历史</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-typescript-styleguide/syntax">2. 语法规范</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">2.1. 标识符</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-3">2.1.1. 命名规范</a><ul>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-4">2.1.1.1. 缩写</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-5">2.1.1.2. 美元符号 $</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-6">2.1.1.3. 类型参数</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-7">2.1.1.4. 测试用例</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-8">2.1.1.5. <code class="docutils literal notranslate"><span class="pre">_</span></code> 前缀与后缀</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-9">2.1.1.6. 导入模块</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-10">2.1.1.7. 常量</a></li>
<li class="toctree-l5"><a class="reference internal" href="contents.html#section-11">2.1.1.8. 其他</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-12">2.1.2. 别名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-13">2.1.3. 命名风格</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-14">2.1.4. 描述性命名</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-15">2.2. 文件编码</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-16">2.3. 注释与文档</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#jsdoc">2.3.1. 用 JSDoc 还是 注释？</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#jsdoc-1">2.3.2. JSDoc 规范</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-17">2.3.3. 对所有导出的顶层模块进行注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#typescript">2.3.4. 省略对于 TypeScript 而言多余的注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#override">2.3.5. 不要使用 <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-18">2.3.6. 注释必须言之有物</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-19">2.3.7. 参数属性注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-20">2.3.8. 函数调用注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-21">2.3.9. 将文档置于装饰器之前</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-typescript-styleguide/language">3. 语言特性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">3.1. 可见性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">3.2. 构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">3.3. 类成员</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#private">3.3.1. <code class="docutils literal notranslate"><span class="pre">#private</span></code> 语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#readonly">3.3.2. 使用 <code class="docutils literal notranslate"><span class="pre">readonly</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-5">3.3.3. 参数属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-6">3.3.4. 字段初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-7">3.3.5. 用于类的词法范围之外的属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">3.3.6. 取值器与设值器（存取器）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">3.4. 原始类型与封装类</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">3.5. 数组构造函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">3.6. 强制类型转换</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">3.7. 变量</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-13">3.8. 异常</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-14">3.9. 对象迭代</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-15">3.10. 容器迭代</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-16">3.11. 展开运算符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-17">3.12. 控制流语句 / 语句块</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#switch">3.13. <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-18">3.14. 相等性判断</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-19">3.15. 函数声明</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-20">3.16. 函数表达式</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-21">3.16.1. 在表达式中使用箭头函数</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-22">3.16.2. 表达式函数体 和 代码块函数体</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#this">3.16.3. 重新绑定 <code class="docutils literal notranslate"><span class="pre">this</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-23">3.16.4. 使用箭头函数作为属性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-24">3.16.5. 事件句柄</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-25">3.17. 自动分号插入</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#ts-ignore">3.18. <code class="docutils literal notranslate"><span class="pre">&#64;ts-ignore</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-26">3.19. 类型断言与非空断言</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-27">3.19.1. 类型断言语法</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-28">3.19.2. 类型断言和对象字面量</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-29">3.20. 成员属性声明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-30">3.20.1. 优化属性访问的兼容性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-31">3.20.2. 优化模块对象导入的兼容性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-32">3.20.3. 例外情况</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-33">3.21. 枚举</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#debugger">3.22. <code class="docutils literal notranslate"><span class="pre">debugger</span></code> 语句</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-34">3.23. 装饰器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-typescript-styleguide/source_organization">4. 代码管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">4.1. 模块</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-3">4.1.1. 导入路径</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-4">4.1.2. 用 命名空间 还是 模块？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">4.2. 导出</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-6">4.2.1. 导出可见性</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-7">4.2.2. 可变导出</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">4.2.3. 容器类</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">4.3. 导入</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-10">4.3.1. 选择模块导入还是解构导入？</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-11">4.3.2. 重命名导入</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#import-type-export-type">4.3.3. <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">type</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-12">4.4. 根据特征组织代码</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-typescript-styleguide/type_system">5. 类型系统</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">5.1. 类型推导</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-3">5.1.1. 返回类型</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#null-undefined">5.2. Null 还是 Undefined ？</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-4">5.2.1. 可空/未定义类型别名</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#undefined">5.2.2. 可选参数 还是 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 类型？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">5.3. 结构类型 与 指名类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">5.4. 接口 还是 类型别名？</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#array-t">5.5. <code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> 类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#key-string-number">5.6. 索引类型 <code class="docutils literal notranslate"><span class="pre">{[key:</span> <span class="pre">string]:</span> <span class="pre">number}</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-7">5.7. 映射类型与条件类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#any">5.8. <code class="docutils literal notranslate"><span class="pre">any</span></code> 类型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="contents.html#section-8">5.8.1. 提供一个更具体的类型</a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#unknown-any">5.8.2. 使用 <code class="docutils literal notranslate"><span class="pre">unknown</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">any</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="contents.html#lint-any">5.8.3. 关闭 Lint 工具对 <code class="docutils literal notranslate"><span class="pre">any</span></code> 的警告</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-9">5.9. 元组类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-10">5.10. 包装类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-11">5.11. 只有泛型的返回类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-typescript-styleguide/consistency">6. 一致性</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">6.1. 目标</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/contents">HTML/CSS 风格指南 - 内容目录</a><ul>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/background">背景</a></li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/general_style_rules">整体样式规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">协议</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/general_formatting_rules">总体排版规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">缩进</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">大小写</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">尾部的空格</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/general_meta_rules">整体的元数据规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">编码</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">注释</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">处理内容</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/html_style_rules">HTML样式规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">文档类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#html-1">HTML合法性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">语义化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">多媒体降级</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">关注点分离</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">实体引用</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">可选的标签</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#type">type属性</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/html_formatting_rules">HTML格式规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">常规格式化</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#html-1">HTML引号</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/css_style_rules">css样式规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#css-1">CSS有效性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#idclass">id与class的命名</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#idclass-1">id与class的命名规范</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">选择器的类型</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">简写属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">0与单位</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">前导0</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">十六进制表示法</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-6">前缀选择器</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#idclass-2">id与class名称分隔符</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#hacks">Hacks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/css_formatting_rules">CSS格式化规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">声明顺序</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-2">块内容的缩进</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-3">声明结束</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#css-1">CSS属性名结束</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-4">声明块间隔</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-5">选择器及声明分离</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#css-2">CSS代码块分离</a></li>
<li class="toctree-l3"><a class="reference internal" href="contents.html#css-3">CSS引号</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/css_meta_rules">CSS元规则</a><ul>
<li class="toctree-l3"><a class="reference internal" href="contents.html#section-1">分段规则</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="contents.html#document-google-html-css-styleguide/parting_words">赠言</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="contents.html#document-contents">Google 开源项目风格指南</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="contents.html#document-contents">Docs</a> &raquo;</li>
        
      <li>Google 开源项目风格指南</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/zh-google-styleguide/zh-google-styleguide/blob/master/contents.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="section-1">
<span id="contents"></span><h1>内容目录</h1>
<div class="toctree-wrapper compound">
<span id="document-index"></span><div class="section" id="google">
<h2>Google 开源项目风格指南——中文版</h2>
<ul class="simple">
<li>ReadTheDocs 托管地址： <a class="reference external" href="https://zh-google-styleguide.readthedocs.io/en/latest/">在线阅读最新版本</a></li>
<li>GitHub 托管地址： <a class="reference external" href="https://github.com/zh-google-styleguide/zh-google-styleguide">zh-google-styleguide</a></li>
<li>离线文档下载地址： <a class="reference external" href="https://github.com/zh-google-styleguide/zh-google-styleguide/releases">release</a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>声明</strong></p>
<p>本项目并非 Google 官方项目，而是由国内程序员凭热情创建和维护。</p>
<p class="last">如果你关注的是 Google 官方英文版，请移步 <a class="reference external" href="https://github.com/google/styleguide">Google Style Guide</a> 。</p>
</div>
<p>每个较大的开源项目都有自己的风格指南：关于如何为该项目编写代码的一系列约定（有时候会比较武断）。当所有代码均保持一致的风格，在理解大型代码库时更为轻松。</p>
<p>“风格”的含义涵盖范围广，从“变量使用驼峰格式（camelCase）”到“决不使用全局变量”再到“决不使用异常”，等等诸如此类。</p>
<p>英文版项目维护的是在 Google 使用的编程风格指南。如果你正在修改的项目源自 Google，你可能会被引导至英文版项目页面，以了解项目所使用的风格。</p>
<p>我们已经发布了七份 <strong>中文版</strong> 的风格指南:</p>
<ol class="arabic simple">
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-cpp-styleguide/">Google C++ 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-objc-styleguide/">Google Objective-C 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-python-styleguide/">Google Python 风格指南</a></li>
<li><a class="reference external" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-javascript-styleguide/">Google JavaScript 风格指南</a></li>
<li><a class="reference external" href="http://zh-google-styleguide.readthedocs.org/en/latest/google-shell-styleguide/">Google Shell 风格指南</a></li>
<li><a class="reference external" href="https://github.com/darcyliu/google-styleguide/blob/master/JSONStyleGuide.md">Google JSON 风格指南</a></li>
<li><a class="reference external" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-typescript-styleguide/contents/">Google TypeScript 风格指南</a></li>
</ol>
<p>中文版项目采用 reStructuredText 纯文本标记语法，并使用 Sphinx 生成 HTML / CHM / PDF 等文档格式。</p>
<ul class="simple">
<li>英文版项目还包含 <a class="reference external" href="https://github.com/google/styleguide/tree/gh-pages/cpplint">cpplint</a> ——一个用来帮助适应风格准则的工具，以及 <a class="reference external" href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">google-c-style.el</a>，Google 风格的 Emacs 配置文件。</li>
<li>另外，招募志愿者翻译 <a class="reference external" href="http://google.github.io/styleguide/javascriptguide.xml">JavaScript Style Guide</a> 以及 <a class="reference external" href="http://google.github.io/styleguide/xmlstyle.html">XML Document Format Style Guide</a> ，有意者请联系 <a class="reference external" href="https://github.com/yangyubo">Yang.Y</a> 。</li>
</ul>
</div>
<span id="document-google-cpp-styleguide/contents"></span><div class="section" id="c">
<span id="cpp-contents"></span><h2>C++ 风格指南 - 内容目录</h2>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#c" id="toc-entry-1">C++ 风格指南 - 内容目录</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<span id="document-google-cpp-styleguide/index"></span><div class="section" id="section-1">
<h3>0. 扉页</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">4.45</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Benjy Weinberger</div>
<div class="line">Craig Silverstein</div>
<div class="line">Gregory Eitzmann</div>
<div class="line">Mark Mentovai</div>
<div class="line">Tashana Landray</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://www.yulefox.com">YuleFox</a></div>
<div class="line"><a class="reference external" href="https://github.com/yangyubo">Yang.Y</a></div>
<div class="line"><a class="reference external" href="http://acgtyrant.com">acgtyrant</a></div>
<div class="line"><a class="reference external" href="http://github.com/lilinsanity">lilinsanity</a></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="http://google-styleguide.googlecode.com">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="section-2">
<h4>0.1 译者前言</h4>
<p>Google 经常会发布一些开源项目, 意味着会接受来自其他代码贡献者的代码. 但是如果代码贡献者的编程风格与 Google 的不一致, 会给代码阅读者和其他代码提交者造成不小的困扰. Google 因此发布了这份自己的编程风格指南, 使所有提交代码的人都能获知 Google 的编程风格.</p>
<p>翻译初衷:</p>
<blockquote>
<div><p>规则的作用就是避免混乱. 但规则本身一定要权威, 有说服力, 并且是理性的. 我们所见过的大部分编程规范, 其内容或不够严谨, 或阐述过于简单, 或带有一定的武断性.</p>
<p>Google 保持其一贯的严谨精神, 5 万汉字的指南涉及广泛, 论证严密. 我们翻译该系列指南的主因也正是其严谨性. 严谨意味着指南的价值不仅仅局限于它罗列出的规范, 更具参考意义的是它为了列出规范而做的谨慎权衡过程.</p>
<p>指南不仅列出你要怎么做, 还告诉你为什么要这么做, 哪些情况下可以不这么做, 以及如何权衡其利弊. 其他团队未必要完全遵照指南亦步亦趋, 如前面所说, 这份指南是 Google 根据自身实际情况打造的, 适用于其主导的开源项目. 其他团队可以参照该指南, 或从中汲取灵感, 建立适合自身实际情况的规范.</p>
<p>我们在翻译的过程中, 收获颇多. 希望本系列指南中文版对你同样能有所帮助.</p>
</div></blockquote>
<p>我们翻译时也是尽力保持严谨, 但水平所限, bug 在所难免. 有任何意见或建议, 可与我们取得联系.</p>
<p>中文版和英文版一样, 使用 <code class="docutils literal notranslate"><span class="pre">Artistic</span> <span class="pre">License/GPL</span></code> 开源许可.</p>
<p>中文版修订历史:</p>
<blockquote>
<div><ul>
<li><p class="first">2015-08 : 热心的清华大学同学 &#64;lilinsanity 完善了「类」章节以及其它一些小章节。至此，对 Google CPP Style Guide 4.45 的翻译正式竣工。</p>
</li>
<li><p class="first">2015-07 4.45 : acgtyrant 为了学习 C++ 的规范，顺便重新翻译了本 C++ 风格指南，特别是 C++11 的全新内容。排版大幅度优化，翻译措辞更地道，添加了新译者笔记。Google 总部 C++ 工程师 innocentim, 清华大学不愿意透露姓名的唐马儒先生，大阪大学大学院情报科学研究科计算机科学专攻博士 farseerfc 和其它 Arch Linux 中文社区众帮了译者不少忙，谢谢他们。因为 C++ Primer 尚未完全入门，暂时没有翻译「类」章节和其它一些小章节。</p>
</li>
<li><p class="first">2009-06 3.133 : YuleFox 的 1.0 版已经相当完善, 但原版在近一年的时间里, 其规范也发生了一些变化.</p>
<blockquote>
<div><p>Yang.Y 与 YuleFox 一拍即合, 以项目的形式来延续中文版 : <a class="reference external" href="http://github.com/yangyubo/zh-google-styleguide">Google 开源项目风格指南 - 中文版项目</a>.</p>
<p>主要变化是同步到 3.133 最新英文版本, 做部分勘误和改善可读性方面的修改, 并改进排版效果. Yang.Y 重新翻修, YuleFox 做后续评审.</p>
</div></blockquote>
</li>
<li><p class="first">2008-07 1.0 : 出自 <a class="reference external" href="http://www.yulefox.com/?p=207">YuleFox 的 Blog</a>, 很多地方摘录的也是该版本.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-3">
<h4>0.2 背景</h4>
<p>C++ 是 Google 大部分开源项目的主要编程语言. 正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护.</p>
<p>本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性. 这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性.</p>
<p><em>风格</em>, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单.</p>
<p>使代码易于管理的方法之一是加强代码一致性. 让任何程序员都可以快速读懂你的代码这点非常重要. 保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义. 创建通用, 必需的习惯用语和模式可以使代码更容易理解. 在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做.</p>
<p>本指南的另一个观点是 C++ 特性的臃肿. C++ 是一门包含大量高级特性的庞大语言. 某些情况下, 我们会限制甚至禁止使用某些特性. 这么做是为了保持代码清爽, 避免这些特性可能导致的各种问题. 指南中列举了这类特性, 并解释为什么这些特性被限制使用.</p>
<p>Google 主导的开源项目均符合本指南的规定.</p>
<p>注意: 本指南并非 C++ 教程, 我们假定读者已经对 C++ 非常熟悉.</p>
</div>
</div>
<span id="document-google-cpp-styleguide/headers"></span><div class="section" id="section-1">
<h3>1. 头文件</h3>
<p>通常每一个 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件都有一个对应的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件. 也有一些常见例外, 如单元测试代码和只包含 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 函数的 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件.</p>
<p>正确使用头文件可令代码在可读性、文件大小和性能上大为改观.</p>
<p>下面的规则将引导你规避使用头文件时的各种陷阱.</p>
<div class="section" id="self-contained">
<span id="self-contained-headers"></span><h4>1.1. Self-contained 头文件</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">头文件应该能够自给自足（self-contained,也就是可以作为第一个头文件被引入），以 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 <code class="docutils literal notranslate"><span class="pre">.inc</span></code> 结尾。不允许分离出 <code class="docutils literal notranslate"><span class="pre">-inl.h</span></code> 头文件的做法.</p>
</div>
<p>所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有 <a class="reference internal" href="#define-guard"><span class="std std-ref">1.2. #define 保护</span></a>，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.</p>
<p>不过有一个例外，即一个文件并不是 self-contained 的，而是作为文本插入到代码某处。或者，文件内容实际上是其它头文件的特定平台（platform-specific）扩展部分。这些文件就要用 <code class="docutils literal notranslate"><span class="pre">.inc</span></code> 文件扩展名。</p>
<p>如果 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 <code class="docutils literal notranslate"><span class="pre">-inl.h</span></code>  文件里（译者注：过去该规范曾提倡把定义放到 -inl.h 里过）。</p>
<p>有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件里。</p>
</div>
<div class="section" id="define">
<span id="define-guard"></span><h4>1.2. #define 保护</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所有头文件都应该有 <code class="docutils literal notranslate"><span class="pre">#define</span></code> 保护来防止头文件被多重包含, 命名格式当是: <code class="docutils literal notranslate"><span class="pre">&lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H_</span></code> .</p>
</div>
<p>为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 中的头文件 <code class="docutils literal notranslate"><span class="pre">foo/src/bar/baz.h</span></code> 可按如下方式保护:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef FOO_BAR_BAZ_H_</span>
<span class="cp">#define FOO_BAR_BAZ_H_</span>
<span class="p">...</span>
<span class="cp">#endif </span><span class="c1">// FOO_BAR_BAZ_H_</span>
</pre></div>
</div>
</div>
<div class="section" id="section-2">
<span id="forward-declarations"></span><h4>1.3. 前置声明</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能地避免使用前置声明。使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 包含需要的头文件即可。</p>
</div>
<p><strong>定义：</strong></p>
<blockquote>
<div>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.</div></blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<div><ul class="simple">
<li>前置声明能够节省编译时间，多余的 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 会迫使编译器展开更多的文件，处理更多的输入。</li>
<li>前置声明能够节省不必要的重新编译的时间。 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 使代码因为头文件中无关的改动而被重新编译多次。</li>
</ul>
</div></blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<div><ul>
<li><p class="first">前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。</p>
</li>
<li><p class="first">前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 API. 例如扩大形参类型，加个自带默认参数的模板形参等等。</p>
</li>
<li><p class="first">前置声明来自命名空间 <code class="docutils literal notranslate"><span class="pre">std::</span></code> 的 symbol 时，其行为未定义。</p>
</li>
<li><p class="first">很难判断什么时候该用前置声明，什么时候该用 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 。极端情况下，用前置声明代替 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 甚至都会暗暗地改变代码的含义：</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// b.h:</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{};</span>
<span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{};</span>

<span class="c1">// good_user.cc:</span>
<span class="cp">#include</span> <span class="cpf">&quot;b.h&quot;</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="n">D</span><span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// calls f(B*)</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
<blockquote>
<div>如果 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 被 <code class="docutils literal notranslate"><span class="pre">B</span></code> 和 <code class="docutils literal notranslate"><span class="pre">D</span></code> 的前置声明替代， <code class="docutils literal notranslate"><span class="pre">test()</span></code> 就会调用 <code class="docutils literal notranslate"><span class="pre">f(void*)</span></code> .</div></blockquote>
<ul class="simple">
<li>前置声明了不少来自头文件的 symbol 时，就会比单单一行的 <code class="docutils literal notranslate"><span class="pre">include</span></code> 冗长。</li>
<li>仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.</li>
</ul>
</div></blockquote>
<p><strong>结论：</strong></p>
<blockquote>
<div><ul class="simple">
<li>尽量避免前置声明那些定义在其他项目中的实体.</li>
<li>函数：总是使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code>.</li>
<li>类模板：优先使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code>.</li>
</ul>
</div></blockquote>
<p>至于什么时候包含头文件，参见 <a class="reference internal" href="#name-and-order-of-includes"><span class="std std-ref">1.5. #include 的路径及顺序</span></a> 。</p>
</div>
<div class="section" id="section-3">
<span id="inline-functions"></span><h4>1.4. 内联函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div>当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div>只要内联的函数体较小, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div>滥用内联将导致程序变得更慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!</p>
<p>另一个实用的经验准则: 内联那些包含循环或 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句从不被执行).</p>
<p>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联.  通常, 递归函数不应该声明成内联函数.（YuleFox 注: 递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p>
</div></blockquote>
</div>
<div class="section" id="include">
<span id="name-and-order-of-includes"></span><h4>1.5. <code class="docutils literal notranslate"><span class="pre">#include</span></code> 的路径及顺序</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 <cite>.h</cite>, 本项目内的 <cite>.h</cite>.</p>
</div>
<p>项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 <code class="docutils literal notranslate"><span class="pre">.</span></code> (当前目录) 或 <code class="docutils literal notranslate"><span class="pre">..</span></code> (上级目录). 例如, <code class="docutils literal notranslate"><span class="pre">google-awesome-project/src/base/logging.h</span></code> 应该按如下方式包含:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;base/logging.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>又如, <code class="docutils literal notranslate"><span class="pre">dir/foo.cc</span></code> 或 <code class="docutils literal notranslate"><span class="pre">dir/foo_test.cc</span></code> 的主要作用是实现或测试 <code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code> 的功能, <code class="docutils literal notranslate"><span class="pre">foo.cc</span></code> 中包含头文件的次序如下:</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code> (优先位置, 详情如下)</li>
<li>C 系统文件</li>
<li>C++ 系统文件</li>
<li>其他库的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件</li>
<li>本项目内 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件</li>
</ol>
</div></blockquote>
<p>这种优先的顺序排序保证当 <code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code> 遗漏某些必要的库时， <code class="docutils literal notranslate"><span class="pre">dir/foo.cc</span></code> 或 <code class="docutils literal notranslate"><span class="pre">dir/foo_test.cc</span></code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p>
<p><code class="docutils literal notranslate"><span class="pre">dir/foo.cc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dir2/foo2.h</span></code> 通常位于同一目录下 (如 <code class="docutils literal notranslate"><span class="pre">base/basictypes_unittest.cc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">base/basictypes.h</span></code>), 但也可以放在不同目录下.</p>
<p>按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。</p>
<p>您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，<a class="reference internal" href="#forward-declarations">前置声明</a> (forward declarations) 情况除外。比如您要用到 <code class="docutils literal notranslate"><span class="pre">bar.h</span></code> 中的某个符号, 哪怕您所包含的 <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> 已经包含了 <code class="docutils literal notranslate"><span class="pre">bar.h</span></code>, 也照样得包含 <code class="docutils literal notranslate"><span class="pre">bar.h</span></code>, 除非 <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> 有明确说明它会自动向您提供 <code class="docutils literal notranslate"><span class="pre">bar.h</span></code> 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 <code class="docutils literal notranslate"><span class="pre">foo.cc</span></code> 只包含 <code class="docutils literal notranslate"><span class="pre">foo.h</span></code> 就够了，不用再管后者所包含的其它内容。</p>
<p>举例来说, <code class="docutils literal notranslate"><span class="pre">google-awesome-project/src/foo/internal/fooserver.cc</span></code> 的包含次序如下:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;foo/public/fooserver.h&quot; // 优先位置</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;hash_map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;base/basictypes.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;base/commandlineflags.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;foo/public/bar.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div></blockquote>
<p><strong>例外：</strong></p>
<p>有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如：</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;foo/public/fooserver.h&quot;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&quot;base/port.h&quot;  // For LANG_CXX11.</span><span class="cp"></span>

<span class="cp">#ifdef LANG_CXX11</span>
<span class="cp">#include</span> <span class="cpf">&lt;initializer_list&gt;</span><span class="cp"></span>
<span class="cp">#endif  </span><span class="c1">// LANG_CXX11</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>避免多重包含是学编程时最基本的要求;</li>
<li>前置声明是为了降低编译依赖，防止修改一个头文件引发多米诺效应;</li>
<li>内联函数的合理使用可提高代码执行效率;</li>
<li><code class="docutils literal notranslate"><span class="pre">-inl.h</span></code> 可提高代码可读性 (一般用不到吧:D);</li>
<li>标准化函数参数顺序可以提高可读性和易维护性 (对函数参数的堆栈空间有轻微影响, 我以前大多是相同类型放在一起);</li>
<li>包含文件的名称使用 <code class="docutils literal notranslate"><span class="pre">.</span></code> 和 <code class="docutils literal notranslate"><span class="pre">..</span></code> 虽然方便却易混乱, 使用比较完整的项目路径看上去很清晰, 很条理, 包含文件的次序除了美观之外, 最重要的是可以减少隐藏依赖, 使每个头文件在 “最需要编译” (对应源文件处 :D) 的地方编译, 有人提出库文件放在最后, 这样出错先是项目内的文件, 头文件都放在对应源文件的最前面, 这一点足以保证内部错误的及时发现了.</li>
</ol>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>原来还真有项目用 <code class="docutils literal notranslate"><span class="pre">#includes</span></code> 来插入文本，且其文件扩展名 <code class="docutils literal notranslate"><span class="pre">.inc</span></code> 看上去也很科学。</li>
<li>Google 已经不再提倡 <code class="docutils literal notranslate"><span class="pre">-inl.h</span></code> 用法。</li>
<li>注意，前置声明的类是不完全类型（incomplete type），我们只能定义指向该类型的指针或引用，或者声明（但不能定义）以不完全类型作为参数或者返回类型的函数。毕竟编译器不知道不完全类型的定义，我们不能创建其类的任何对象，也不能声明成类内部的数据成员。</li>
<li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li>
<li>在 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 和本项目内的 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 是个好习惯。</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/scoping"></span><div class="section" id="section-1">
<h3>2. 作用域</h3>
<div class="section" id="section-2">
<span id="namespaces"></span><h4>2.1. 命名空间</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">鼓励在 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件内使用匿名命名空间或 <code class="docutils literal notranslate"><span class="pre">static</span></code> 声明. 使用具名的命名空间时, 其名称可基于项目名或相对路径. 禁止使用 using 指示（using-directive）。禁止使用内联命名空间（inline namespace）。</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div>命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突.</div></blockquote>
<p><strong>优点:</strong></p>
<blockquote>
<div><p>虽然类已经提供了（可嵌套的）命名轴线 (YuleFox 注: 将命名分割在不同类的作用域内), 命名空间在这基础上又封装了一层.</p>
<p>举例来说, 两个不同项目的全局作用域都有一个类 <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, 这样在编译或运行时造成冲突. 如果每个项目将代码置于不同命名空间中, <code class="docutils literal notranslate"><span class="pre">project1::Foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">project2::Foo</span></code> 作为不同符号自然不会冲突.</p>
<p>内联命名空间会自动把内部的标识符放到外层作用域，比如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">X</span> <span class="p">{</span>
<span class="kr">inline</span> <span class="k">namespace</span> <span class="n">Y</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>  <span class="c1">// namespace Y</span>
<span class="p">}</span>  <span class="c1">// namespace X</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">X::Y::foo()</span></code> 与 <code class="docutils literal notranslate"><span class="pre">X::foo()</span></code> 彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。</p>
</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div><p>命名空间具有迷惑性, 因为它们使得区分两个相同命名所指代的定义更加困难。</p>
<p>内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。</p>
<p>有时候不得不多次引用某个定义在许多嵌套命名空间里的实体，使用完整的命名空间会导致代码的冗长。</p>
<p>在头文件中使用匿名空间导致违背 C++ 的唯一定义原则 (One Definition Rule (ODR)).</p>
</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>根据下文将要提到的策略合理使用命名空间.</p>
<ul>
<li><p class="first">遵守 <a class="reference external" href="naming.html#namespace-names">命名空间命名</a> 中的规则。</p>
</li>
<li><p class="first">像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。</p>
</li>
<li><p class="first">用命名空间把文件包含, <a class="reference external" href="https://gflags.github.io/gflags/">gflags</a> 的声明/定义, 以及类的前置声明以外的整个源文件封装起来, 以区别于其它命名空间:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// .h 文件</span>
<span class="k">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

<span class="c1">// 所有声明都置于命名空间中</span>
<span class="c1">// 注意不要使用缩进</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="p">...</span>
    <span class="kt">void</span> <span class="n">Foo</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// .cc 文件</span>
<span class="k">namespace</span> <span class="n">mynamespace</span> <span class="p">{</span>

<span class="c1">// 函数定义都置于命名空间中</span>
<span class="kt">void</span> <span class="n">MyClass</span><span class="o">::</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="p">}</span> <span class="c1">// namespace mynamespace</span>
</pre></div>
</div>
<p>更复杂的 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件包含更多, 更复杂的细节, 比如 gflags 或 using 声明。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;a.h&quot;</span><span class="cp"></span>

<span class="n">DEFINE_FLAG</span><span class="p">(</span><span class="kt">bool</span><span class="p">,</span> <span class="n">someflag</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&quot;dummy flag&quot;</span><span class="p">);</span>

<span class="k">namespace</span> <span class="n">a</span> <span class="p">{</span>

<span class="p">...</span><span class="n">code</span> <span class="k">for</span> <span class="n">a</span><span class="p">...</span>                <span class="c1">// 左对齐</span>

<span class="p">}</span> <span class="c1">// namespace a</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">不要在命名空间 <code class="docutils literal notranslate"><span class="pre">std</span></code> 内声明任何东西, 包括标准库的类前置声明. 在 <code class="docutils literal notranslate"><span class="pre">std</span></code> 命名空间声明实体是未定义的行为, 会导致如不可移植. 声明标准库下的实体, 需要包含对应的头文件.</p>
</li>
<li><p class="first">不应该使用 <em>using 指示</em> 引入整个命名空间的标识符号。</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 禁止 —— 污染命名空间</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">foo</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">不要在头文件中使用 <em>命名空间别名</em> 除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在 .cc 中使用别名缩短常用的命名空间</span>
<span class="k">namespace</span> <span class="n">baz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 在 .h 中使用别名缩短常用的命名空间</span>
<span class="k">namespace</span> <span class="n">librarian</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">impl</span> <span class="p">{</span>  <span class="c1">// 仅限内部使用</span>
<span class="k">namespace</span> <span class="n">sidetable</span> <span class="o">=</span> <span class="o">::</span><span class="n">pipeline_diagnostics</span><span class="o">::</span><span class="n">sidetable</span><span class="p">;</span>
<span class="p">}</span>  <span class="c1">// namespace impl</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="n">my_inline_function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 限制在一个函数中的命名空间别名</span>
  <span class="k">namespace</span> <span class="n">baz</span> <span class="o">=</span> <span class="o">::</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">baz</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">}</span>  <span class="c1">// namespace librarian</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">禁止用内联命名空间</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-3">
<span id="unnamed-namespace-and-static-variables"></span><h4>2.2. 匿名命名空间和静态变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code class="docutils literal notranslate"><span class="pre">static</span></code> 。但是不要在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件中这么做。</p>
</div>
<p><strong>定义:</strong></p>
<blockquote>
<div>所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为 <code class="docutils literal notranslate"><span class="pre">static</span></code> 拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>推荐、鼓励在 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 中使用。</p>
<p>匿名命名空间的声明和具名的格式相同，在最后注释上 <code class="docutils literal notranslate"><span class="pre">namespace</span></code> :</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="section-4">
<span id="nonmember-static-member-and-global-functions"></span><h4>2.3. 非成员函数、静态成员函数和全局函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用静态成员函数或命名空间内的非成员函数, 尽量不要用裸的全局函数. 将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关.</p>
</div>
<p><strong>优点:</strong></p>
<blockquote>
<div>某些情况下, 非成员函数和静态成员函数是非常有用的, 将非成员函数放在命名空间内可避免污染全局作用域.</div></blockquote>
<p><strong>缺点:</strong></p>
<blockquote>
<div>将非成员函数和静态成员函数作为新类的成员或许更有意义, 当它们需要访问外部资源或具有重要的依赖关系时更是如此.</div></blockquote>
<p><strong>结论:</strong></p>
<blockquote>
<div><p>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. 相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类, 不如使用 <a class="reference internal" href="#namespaces"><span class="std std-ref">2.1. 命名空间</span></a> 。举例而言，对于头文件 <code class="docutils literal notranslate"><span class="pre">myproject/foo_bar.h</span></code> , 应当使用</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">myproject</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">foo_bar</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">Function1</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">Function2</span><span class="p">();</span>
<span class="p">}</span>  <span class="c1">// namespace foo_bar</span>
<span class="p">}</span>  <span class="c1">// namespace myproject</span>
</pre></div>
</div>
<p>而非</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">myproject</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">FooBar</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">Function1</span><span class="p">();</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="nf">Function2</span><span class="p">();</span>
<span class="p">};</span>
<span class="p">}</span>  <span class="c1">// namespace myproject</span>
</pre></div>
</div>
<p>定义在同一编译单元的函数, 被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖; 静态成员函数对此尤其敏感. 可以考虑提取到新类中, 或者将函数置于独立库的命名空间内.</p>
<p>如果你必须定义非成员函数, 又只是在 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件中使用它, 可使用匿名 <a class="reference internal" href="#namespaces"><span class="std std-ref">2.1. 命名空间</span></a> 或 <code class="docutils literal notranslate"><span class="pre">static</span></code> 链接关键字 (如 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">int</span> <span class="pre">Foo()</span> <span class="pre">{...}</span></code>) 限定其作用域.</p>
</div></blockquote>
</div>
<div class="section" id="section-5">
<span id="local-variables"></span><h4>2.4. 局部变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化.</p>
</div>
<p>C++ 允许在函数的任何位置声明变量. 我们提倡在尽可能小的作用域中声明变量, 离第一次使用越近越好. 这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值. 特别是，应使用初始化的方式替代声明再赋值, 比如:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span> <span class="c1">// 坏——初始化和声明分离</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">g</span><span class="p">();</span> <span class="c1">// 好——初始化时声明</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// 用花括号初始化更好</span>
<span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span> <span class="c1">// 好——v 一开始就初始化</span>
</pre></div>
</div>
</div></blockquote>
<p>属于 <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">while</span></code> 和 <code class="docutils literal notranslate"><span class="pre">for</span></code> 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">))</span> <span class="n">str</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数. 这会导致效率降低.</p>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 低效的实现</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                  <span class="c1">// 构造函数和析构函数分别调用 1000000 次!</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在循环作用域外面声明这类变量要高效的多:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>                      <span class="c1">// 构造函数和析构函数只调用 1 次</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<span id="static-and-global-variables"></span><h4>2.5. 静态和全局变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。</p>
</div>
<p>禁止使用类的 <a class="reference external" href="http://zh.cppreference.com/w/cpp/language/storage_duration#.E5.AD.98.E5.82.A8.E6.9C.9F">静态储存周期</a> 变量：由于构造和析构函数调用顺序的不确定性，它们会导致难以发现的 bug 。不过 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 变量除外，毕竟它们又不涉及动态初始化或析构。</p>
<p>静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型 (POD : Plain Old Data): 即 int, char 和 float, 以及 POD 类型的指针、数组和结构体。</p>
<p>静态变量的构造函数、析构函数和初始化的顺序在 C++ 中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug. 所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化 POD 变量，除非该函数（比如 <code class="docutils literal notranslate"><span class="pre">getenv()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">getpid()</span></code> ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Xris 译注:</p>
<p class="last">同一个编译单元内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序。不同的编译单元之间初始化和销毁顺序属于未明确行为 (unspecified behaviour)。</p>
</div>
<p>同理，全局和静态变量在程序中断时会被析构，无论所谓中断是从 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 返回还是对 <code class="docutils literal notranslate"><span class="pre">exit()</span></code> 的调用。析构顺序正好与构造函数调用的顺序相反。但既然构造顺序未定义，那么析构顺序当然也就不定了。比如，在程序结束时某静态变量已经被析构了，但代码还在跑——比如其它线程——并试图访问它且失败；再比如，一个静态 string 变量也许会在一个引用了前者的其它变量析构之前被析构掉。</p>
<p>改善以上析构问题的办法之一是用 <code class="docutils literal notranslate"><span class="pre">quick_exit()</span></code> 来代替 <code class="docutils literal notranslate"><span class="pre">exit()</span></code> 并中断程序。它们的不同之处是前者不会执行任何析构，也不会执行 <code class="docutils literal notranslate"><span class="pre">atexit()</span></code> 所绑定的任何 handlers. 如果您想在执行 <code class="docutils literal notranslate"><span class="pre">quick_exit()</span></code> 来中断时执行某 handler（比如刷新 log），您可以把它绑定到 <code class="docutils literal notranslate"><span class="pre">_at_quick_exit()</span></code>. 如果您想在 <code class="docutils literal notranslate"><span class="pre">exit()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">quick_exit()</span></code> 都用上该 handler, 都绑定上去。</p>
<p>综上所述，我们只允许 POD 类型的静态变量，即完全禁用 <code class="docutils literal notranslate"><span class="pre">vector</span></code> (使用 C 数组替代) 和 <code class="docutils literal notranslate"><span class="pre">string</span></code> (使用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char</span> <span class="pre">[]</span></code>)。</p>
<p>如果您确实需要一个 <code class="docutils literal notranslate"><span class="pre">class</span></code> 类型的静态或全局变量，可以考虑在 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 函数或 <code class="docutils literal notranslate"><span class="pre">pthread_once()</span></code> 内初始化一个指针且永不回收。注意只能用 raw 指针，别用智能指针，毕竟后者的析构函数涉及到上文指出的不定顺序问题。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Yang.Y 译注:</p>
<p class="last">上文提及的静态变量泛指静态生存周期的对象, 包括: 全局变量, 静态变量, 静态类成员变量, 以及函数静态变量.</p>
</div>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">cc</span></code> 中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用 <code class="docutils literal notranslate"><span class="pre">using</span></code> 关键字污染命名空间;</li>
<li>嵌套类符合局部使用原则, 只是不能在其他头文件中前置声明, 尽量不要 <code class="docutils literal notranslate"><span class="pre">public</span></code>;</li>
<li>尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元;</li>
<li>多线程中的全局变量 (含静态成员变量) 不要使用 <code class="docutils literal notranslate"><span class="pre">class</span></code> 类型 (含 STL 容器), 避免不明确行为导致的 bug.</li>
<li>作用域的使用, 除了考虑名称污染, 可读性之外, 主要是为降低耦合, 提高编译/执行效率.</li>
</ol>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>注意「using 指示（using-directive）」和「using 声明（using-declaration）」的区别。</li>
<li>匿名命名空间说白了就是文件作用域，就像 C static 声明的作用域一样，后者已经被 C++ 标准提倡弃用。</li>
<li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li>
<li>注意别在循环犯大量构造和析构的低级错误。</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/classes"></span><div class="section" id="section-1">
<h3>3. 类</h3>
<p>类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.</p>
<div class="section" id="section-2">
<h4>3.1. 构造函数的职责</h4>
<p><strong>总述</strong></p>
<p>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>
<p><strong>定义</strong></p>
<p>在构造函数中可以进行各种初始化操作.</p>
<p><strong>优点</strong></p>
<ul class="simple">
<li>无需考虑类是否被初始化.</li>
<li>经过构造函数完全初始化后的对象可以为 <code class="docutils literal notranslate"><span class="pre">const</span></code> 类型, 也能更方便地被标准容器或算法使用.</li>
</ul>
<p><strong>缺点</strong></p>
<ul class="simple">
<li>如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.</li>
<li>在没有使程序崩溃 (因为并不是一个始终合适的方法) 或者使用异常 (因为已经被 <a class="reference internal" href="contents.html#exceptions"><span class="std std-ref">禁用</span></a> 了) 等方法的条件下, 构造函数很难上报错误</li>
<li>如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用 <code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">IsValid()</span></code> 或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.</li>
<li>构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.</li>
</ul>
<p><strong>结论</strong></p>
<p>构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用 <code class="docutils literal notranslate"><span class="pre">Init()</span></code> 方法或工厂函数.</p>
<p>构造函数不得调用虚函数, 或尝试报告一个非致命错误. 如果对象需要进行有意义的 (non-trivial) 初始化, 考虑使用明确的 Init() 方法或使用工厂模式. Avoid <code class="docutils literal notranslate"><span class="pre">Init()</span></code> methods on objects with no other states that affect which public methods may be called (此类形式的半构造对象有时无法正确工作).</p>
</div>
<div class="section" id="section-3">
<span id="implicit-conversions"></span><h4>3.2. 隐式类型转换</h4>
<p><strong>总述</strong></p>
<p>不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用 <code class="docutils literal notranslate"><span class="pre">explicit</span></code> 关键字.</p>
<p><strong>定义</strong></p>
<p>隐式类型转换允许一个某种类型 (称作 <em>源类型</em>) 的对象被用于需要另一种类型 (称作 <em>目的类型</em>) 的位置, 例如, 将一个 <code class="docutils literal notranslate"><span class="pre">int</span></code> 类型的参数传递给需要 <code class="docutils literal notranslate"><span class="pre">double</span></code> 类型的函数.</p>
<p>除了语言所定义的隐式类型转换, 用户还可以通过在类定义中添加合适的成员定义自己需要的转换. 在源类型中定义隐式类型转换, 可以通过目的类型名的类型转换运算符实现 (例如 <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">bool()</span></code>). 在目的类型中定义隐式类型转换, 则通过以源类型作为其唯一参数 (或唯一无默认值的参数) 的构造函数实现.</p>
<p><code class="docutils literal notranslate"><span class="pre">explicit</span></code> 关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换, 例如使用 <code class="docutils literal notranslate"><span class="pre">cast</span></code>. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Func</span><span class="p">(</span><span class="n">Foo</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
<p>此时下面的代码是不允许的:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Func</span><span class="p">({</span><span class="mi">42</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">});</span>  <span class="c1">// Error</span>
</pre></div>
</div>
<p>这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是 <code class="docutils literal notranslate"><span class="pre">explicit</span></code> 应当限制的行为.</p>
<p><strong>优点</strong></p>
<ul class="simple">
<li>有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强.</li>
<li>隐式类型转换可以简单地取代函数重载.</li>
<li>在初始化对象时, 列表初始化语法是一种简洁明了的写法.</li>
</ul>
<p><strong>缺点</strong></p>
<ul class="simple">
<li>隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li>
<li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.</li>
<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>
<li>如果单参数构造函数没有加上 <code class="docutils literal notranslate"><span class="pre">explicit</span></code> 关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上 <code class="docutils literal notranslate"><span class="pre">explicit</span></code> 标记.</li>
<li>并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清.</li>
<li>如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候.</li>
</ul>
<p><strong>结论</strong></p>
<p>在类型定义中, 类型转换运算符和单参数构造函数都应当用 <code class="docutils literal notranslate"><span class="pre">explicit</span></code> 进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为 <code class="docutils literal notranslate"><span class="pre">explicit</span></code>, 因为它们并不执行类型转换. 对于设计目的就是用于对其他类型进行透明包装的类来说, 隐式类型转换有时是必要且合适的. 这时应当联系项目组长并说明特殊情况.</p>
<p>不能以一个参数进行调用的构造函数不应当加上 <code class="docutils literal notranslate"><span class="pre">explicit</span></code>. 接受一个 <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> 作为参数的构造函数也应当省略 <code class="docutils literal notranslate"><span class="pre">explicit</span></code>, 以便支持拷贝初始化 (例如 <code class="docutils literal notranslate"><span class="pre">MyType</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">2};</span></code>).</p>
</div>
<div class="section" id="section-4">
<span id="copyable-and-movable-types"></span><h4>3.3. 可拷贝类型和可移动类型</h4>
<p><strong>总述</strong></p>
<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
<p><strong>定义</strong></p>
<p>可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. <code class="docutils literal notranslate"><span class="pre">string</span></code> 类型就是一个可拷贝类型的例子.</p>
<p>可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;int&gt;</span></code> 就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.</p>
<p>拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.</p>
<p><strong>优点</strong></p>
<p>可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.</p>
<p>拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如 <code class="docutils literal notranslate"><span class="pre">Clone()</span></code>, <code class="docutils literal notranslate"><span class="pre">CopyFrom()</span></code> or <code class="docutils literal notranslate"><span class="pre">Swap()</span></code>, 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过 <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">default</span></code>. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时, 对于类似 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/copy_elision">省略不必要的拷贝</a> 这样的优化它们也更加合适.</p>
<p>移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.</p>
<p><strong>缺点</strong></p>
<p>许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型 (<code class="docutils literal notranslate"><span class="pre">Registerer</span></code>), 与特定的作用域相关的类型 (<code class="docutils literal notranslate"><span class="pre">Cleanup</span></code>), 与其他对象实体紧耦合的类型 (<code class="docutils literal notranslate"><span class="pre">Mutex</span></code>) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成 <a class="reference external" href="https://en.wikipedia.org/wiki/Object_slicing">对象切割</a> . 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.</p>
<p>拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.</p>
<p><strong>结论</strong></p>
<p>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可移动, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.</p>
<p>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">field_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">field</span><span class="p">)</span> <span class="p">{}</span>
  <span class="c1">// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">Field</span> <span class="n">field_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个 <code class="docutils literal notranslate"><span class="pre">public</span> <span class="pre">virtual</span> <span class="pre">Clone()</span></code> 和一个 <code class="docutils literal notranslate"><span class="pre">protected</span></code> 的拷贝构造函数以供派生类实现.</p>
<p>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code class="docutils literal notranslate"><span class="pre">public</span></code> 域中使用 <code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">delete</span></code> 或其他手段禁用之.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// MyClass is neither copyable nor movable.</span>
<span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="vs">
<span id="structs-vs-classes"></span><h4>3.4. 结构体 VS. 类</h4>
<p><strong>总述</strong></p>
<p>仅当只有数据成员时使用 <code class="docutils literal notranslate"><span class="pre">struct</span></code>, 其它一概使用 <code class="docutils literal notranslate"><span class="pre">class</span></code>.</p>
<p><strong>说明</strong></p>
<p>在 C++ 中 <code class="docutils literal notranslate"><span class="pre">struct</span></code> 和 <code class="docutils literal notranslate"><span class="pre">class</span></code> 关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.</p>
<p><code class="docutils literal notranslate"><span class="pre">struct</span></code> 用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, <code class="docutils literal notranslate"><span class="pre">Initialize()</span></code>, <code class="docutils literal notranslate"><span class="pre">Reset()</span></code>, <code class="docutils literal notranslate"><span class="pre">Validate()</span></code> 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.</p>
<p>如果需要更多的函数功能, <code class="docutils literal notranslate"><span class="pre">class</span></code> 更适合. 如果拿不准, 就用 <code class="docutils literal notranslate"><span class="pre">class</span></code>.</p>
<p>为了和 STL 保持一致, 对于仿函数等特性可以不用 <code class="docutils literal notranslate"><span class="pre">class</span></code> 而是使用 <code class="docutils literal notranslate"><span class="pre">struct</span></code>.</p>
<p>注意: 类和结构体的成员变量使用不同的 <a class="reference internal" href="contents.html#variable-names"><span class="std std-ref">命名规则</span></a>.</p>
</div>
<div class="section" id="section-5">
<span id="inheritance"></span><h4>3.5. 继承</h4>
<p><strong>总述</strong></p>
<p>使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;&lt;Design Patterns&gt;&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 <code class="docutils literal notranslate"><span class="pre">public</span></code> 继承.</p>
<p><strong>定义</strong></p>
<p>当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; <a class="reference internal" href="#interface"><span class="std std-ref">接口继承</span></a>, 子类仅继承父类的方法名称.</p>
<p><strong>优点</strong></p>
<p>实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.</p>
<p><strong>缺点</strong></p>
<p>对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局.</p>
<p><strong>结论</strong></p>
<p>所有继承必须是 <code class="docutils literal notranslate"><span class="pre">public</span></code> 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.</p>
<p>不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 的确 “是一种” <code class="docutils literal notranslate"><span class="pre">Foo</span></code>, <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 才能继承 <code class="docutils literal notranslate"><span class="pre">Foo</span></code>.</p>
<p>必要的话, 析构函数声明为 <code class="docutils literal notranslate"><span class="pre">virtual</span></code>. 如果你的类有虚函数, 则析构函数也应该为虚函数.</p>
<p>对于可能被子类访问的成员函数, 不要过度使用 <code class="docutils literal notranslate"><span class="pre">protected</span></code> 关键字. 注意, 数据成员都必须是 <a class="reference internal" href="#access-control"><span class="std std-ref">私有的</span></a>.</p>
<p>对于重载的虚函数或虚析构函数, 使用 <code class="docutils literal notranslate"><span class="pre">override</span></code>, 或 (较不常用的) <code class="docutils literal notranslate"><span class="pre">final</span></code> 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 <code class="docutils literal notranslate"><span class="pre">override</span></code>, <code class="docutils literal notranslate"><span class="pre">final</span></code> 或 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 的其中之一进行标记. 标记为 <code class="docutils literal notranslate"><span class="pre">override</span></code> 或 <code class="docutils literal notranslate"><span class="pre">final</span></code> 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.</p>
</div>
<div class="section" id="section-6">
<span id="multiple-inheritance"></span><h4>3.6. 多重继承</h4>
<p><strong>总述</strong></p>
<p>真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 为后缀的 <a class="reference internal" href="#interface"><span class="std std-ref">纯接口类</span></a>.</p>
<p><strong>定义</strong></p>
<p>多重继承允许子类拥有多个基类. 要将作为 <em>纯接口</em> 的基类和具有 <em>实现</em> 的基类区别开来.</p>
<p><strong>优点</strong></p>
<p>相比单继承 (见 <a class="reference internal" href="#inheritance"><span class="std std-ref">继承</span></a>), 多重实现继承可以复用更多的代码.</p>
<p><strong>缺点</strong></p>
<p>真正需要用到多重 <em>实现</em> 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.</p>
<p><strong>结论</strong></p>
<p>只有当所有父类除第一个外都是 <a class="reference internal" href="#interface"><span class="std std-ref">纯接口类</span></a> 时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 为后缀.</p>
<p><strong>注意</strong></p>
<p>关于该规则, Windows 下有个 <a class="reference internal" href="contents.html#windows-code"><span class="std std-ref">特例</span></a>.</p>
</div>
<div class="section" id="section-7">
<span id="interface"></span><h4>3.7. 接口</h4>
<p><strong>总述</strong></p>
<p>接口是指满足特定条件的类, 这些类以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 为后缀 (不强制).</p>
<p><strong>定义</strong></p>
<p>当一个类满足以下要求时, 称之为纯接口:</p>
<ul class="simple">
<li>只有纯虚函数 (”<code class="docutils literal notranslate"><span class="pre">=0</span></code>”) 和静态函数 (除了下文提到的析构函数).</li>
<li>没有非静态数据成员.</li>
<li>没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 <code class="docutils literal notranslate"><span class="pre">protected</span></code>.</li>
<li>如果它是一个子类, 也只能从满足上述条件并以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 为后缀的类继承.</li>
</ul>
<p>接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 <em>The C++ Programming Language, 3rd edition</em> 第 12.4 节.</p>
<p><strong>优点</strong></p>
<p>以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 <a class="reference internal" href="#multiple-inheritance"><span class="std std-ref">多重继承</span></a> 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心.</p>
<p><strong>缺点</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">Interface</span></code> 后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户.</p>
<p><strong>结论</strong></p>
<p>只有在满足上述条件时, 类才以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 结尾, 但反过来, 满足上述需要的类未必一定以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 结尾.</p>
</div>
<div class="section" id="section-8">
<h4>3.8. 运算符重载</h4>
<p><strong>总述</strong></p>
<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.</p>
<p><strong>定义</strong></p>
<p>C++ 允许用户通过使用 <code class="docutils literal notranslate"><span class="pre">operator</span></code> 关键字 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/operators">对内建运算符进行重载定义</a> , 只要其中一个参数是用户定义的类型. <code class="docutils literal notranslate"><span class="pre">operator</span></code> 关键字还允许用户使用 <code class="docutils literal notranslate"><span class="pre">operator&quot;&quot;</span></code> 定义新的字面运算符, 并且定义类型转换函数, 例如 <code class="docutils literal notranslate"><span class="pre">operator</span> <span class="pre">bool()</span></code>.</p>
<p><strong>优点</strong></p>
<p>重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合语言习惯的名称 (例如 <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作.</p>
<p>对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记.</p>
<p><strong>缺点</strong></p>
<ul class="simple">
<li>要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.</li>
<li>过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时.</li>
<li>函数重载有多少弊端, 运算符重载就至少有多少.</li>
<li>运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.</li>
<li>对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具.</li>
<li>如果重载运算符的参数写错, 此时得到的可能是一个完全不同的重载而非编译错误. 例如: <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">&lt;</span> <span class="pre">bar</span></code> 执行的是一个行为, 而 <code class="docutils literal notranslate"><span class="pre">&amp;foo</span> <span class="pre">&lt;</span> <span class="pre">&amp;bar</span></code> 执行的就是完全不同的另一个行为了.</li>
<li>重载某些运算符本身就是有害的. 例如, 重载一元运算符 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. 重载诸如 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code> 和 <code class="docutils literal notranslate"><span class="pre">,</span></code> 会导致运算顺序和内建运算的顺序不一致.</li>
<li>运算符从通常定义在类的外部, 所以对于同一运算, 可能出现不同的文件引入了不同的定义的风险. 如果两种定义都链接到同一二进制文件, 就会导致未定义的行为, 有可能表现为难以发现的运行时错误.</li>
<li>用户定义字面量所创建的语义形式对于某些有经验的 C++ 程序员来说都是很陌生的.</li>
</ul>
<p><strong>结论</strong></p>
<p>只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, <code class="docutils literal notranslate"><span class="pre">|</span></code> 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道.</p>
<p>只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&gt;</span></code> 不会同时返回 <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>建议不要将不进行修改的二元运算符定义为成员函数. 如果一个二元运算符被定义为类成员, 这时隐式转换会作用于右侧的参数却不会作用于左侧. 这时会出现 <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code> 能够通过编译而 <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">a</span></code> 不能的情况, 这是很让人迷惑的.</p>
<p>不要为了避免重载操作符而走极端. 比如说, 应当定义 <code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, 和 <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">Equals()</span></code>, <code class="docutils literal notranslate"><span class="pre">CopyFrom()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">PrintTo()</span></code>. 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入 <code class="docutils literal notranslate"><span class="pre">std::set</span></code> 中, 最好还是定义一个自定义的比较运算符而不是重载 <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>.</p>
<p>不要重载 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, <code class="docutils literal notranslate"><span class="pre">,</span></code> 或一元运算符 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>. 不要重载 <code class="docutils literal notranslate"><span class="pre">operator&quot;&quot;</span></code>, 也就是说, 不要引入用户定义字面量.</p>
<p>类型转换运算符在 <a class="reference internal" href="#implicit-conversions"><span class="std std-ref">隐式类型转换</span></a> 一节有提及. <code class="docutils literal notranslate"><span class="pre">=</span></code> 运算符在 <a class="reference internal" href="#copyable-and-movable-types"><span class="std std-ref">可拷贝类型和可移动类型</span></a> 一节有提及. 运算符 <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> 在 <a class="reference internal" href="contents.html#streams"><span class="std std-ref">流</span></a> 一节有提及. 同时请参见 <a class="reference internal" href="contents.html#function-overloading"><span class="std std-ref">函数重载</span></a> 一节, 其中提到的的规则对运算符重载同样适用.</p>
</div>
<div class="section" id="section-9">
<span id="access-control"></span><h4>3.9. 存取控制</h4>
<p><strong>总述</strong></p>
<p>将 <em>所有</em> 数据成员声明为 <code class="docutils literal notranslate"><span class="pre">private</span></code>, 除非是 <code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">const</span></code> 类型成员 (遵循 <a class="reference internal" href="contents.html#constant-names"><span class="std std-ref">常量命名规则</span></a>). 出于技术上的原因, 在使用 <a class="reference external" href="https://github.com/google/googletest">Google Test</a> 时我们允许测试固件类中的数据成员为 <code class="docutils literal notranslate"><span class="pre">protected</span></code>.</p>
</div>
<div class="section" id="section-10">
<span id="declaration-order"></span><h4>3.10. 声明顺序</h4>
<p><strong>总述</strong></p>
<p>将相似的声明放在一起, 将 <code class="docutils literal notranslate"><span class="pre">public</span></code> 部分放在最前.</p>
<p><strong>说明</strong></p>
<p>类定义一般应以 <code class="docutils literal notranslate"><span class="pre">public:</span></code> 开始, 后跟 <code class="docutils literal notranslate"><span class="pre">protected:</span></code>, 最后是 <code class="docutils literal notranslate"><span class="pre">private:</span></code>. 省略空部分.</p>
<p>在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括 <code class="docutils literal notranslate"><span class="pre">typedef</span></code>, <code class="docutils literal notranslate"><span class="pre">using</span></code> 和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.</p>
<p>不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 参见 <a class="reference internal" href="contents.html#inline-functions"><span class="std std-ref">内联函数</span></a> 一节.</p>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>不在构造函数中做太多逻辑相关的初始化;</li>
<li>编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数;</li>
<li>为避免隐式转换, 需将单参数构造函数声明为 <code class="docutils literal notranslate"><span class="pre">explicit</span></code>;</li>
<li>为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为 <code class="docutils literal notranslate"><span class="pre">private</span></code> 且无需实现;</li>
<li>仅在作为数据集合时使用 <code class="docutils literal notranslate"><span class="pre">struct</span></code>;</li>
<li>组合 &gt; 实现继承 &gt; 接口继承 &gt; 私有继承, 子类重载的虚函数也要声明 <code class="docutils literal notranslate"><span class="pre">virtual</span></code> 关键字, 虽然编译器允许不这样做;</li>
<li>避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口;</li>
<li>接口类类名以 <code class="docutils literal notranslate"><span class="pre">Interface</span></code> 为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为 <code class="docutils literal notranslate"><span class="pre">protected</span></code>;</li>
<li>为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明;</li>
<li>存取函数一般内联在头文件中;</li>
<li>声明次序: <code class="docutils literal notranslate"><span class="pre">public</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">protected</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">private</span></code>;</li>
<li>函数体尽量短小, 紧凑, 功能单一;</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/functions"></span><div class="section" id="section-1">
<h3>4. 函数</h3>
<div class="section" id="section-2">
<h4>4.1. 输入和输出</h4>
<p><strong>总述</strong></p>
<p>我们倾向于按值返回， 否则按引用返回。 避免返回指针， 除非它可以为空.</p>
<p><strong>说明</strong></p>
<p>C++ 函数由返回值提供天然的输出， 有时也通过输出参数（或输入/输出参数）提供. 我们倾向于使用返回值而不是输出参数： 它们提高了可读性， 并且通常提供相同或更好的性能.</p>
<p>C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 非可选输入参数通常是值参或 <code class="docutils literal notranslate"><span class="pre">const</span></code> 引用, 非可选输出参数或输入/输出参数通常应该是引用 （不能为空）. 对于可选的参数， 通常使用 <code class="docutils literal notranslate"><span class="pre">std::optional</span></code> 来表示可选的按值输入， 使用 <code class="docutils literal notranslate"><span class="pre">const</span></code> 指针来表示可选的其他输入． 使用非常量指针来表示可选输出和可选输入/输出参数．</p>
<p>避免定义需要 <code class="docutils literal notranslate"><span class="pre">const</span></code> 引用参数去超出生命周期的函数， 因为 <code class="docutils literal notranslate"><span class="pre">const</span></code> 引用参数与临时变量绑定． 相反， 要找到某种方法来消除生命周期要求 （例如， 通过复制参数）， 或者通过 <code class="docutils literal notranslate"><span class="pre">const</span></code> 指针传递它并记录生命周期和非空要求.</p>
<p>在排序函数参数时， 将所有输入参数放在所有输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.</p>
<p>这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.</p>
</div>
<div class="section" id="section-3">
<h4>4.2. 编写简短函数</h4>
<p><strong>总述</strong></p>
<p>我们倾向于编写简短, 凝练的函数.</p>
<p><strong>说明</strong></p>
<p>我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过 40 行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.</p>
<p>即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短, 以便于他人阅读和修改代码.</p>
<p>在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用 / 调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.</p>
</div>
<div class="section" id="section-4">
<h4>4.3. 引用参数</h4>
<p><strong>总述</strong></p>
<p>所有按引用传递的参数必须加上 <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p>
<p><strong>定义</strong></p>
<p>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">*pval)</span></code>. 在 C++ 中, 函数还可以声明为引用参数: <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">&amp;val)</span></code>.</p>
<p><strong>优点</strong></p>
<p>定义引用参数可以防止出现 <code class="docutils literal notranslate"><span class="pre">(*pval)++</span></code> 这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针.</p>
<p><strong>缺点</strong></p>
<p>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</p>
<p><strong>结论</strong></p>
<p>函数参数列表中, 所有引用参数都必须是 <code class="docutils literal notranslate"><span class="pre">const</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code class="docutils literal notranslate"><span class="pre">const</span></code> 引用, 输出参数为指针. 输入参数可以是 <code class="docutils literal notranslate"><span class="pre">const</span></code> 指针, 但决不能是非 <code class="docutils literal notranslate"><span class="pre">const</span></code> 的引用参数, 除非特殊要求, 比如 <code class="docutils literal notranslate"><span class="pre">swap()</span></code>.</p>
<p>有时候, 在输入形参中用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code> 指针比 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> 更明智. 比如:</p>
<ul class="simple">
<li>可能会传递空指针.</li>
<li>函数要把指针或对地址的引用赋值给输入形参.</li>
</ul>
<p>总而言之, 大多时候输入形参往往是 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code>. 若用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code> 则说明输入另有处理. 所以若要使用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code>, 则应给出相应的理由, 否则会使得读者感到迷惑.</p>
</div>
<div class="section" id="section-5">
<span id="function-overloading"></span><h4>4.4. 函数重载</h4>
<p><strong>总述</strong></p>
<p>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</p>
<p><strong>定义</strong></p>
<p>你可以编写一个参数类型为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">string&amp;</span></code> 的函数, 然后用另一个参数类型为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> 的函数对其进行重载:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">textlen</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>优点</strong></p>
<p>通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.</p>
<p><strong>缺点</strong></p>
<p>如果函数单靠不同的参数类型而重载 (acgtyrant 注：这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.</p>
<p><strong>结论</strong></p>
<p>如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用 <code class="docutils literal notranslate"><span class="pre">AppendString()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AppendInt()</span></code> 等, 而不是一口气重载多个 <code class="docutils literal notranslate"><span class="pre">Append()</span></code>. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> 以便使用者可以用 <a class="reference internal" href="contents.html#braced-initializer-list"><span class="std std-ref">列表初始化</span></a> 指定参数.</p>
</div>
<div class="section" id="section-6">
<h4>4.5. 缺省参数</h4>
<p><strong>总述</strong></p>
<p>只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 <a class="reference internal" href="contents.html#function-overloading"><span class="std std-ref">函数重载</span></a> 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.</p>
<p><strong>优点</strong></p>
<p>有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”.</p>
<p><strong>缺点</strong></p>
<p>缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 <a class="reference internal" href="contents.html#function-overloading"><span class="std std-ref">不应当使用函数重载的理由</span></a> 也都适用于缺省参数.</p>
<p>虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.</p>
<p>缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.</p>
<p>缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.</p>
<p><strong>结论</strong></p>
<p>对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">f(int</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">counter++);</span></code> 这样的代码.)</p>
<p>在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.</p>
</div>
<div class="section" id="section-7">
<h4>4.6. 函数返回类型后置语法</h4>
<p><strong>总述</strong></p>
<p>只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法.</p>
<p><strong>定义</strong></p>
<p>C++ 现在允许两种不同的函数声明方式. 以往的写法是将返回类型置于函数名之前. 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<p>C++11 引入了这一新的形式. 现在可以在函数名前使用 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 关键字, 在参数列表之后后置返回类型. 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>后置返回类型为函数作用域. 对于像 <code class="docutils literal notranslate"><span class="pre">int</span></code> 这样简单的类型, 两种写法没有区别. 但对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别.</p>
<p><strong>优点</strong></p>
<p>后置返回类型是显式地指定 <a class="reference internal" href="contents.html#lambda-expressions"><span class="std std-ref">Lambda 表达式</span></a> 的返回值的唯一方式. 某些情况下, 编译器可以自动推导出 Lambda 表达式的返回类型, 但并不是在所有的情况下都能实现. 即使编译器能够自动推导, 显式地指定返回类型也能让读者更明了.</p>
<p>有时在已经出现了的函数参数列表之后指定返回类型, 能够让书写更简单, 也更易读, 尤其是在返回类型依赖于模板参数时. 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">auto</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">);</span>
</pre></div>
</div>
<p>对比下面的例子:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">declval</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">declval</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&amp;&gt;</span><span class="p">())</span> <span class="n">add</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">);</span>
</pre></div>
</div>
<p><strong>缺点</strong></p>
<p>后置返回类型相对来说是非常新的语法, 而且在 C 和 Java 中都没有相似的写法, 因此可能对读者来说比较陌生.</p>
<p>在已有的代码中有大量的函数声明, 你不可能把它们都用新的语法重写一遍. 因此实际的做法只能是使用旧的语法或者新旧混用. 在这种情况下, 只使用一种版本是相对来说更规整的形式.</p>
<p><strong>结论</strong></p>
<p>在大部分情况下, 应当继续使用以往的函数声明写法, 即将返回类型置于函数名前. 只有在必需的时候 (如 Lambda 表达式) 或者使用后置语法能够简化书写并且提高易读性的时候才使用新的返回类型后置语法. 但是后一种情况一般来说是很少见的, 大部分时候都出现在相当复杂的模板代码中, 而多数情况下不鼓励写这样 <a class="reference internal" href="contents.html#template-metaprogramming"><span class="std std-ref">复杂的模板代码</span></a>.</p>
</div>
</div>
<span id="document-google-cpp-styleguide/magic"></span><div class="section" id="google">
<h3>5. 来自 Google 的奇技</h3>
<p>Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.</p>
<div class="section" id="section-1">
<h4>5.1. 所有权与智能指针</h4>
<p><strong>&gt; 总述</strong></p>
<p>动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.</p>
<p><strong>&gt; 定义</strong></p>
<p>所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.</p>
<p>智能指针是一个通过重载 <code class="docutils literal notranslate"><span class="pre">*</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> 运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位. <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a> 是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当 <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> 离开作用域时, 对象就会被销毁. <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> 不能被复制, 但可以把它移动（move）给新所有主. <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/shared_ptr">std::shared_ptr</a> 同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.</p>
<p><strong>&gt; 优点</strong></p>
<ul class="simple">
<li>如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.</li>
<li>传递对象的所有权, 开销比复制来得小, 如果可以复制的话.</li>
<li>传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.</li>
<li>如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.</li>
<li>可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.</li>
<li>对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.</li>
</ul>
<p><strong>&gt; 缺点</strong></p>
<ul class="simple">
<li>不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.</li>
<li>其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.</li>
<li>如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.</li>
<li>如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.</li>
<li><code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> 的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.</li>
<li>如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.</li>
<li>所有权共享机制的登记工作在运行时进行, 开销可能相当大.</li>
<li>某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.</li>
<li>智能指针并不能够完全代替原生指针.</li>
</ul>
<p><strong>&gt; 结论</strong></p>
<p>如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用 <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> 来明确所有权传递, 例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">FooFactory</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">FooConsumer</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说 <code class="docutils literal notranslate"><span class="pre">std::shared_ptr&lt;const</span> <span class="pre">Foo&gt;</span></code> ）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用 <code class="docutils literal notranslate"><span class="pre">std::shared_ptr</span></code> .</p>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">std::auto_ptr</span></code>, 使用 <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code> 代替它.</p>
</div>
<div class="section" id="cpplint">
<h4>5.2. Cpplint</h4>
<p><strong>&gt; 总述</strong></p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">cpplint.py</span></code> 检查风格错误.</p>
<p><strong>&gt; 说明</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">cpplint.py</span></code> 是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加 <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">NOLINT</span></code>, 或在上一行加 <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">NOLINTNEXTLINE</span></code>, 可以忽略报错.</p>
<p>某些项目会指导你如何使用他们的项目工具运行 <code class="docutils literal notranslate"><span class="pre">cpplint.py</span></code>. 如果你参与的项目没有提供, 你可以单独下载 <a class="reference external" href="http://github.com/google/styleguide/blob/gh-pages/cpplint/cpplint.py">cpplint.py</a>.</p>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>把智能指针当成对象来看待的话, 就很好领会它与所指对象之间的关系了.</li>
<li>原来 Rust 的 Ownership 思想是受到了 C++ 智能指针的很大启发啊.</li>
<li><code class="docutils literal notranslate"><span class="pre">scoped_ptr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">auto_ptr</span></code> 已过时.  现在是 <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">uniqued_ptr</span></code> 的天下了.</li>
<li>按本文来说, 似乎除了智能指针, 还有其它所有权机制, 值得留意.</li>
<li>Arch Linux 用户注意了, AUR 有对 cpplint 打包.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/others"></span><div class="section" id="c">
<h3>6. 其他 C++ 特性</h3>
<div class="section" id="section-1">
<h4>6.1. 引用参数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所有按引用传递的参数必须加上 <code class="docutils literal notranslate"><span class="pre">const</span></code>.</p>
</div>
<p>定义:</p>
<blockquote>
<div>在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">*pval)</span></code>. 在 C++ 中, 函数还可以声明引用参数: <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">foo(int</span> <span class="pre">&amp;val)</span></code>.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>定义引用参数防止出现 <code class="docutils literal notranslate"><span class="pre">(*pval)++</span></code> 这样丑陋的代码. 像拷贝构造函数这样的应用也是必需的. 而且更明确, 不接受 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 指针.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>函数参数列表中, 所有引用参数都必须是 <code class="docutils literal notranslate"><span class="pre">const</span></code>:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">in</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">out</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>事实上这在 Google Code 是一个硬性约定: 输入参数是值参或 <code class="docutils literal notranslate"><span class="pre">const</span></code> 引用, 输出参数为指针. 输入参数可以是 <code class="docutils literal notranslate"><span class="pre">const</span></code> 指针, 但决不能是非 <code class="docutils literal notranslate"><span class="pre">const</span></code> 的引用参数，除非用于交换，比如 <code class="docutils literal notranslate"><span class="pre">swap()</span></code>.</p>
<p>有时候，在输入形参中用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code> 指针比 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code> 更明智。比如：</p>
<ul class="simple">
<li>您会传 null 指针。</li>
<li>函数要把指针或对地址的引用赋值给输入形参。</li>
</ul>
<p>总之大多时候输入形参往往是 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T&amp;</span></code>. 若用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code> 说明输入另有处理。所以若您要用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">T*</span></code>, 则应有理有据，否则会害得读者误解。</p>
</div></blockquote>
</div>
<div class="section" id="section-2">
<h4>6.2. 右值引用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只在定义移动构造函数与移动赋值操作时使用右值引用. 不要使用 <code class="docutils literal notranslate"><span class="pre">std::forward</span></code>.</p>
</div>
<p>定义:</p>
<blockquote>
<div>右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">f(string&amp;&amp;</span> <span class="pre">s)</span></code>; 声明了一个其参数是一个字符串的右值引用的函数.</div></blockquote>
<p>优点:</p>
<blockquote>
<div><p>用于定义移动构造函数 (使用类的右值引用进行构造的函数) 使得移动一个值而非拷贝之成为可能. 例如, 如果 <code class="docutils literal notranslate"><span class="pre">v1</span></code> 是一个 <code class="docutils literal notranslate"><span class="pre">vector&lt;string&gt;</span></code>, 则 <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">v2(std::move(v1))</span></code> 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升.</p>
<p>右值引用使得编写通用的函数封装来转发其参数到另外一个函数成为可能, 无论其参数是否是临时对象都能正常工作.</p>
<p>右值引用能实现可移动但不可拷贝的类型, 这一特性对那些在拷贝方面没有实际需求, 但有时又需要将它们作为函数参数传递或塞入容器的类型很有用.</p>
<p>要高效率地使用某些标准库类型, 例如 <code class="docutils literal notranslate"><span class="pre">std::unique_ptr</span></code>, <code class="docutils literal notranslate"><span class="pre">std::move</span></code> 是必需的.</p>
</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>右值引用是一个相对比较新的特性 (由 C++11 引入), 它尚未被广泛理解. 类似引用崩溃, 移动构造函数的自动推导这样的规则都是很复杂的.</div></blockquote>
<p>结论:</p>
<blockquote>
<div>只在定义移动构造函数与移动赋值操作时使用右值引用, 不要使用 <code class="docutils literal notranslate"><span class="pre">std::forward</span></code> 功能函数. 你可能会使用 <code class="docutils literal notranslate"><span class="pre">std::move</span></code> 来表示将值从一个对象移动而不是复制到另一个对象.</div></blockquote>
</div>
<div class="section" id="section-3">
<span id="function-overloading"></span><h4>6.3. 函数重载</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">若要用好函数重载，最好能让读者一看调用点（call site）就胸有成竹，不用花心思猜测调用的重载函数到底是哪一种。该规则适用于构造函数。</p>
</div>
<p>定义:</p>
<blockquote>
<div><p>你可以编写一个参数类型为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">string&amp;</span></code> 的函数, 然后用另一个参数类型为 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">char*</span></code> 的函数重载它:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">Analyze</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">textlen</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p>优点:</p>
<blockquote>
<div>通过重载参数不同的同名函数, 令代码更加直观. 模板化代码需要重载, 同时为使用者带来便利.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>如果函数单单靠不同的参数类型而重载（acgtyrant 注：这意味着参数数量不变），读者就得十分熟悉 C++ 五花八门的匹配规则，以了解匹配过程具体到底如何。另外，当派生类只重载了某个函数的部分变体，继承语义容易令人困惑。</div></blockquote>
<p>结论:</p>
<blockquote>
<div>如果您打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 <code class="docutils literal notranslate"><span class="pre">AppendString()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AppendInt()</span></code> 等， 而不是一口气重载多个 <code class="docutils literal notranslate"><span class="pre">Append()</span></code>.</div></blockquote>
</div>
<div class="section" id="section-4">
<h4>6.4. 缺省参数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不允许使用缺省函数参数，少数极端情况除外。尽可能改用函数重载。</p>
</div>
<p>优点:</p>
<blockquote>
<div>当您有依赖缺省参数的函数时，您也许偶尔会修改修改这些缺省参数。通过缺省参数，不用再为个别情况而特意定义一大堆函数了。与函数重载相比，缺省参数语法更为清晰，代码少，也很好地区分了「必选参数」和「可选参数」。</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>缺省参数会干扰函数指针，害得后者的函数签名（function signature）往往对不上所实际要调用的函数签名。即在一个现有函数添加缺省参数，就会改变它的类型，那么调用其地址的代码可能会出错，不过函数重载就没这问题了。此外，缺省参数会造成臃肿的代码，毕竟它们在每一个调用点（call site）都有重复（acgtyrant 注：我猜可能是因为调用函数的代码表面上看来省去了不少参数，但编译器在编译时还是会在每一个调用代码里统统补上所有默认实参信息，造成大量的重复）。函数重载正好相反，毕竟它们所谓的「缺省参数」只会出现在函数定义里。</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>由于缺点并不是很严重，有些人依旧偏爱缺省参数胜于函数重载。所以除了以下情况，我们要求必须显式提供所有参数（acgtyrant 注：即不能再通过缺省参数来省略参数了）。</p>
<p>其一，位于 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。</p>
<p>其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。</p>
<p>其三，可以用来模拟变长数组。</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 通过空 AlphaNum 以支持四个形参</span>
<span class="n">string</span> <span class="nf">StrCat</span><span class="p">(</span><span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">gEmptyAlphaNum</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">c</span> <span class="o">=</span> <span class="n">gEmptyAlphaNum</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">AlphaNum</span> <span class="o">&amp;</span><span class="n">d</span> <span class="o">=</span> <span class="n">gEmptyAlphaNum</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="alloca">
<h4>6.5. 变长数组和 alloca()</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不允许使用变长数组和 <code class="docutils literal notranslate"><span class="pre">alloca()</span></code>.</p>
</div>
<p>优点:</p>
<blockquote>
<div>变长数组具有浑然天成的语法. 变长数组和 <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> 也都很高效.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>变长数组和 <code class="docutils literal notranslate"><span class="pre">alloca()</span></code> 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.</div></blockquote>
<p>结论:</p>
<blockquote>
<div>改用更安全的分配器（allocator），就像 <code class="docutils literal notranslate"><span class="pre">std::vector</span></code> 或 <code class="docutils literal notranslate"><span class="pre">std::unique_ptr&lt;T[]&gt;</span></code>.</div></blockquote>
</div>
<div class="section" id="section-5">
<h4>6.6. 友元</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们允许合理的使用友元类及友元函数.</p>
</div>
<p>通常友元应该定义在同一文件内, 避免代码读者跑到其它文件查找使用该私有成员的类. 经常用到友元的一个地方是将 <code class="docutils literal notranslate"><span class="pre">FooBuilder</span></code> 声明为 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的友元, 以便 <code class="docutils literal notranslate"><span class="pre">FooBuilder</span></code> 正确构造 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的内部状态, 而无需将该状态暴露出来. 某些情况下, 将一个单元测试类声明成待测类的友元会很方便.</p>
<p>友元扩大了 (但没有打破) 类的封装边界. 某些情况下, 相对于将类成员声明为 <code class="docutils literal notranslate"><span class="pre">public</span></code>, 使用友元是更好的选择, 尤其是如果你只允许另一个类访问该类的私有成员时. 当然, 大多数类都只应该通过其提供的公有成员进行互操作.</p>
</div>
<div class="section" id="section-6">
<span id="exceptions"></span><h4>6.7. 异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们不使用 C++ 异常.</p>
</div>
<p>优点:</p>
<blockquote>
<div><ul class="simple">
<li>异常允许应用高层决定如何处理在底层嵌套函数中「不可能发生」的失败（failures），不用管那些含糊且容易出错的错误代码（acgtyrant 注：error code, 我猜是Ｃ语言函数返回的非零 int 值）。</li>
<li>很多现代语言都用异常。引入异常使得 C++ 与 Python, Java 以及其它类 C++ 的语言更一脉相承。</li>
<li>有些第三方 C++ 库依赖异常，禁用异常就不好用了。</li>
<li>异常是处理构造函数失败的唯一途径。虽然可以用工厂函数（acgtyrant 注：factory function, 出自 C++ 的一种设计模式，即「简单工厂模式」）或 <code class="docutils literal notranslate"><span class="pre">Init()</span></code> 方法代替异常, 但是前者要求在堆栈分配内存，后者会导致刚创建的实例处于 ”无效“ 状态。</li>
<li>在测试框架里很好用。</li>
</ul>
</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><ul class="simple">
<li>在现有函数中添加 <code class="docutils literal notranslate"><span class="pre">throw</span></code> 语句时，您必须检查所有调用点。要么让所有调用点统统具备最低限度的异常安全保证，要么眼睁睁地看异常一路欢快地往上跑，最终中断掉整个程序。举例，<code class="docutils literal notranslate"><span class="pre">f()</span></code> 调用 <code class="docutils literal notranslate"><span class="pre">g()</span></code>, <code class="docutils literal notranslate"><span class="pre">g()</span></code> 又调用 <code class="docutils literal notranslate"><span class="pre">h()</span></code>, 且 <code class="docutils literal notranslate"><span class="pre">h</span></code> 抛出的异常被 <code class="docutils literal notranslate"><span class="pre">f</span></code> 捕获。当心 <code class="docutils literal notranslate"><span class="pre">g</span></code>, 否则会没妥善清理好。</li>
<li>还有更常见的，异常会彻底扰乱程序的执行流程并难以判断，函数也许会在您意料不到的地方返回。您或许会加一大堆何时何处处理异常的规定来降低风险，然而开发者的记忆负担更重了。</li>
<li>异常安全需要RAII和不同的编码实践. 要轻松编写出正确的异常安全代码需要大量的支持机制. 更进一步地说, 为了避免读者理解整个调用表, 异常安全必须隔绝从持续状态写到 “提交” 状态的逻辑. 这一点有利有弊 (因为你也许不得不为了隔离提交而混淆代码). 如果允许使用异常, 我们就不得不时刻关注这样的弊端, 即使有时它们并不值得.</li>
<li>启用异常会增加二进制文件数据，延长编译时间（或许影响小），还可能加大地址空间的压力。</li>
<li>滥用异常会变相鼓励开发者去捕捉不合时宜，或本来就已经没法恢复的「伪异常」。比如，用户的输入不符合格式要求时，也用不着抛异常。如此之类的伪异常列都列不完。</li>
</ul>
</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>从表面上看来，使用异常利大于弊, 尤其是在新项目中. 但是对于现有代码, 引入异常会牵连到所有相关代码. 如果新项目允许异常向外扩散, 在跟以前未使用异常的代码整合时也将是个麻烦. 因为 Google 现有的大多数 C++ 代码都没有异常处理, 引入带有异常处理的新代码相当困难.</p>
<p>鉴于 Google 现有代码不接受异常, 在现有代码中使用异常比在新项目中使用的代价多少要大一些. 迁移过程比较慢, 也容易出错. 我们不相信异常的使用有效替代方案, 如错误代码, 断言等会造成严重负担.</p>
<p>我们并不是基于哲学或道德层面反对使用异常, 而是在实践的基础上. 我们希望在 Google 使用我们自己的开源项目, 但项目中使用异常会为此带来不便, 因此我们也建议不要在 Google 的开源项目中使用异常. 如果我们需要把这些项目推倒重来显然不太现实.</p>
<p>对于 Windows 代码来说, 有个 <a class="reference internal" href="contents.html#windows-code"><span class="std std-ref">特例</span></a>.</p>
</div></blockquote>
<p>(YuleFox 注: 对于异常处理, 显然不是短短几句话能够说清楚的, 以构造函数为例, 很多 C++ 书籍上都提到当构造失败时只有异常可以处理, Google 禁止使用异常这一点, 仅仅是为了自身的方便, 说大了, 无非是基于软件管理成本上, 实际使用中还是自己决定)</p>
</div>
<div class="section" id="section-7">
<span id="rtti"></span><h4>6.8. 运行时类型识别</h4>
<blockquote>
<div>TODO</div></blockquote>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们禁止使用 RTTI.</p>
</div>
<p>定义:</p>
<blockquote>
<div>RTTI 允许程序员在运行时识别 C++ 类对象的类型. 它通过使用 <code class="docutils literal notranslate"><span class="pre">typeid</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> 完成.</div></blockquote>
<p>优点:</p>
<blockquote>
<div><p>RTTI 的标准替代 (下面将描述) 需要对有问题的类层级进行修改或重构. 有时这样的修改并不是我们所想要的, 甚至是不可取的, 尤其是在一个已经广泛使用的或者成熟的代码中.</p>
<p>RTTI 在某些单元测试中非常有用. 比如进行工厂类测试时, 用来验证一个新建对象是否为期望的动态类型. RTTI 对于管理对象和派生对象的关系也很有用.</p>
<p>在考虑多个抽象对象时 RTTI 也很好用. 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">Base</span><span class="o">::</span><span class="n">Equal</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">Derived</span><span class="o">::</span><span class="n">Equal</span><span class="p">(</span><span class="n">Base</span><span class="o">*</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Derived</span><span class="o">*</span> <span class="n">that</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">that</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><p>在运行时判断类型通常意味着设计问题. 如果你需要在运行期间确定一个对象的类型, 这通常说明你需要考虑重新设计你的类.</p>
<p>随意地使用 RTTI 会使你的代码难以维护. 它使得基于类型的判断树或者 switch 语句散布在代码各处. 如果以后要进行修改, 你就必须检查它们.</p>
</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>RTTI 有合理的用途但是容易被滥用, 因此在使用时请务必注意. 在单元测试中可以使用 RTTI, 但是在其他代码中请尽量避免. 尤其是在新代码中, 使用 RTTI 前务必三思. 如果你的代码需要根据不同的对象类型执行不同的行为的话, 请考虑用以下的两种替代方案之一查询类型:</p>
<p>虚函数可以根据子类类型的不同而执行不同代码. 这是把工作交给了对象本身去处理.</p>
<p>如果这一工作需要在对象之外完成, 可以考虑使用双重分发的方案, 例如使用访问者设计模式. 这就能够在对象之外进行类型判断.</p>
<p>如果程序能够保证给定的基类实例实际上都是某个派生类的实例, 那么就可以自由使用 dynamic_cast. 在这种情况下, 使用 dynamic_cast 也是一种替代方案.</p>
<p>基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">D1</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">D2</span><span class="p">))</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">D3</span><span class="p">))</span> <span class="p">{</span>
<span class="p">...</span>
</pre></div>
</div>
<p>一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.</p>
<p>不要去手工实现一个类似 RTTI 的方案. 反对 RTTI 的理由同样适用于这些方案, 比如带类型标签的类继承体系. 而且, 这些方案会掩盖你的真实意图.</p>
</div></blockquote>
</div>
<div class="section" id="section-8">
<h4>6.9. 类型转换</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 C++ 的类型转换, 如 <code class="docutils literal notranslate"><span class="pre">static_cast&lt;&gt;()</span></code>. 不要使用 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">(int)x</span></code> 或 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">int(x)</span></code> 等转换方式;</p>
</div>
<p>定义:</p>
<blockquote>
<div>C++ 采用了有别于 C 的类型转换机制, 对转换操作进行归类.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>C 语言的类型转换问题在于模棱两可的操作; 有时是在做强制转换 (如 <code class="docutils literal notranslate"><span class="pre">(int)3.5</span></code>), 有时是在做类型转换 (如 <code class="docutils literal notranslate"><span class="pre">(int)&quot;hello&quot;</span></code>). 另外, C++ 的类型转换在查找时更醒目.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>恶心的语法.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>不要使用 C 风格类型转换. 而应该使用 C++ 风格.</p>
<blockquote>
<div><ul class="simple">
<li>用 <code class="docutils literal notranslate"><span class="pre">static_cast</span></code> 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.</li>
<li>用 <code class="docutils literal notranslate"><span class="pre">const_cast</span></code> 去掉 <code class="docutils literal notranslate"><span class="pre">const</span></code> 限定符.</li>
<li>用 <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.</li>
</ul>
</div></blockquote>
<p>至于 <code class="docutils literal notranslate"><span class="pre">dynamic_cast</span></code> 参见 <a class="reference internal" href="#rtti"><span class="std std-ref">6.8. 运行时类型识别</span></a>.</p>
</div></blockquote>
</div>
<div class="section" id="section-9">
<span id="streams"></span><h4>6.10. 流</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只在记录日志时使用流.</p>
</div>
<p>定义:</p>
<blockquote>
<div>流用来替代 <code class="docutils literal notranslate"><span class="pre">printf()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">scanf()</span></code>.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>有了流, 在打印时不需要关心对象的类型. 不用担心格式化字符串与参数列表不匹配 (虽然在 gcc 中使用 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 也不存在这个问题). 流的构造和析构函数会自动打开和关闭对应的文件.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>流使得 <code class="docutils literal notranslate"><span class="pre">pread()</span></code> 等功能函数很难执行. 如果不使用 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 风格的格式化字符串, 某些格式化操作 (尤其是常用的格式字符串 <code class="docutils literal notranslate"><span class="pre">%.*s</span></code>) 用流处理性能是很低的. 流不支持字符串操作符重新排序 (%1s), 而这一点对于软件国际化很有用.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>不要使用流, 除非是日志接口需要. 使用 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 之类的代替.</p>
<p>使用流还有很多利弊, 但代码一致性胜过一切. 不要在代码中使用流.</p>
</div></blockquote>
<p>拓展讨论:</p>
<blockquote>
<div><p>对这一条规则存在一些争论, 这儿给出点深层次原因. 回想一下唯一性原则 (Only One Way): 我们希望在任何时候都只使用一种确定的 I/O 类型, 使代码在所有 I/O 处都保持一致. 因此, 我们不希望用户来决定是使用流还是 <code class="docutils literal notranslate"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></code>. 相反, 我们应该决定到底用哪一种方式. 把日志作为特例是因为日志是一个非常独特的应用, 还有一些是历史原因.</p>
<p>流的支持者们主张流是不二之选, 但观点并不是那么清晰有力. 他们指出的流的每个优势也都是其劣势. 流最大的优势是在输出时不需要关心打印对象的类型. 这是一个亮点. 同时, 也是一个不足: 你很容易用错类型, 而编译器不会报警. 使用流时容易造成的这类错误:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">this</span><span class="p">;</span>   <span class="c1">// 输出地址</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">// 输出值</span>
</pre></div>
</div>
</div></blockquote>
<p>由于 <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> 被重载, 编译器不会报错. 就因为这一点我们反对使用操作符重载.</p>
<p>有人说 <code class="docutils literal notranslate"><span class="pre">printf</span></code> 的格式化丑陋不堪, 易读性差, 但流也好不到哪儿去. 看看下面两段代码吧, 实现相同的功能, 哪个更清晰?</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error connecting to &#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span>
     <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">);</span>

<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Error connecting to &#39;%s:%u: %s&quot;</span><span class="p">,</span>
        <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hostname</span><span class="p">.</span><span class="n">second</span><span class="p">,</span>
        <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));</span>
</pre></div>
</div>
</div></blockquote>
<p>你可能会说, “把流封装一下就会比较好了”, 这儿可以, 其他地方呢? 而且不要忘了, 我们的目标是使语言更紧凑, 而不是添加一些别人需要学习的新装备.</p>
<p>每一种方式都是各有利弊, “没有最好, 只有更适合”. 简单性原则告诫我们必须从中选择其一, 最后大多数决定采用 <code class="docutils literal notranslate"><span class="pre">printf</span> <span class="pre">+</span> <span class="pre">read/write</span></code>.</p>
</div></blockquote>
</div>
<div class="section" id="section-10">
<h4>6.11. 前置自增和自减</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对于迭代器和其他模板对象使用前缀形式 (<code class="docutils literal notranslate"><span class="pre">++i</span></code>) 的自增, 自减运算符.</p>
</div>
<p>定义:</p>
<blockquote>
<div>对于变量在自增 (<code class="docutils literal notranslate"><span class="pre">++i</span></code> 或 <code class="docutils literal notranslate"><span class="pre">i++</span></code>) 或自减 (<code class="docutils literal notranslate"><span class="pre">--i</span></code> 或 <code class="docutils literal notranslate"><span class="pre">i--</span></code>) 后表达式的值又没有没用到的情况下, 需要确定到底是使用前置还是后置的自增 (自减).</div></blockquote>
<p>优点:</p>
<blockquote>
<div>不考虑返回值的话, 前置自增 (<code class="docutils literal notranslate"><span class="pre">++i</span></code>) 通常要比后置自增 (<code class="docutils literal notranslate"><span class="pre">i++</span></code>) 效率更高. 因为后置自增 (或自减) 需要对表达式的值 <code class="docutils literal notranslate"><span class="pre">i</span></code> 进行一次拷贝. 如果 <code class="docutils literal notranslate"><span class="pre">i</span></code> 是迭代器或其他非数值类型, 拷贝的代价是比较大的. 既然两种自增方式实现的功能一样, 为什么不总是使用前置自增呢?</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>在 C 开发中, 当表达式的值未被使用时, 传统的做法是使用后置自增, 特别是在 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环中. 有些人觉得后置自增更加易懂, 因为这很像自然语言, 主语 (<code class="docutils literal notranslate"><span class="pre">i</span></code>) 在谓语动词 (<code class="docutils literal notranslate"><span class="pre">++</span></code>) 前.</div></blockquote>
<p>结论:</p>
<blockquote>
<div>对简单数值 (非对象), 两种都无所谓. 对迭代器和模板类型, 使用前置自增 (自减).</div></blockquote>
</div>
<div class="section" id="const">
<h4>6.12. <code class="docutils literal notranslate"><span class="pre">const</span></code> 用法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">我们强烈建议你在任何可能的情况下都要使用 <code class="docutils literal notranslate"><span class="pre">const</span></code>. 此外有时改用 C++11 推出的 constexpr 更好。</p>
</div>
<p>定义:</p>
<blockquote>
<div>在声明的变量或参数前加上关键字 <code class="docutils literal notranslate"><span class="pre">const</span></code> 用于指明变量值不可被篡改 (如 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">foo</span></code> ). 为类中的函数加上 <code class="docutils literal notranslate"><span class="pre">const</span></code> 限定符表明该函数不会修改类成员变量的状态 (如 <code class="docutils literal notranslate"><span class="pre">class</span> <span class="pre">Foo</span> <span class="pre">{</span> <span class="pre">int</span> <span class="pre">Bar(char</span> <span class="pre">c)</span> <span class="pre">const;</span> <span class="pre">};</span></code>).</div></blockquote>
<p>优点:</p>
<blockquote>
<div>大家更容易理解如何使用变量. 编译器可以更好地进行类型检测, 相应地, 也能生成更好的代码. 人们对编写正确的代码更加自信, 因为他们知道所调用的函数被限定了能或不能修改变量值. 即使是在无锁的多线程编程中, 人们也知道什么样的函数是安全的.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">const</span></code> 是入侵性的: 如果你向一个函数传入 <code class="docutils literal notranslate"><span class="pre">const</span></code> 变量, 函数原型声明中也必须对应 <code class="docutils literal notranslate"><span class="pre">const</span></code> 参数 (否则变量需要 <code class="docutils literal notranslate"><span class="pre">const_cast</span></code> 类型转换), 在调用库函数时显得尤其麻烦.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">const</span></code> 变量, 数据成员, 函数和参数为编译时类型检测增加了一层保障; 便于尽早发现错误. 因此, 我们强烈建议在任何可能的情况下使用 <code class="docutils literal notranslate"><span class="pre">const</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li>如果函数不会修改你传入的引用或指针类型参数, 该参数应声明为 <code class="docutils literal notranslate"><span class="pre">const</span></code>.</li>
<li>尽可能将函数声明为 <code class="docutils literal notranslate"><span class="pre">const</span></code>. 访问函数应该总是 <code class="docutils literal notranslate"><span class="pre">const</span></code>. 其他不会修改任何数据成员, 未调用非 <code class="docutils literal notranslate"><span class="pre">const</span></code> 函数, 不会返回数据成员非 <code class="docutils literal notranslate"><span class="pre">const</span></code> 指针或引用的函数也应该声明成 <code class="docutils literal notranslate"><span class="pre">const</span></code>.</li>
<li>如果数据成员在对象构造之后不再发生变化, 可将其定义为 <code class="docutils literal notranslate"><span class="pre">const</span></code>.</li>
</ul>
</div></blockquote>
<p>然而, 也不要发了疯似的使用 <code class="docutils literal notranslate"><span class="pre">const</span></code>. 像 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">*</span> <span class="pre">const</span> <span class="pre">x;</span></code> 就有些过了, 虽然它非常精确的描述了常量 <code class="docutils literal notranslate"><span class="pre">x</span></code>. 关注真正有帮助意义的信息: 前面的例子写成 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int**</span> <span class="pre">x</span></code> 就够了.</p>
<p>关键字 <code class="docutils literal notranslate"><span class="pre">mutable</span></code> 可以使用, 但是在多线程中是不安全的, 使用时首先要考虑线程安全.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">const</span></code> 的位置:</p>
<blockquote>
<div><p>有人喜欢 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">const</span> <span class="pre">*foo</span></code> 形式, 不喜欢 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">int*</span> <span class="pre">foo</span></code>, 他们认为前者更一致因此可读性也更好: 遵循了 <code class="docutils literal notranslate"><span class="pre">const</span></code> 总位于其描述的对象之后的原则. 但是一致性原则不适用于此, “不要过度使用” 的声明可以取消大部分你原本想保持的一致性. 将 <code class="docutils literal notranslate"><span class="pre">const</span></code> 放在前面才更易读, 因为在自然语言中形容词 (<code class="docutils literal notranslate"><span class="pre">const</span></code>) 是在名词 (<code class="docutils literal notranslate"><span class="pre">int</span></code>) 之前.</p>
<p>这是说, 我们提倡但不强制 <code class="docutils literal notranslate"><span class="pre">const</span></code> 在前. 但要保持代码的一致性! (Yang.Y 注: 也就是不要在一些地方把 <code class="docutils literal notranslate"><span class="pre">const</span></code> 写在类型前面, 在其他地方又写在后面, 确定一种写法, 然后保持一致.)</p>
</div></blockquote>
</div>
<div class="section" id="constexpr">
<h4>6.13. <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 用法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>
</div>
<p>定义:</p>
<blockquote>
<div>变量可以被声明成 constexpr 以表示它是真正意义上的常量，即在编译时和运行时都不变。函数或构造函数也可以被声明成 constexpr, 以用来定义 constexpr 变量。</div></blockquote>
<p>优点:</p>
<blockquote>
<div>如今 constexpr 就可以定义浮点式的真・常量，不用再依赖字面值了；也可以定义用户自定义类型上的常量；甚至也可以定义函数调用所返回的常量。</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>若过早把变量优化成 constexpr 变量，将来又要把它改为常规变量时，挺麻烦的；当前对constexpr函数和构造函数中允许的限制可能会导致这些定义中解决的方法模糊。</div></blockquote>
<p>结论:</p>
<blockquote>
<div>靠 constexpr 特性，方才实现了 C++ 在接口上打造真正常量机制的可能。好好用 constexpr 来定义真・常量以及支持常量的函数。避免复杂的函数定义，以使其能够与constexpr一起使用。 千万别痴心妄想地想靠 constexpr 来强制代码「内联」。</div></blockquote>
</div>
<div class="section" id="section-11">
<h4>6.14. 整型</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">C++ 内建整型中, 仅使用 <code class="docutils literal notranslate"><span class="pre">int</span></code>. 如果程序中需要不同大小的变量, 可以使用 <code class="docutils literal notranslate"><span class="pre">&lt;stdint.h&gt;</span></code> 中长度精确的整型, 如 <code class="docutils literal notranslate"><span class="pre">int16_t</span></code>.如果您的变量可能不小于 2^31 (2GiB), 就用 64 位变量比如 <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>. 此外要留意，哪怕您的值并不会超出 int 所能够表示的范围，在计算过程中也可能会溢出。所以拿不准时，干脆用更大的类型。</p>
</div>
<p>定义:</p>
<blockquote>
<div>C++ 没有指定整型的大小. 通常人们假定 <code class="docutils literal notranslate"><span class="pre">short</span></code> 是 16 位, <code class="docutils literal notranslate"><span class="pre">int</span></code> 是 32 位, <code class="docutils literal notranslate"><span class="pre">long</span></code> 是 32 位, <code class="docutils literal notranslate"><span class="pre">long</span> <span class="pre">long</span></code> 是 64 位.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>保持声明统一.</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>C++ 中整型大小因编译器和体系结构的不同而不同.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">&lt;stdint.h&gt;</span></code> 定义了 <code class="docutils literal notranslate"><span class="pre">int16_t</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code>, <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> 等整型, 在需要确保整型大小时可以使用它们代替 <code class="docutils literal notranslate"><span class="pre">short</span></code>, <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> 等. 在 C 整型中, 只使用 <code class="docutils literal notranslate"><span class="pre">int</span></code>. 在合适的情况下, 推荐使用标准类型如 <code class="docutils literal notranslate"><span class="pre">size_t</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ptrdiff_t</span></code>.</p>
<p>如果已知整数不会太大, 我们常常会使用 <code class="docutils literal notranslate"><span class="pre">int</span></code>, 如循环计数. 在类似的情况下使用原生类型 <code class="docutils literal notranslate"><span class="pre">int</span></code>. 你可以认为 <code class="docutils literal notranslate"><span class="pre">int</span></code> 至少为 32 位, 但不要认为它会多于 <code class="docutils literal notranslate"><span class="pre">32</span></code> 位. 如果需要 64 位整型, 用 <code class="docutils literal notranslate"><span class="pre">int64_t</span></code> 或 <code class="docutils literal notranslate"><span class="pre">uint64_t</span></code>.</p>
<p>对于大整数, 使用 <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>.</p>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">uint32_t</span></code> 等无符号整型, 除非你是在表示一个位组而不是一个数值, 或是你需要定义二进制补码溢出. 尤其是不要为了指出数值永不会为负, 而使用无符号类型. 相反, 你应该使用断言来保护数据.</p>
<p>如果您的代码涉及容器返回的大小（size），确保其类型足以应付容器各种可能的用法。拿不准时，类型越大越好。</p>
<p>小心整型类型转换和整型提升（acgtyrant 注：integer promotions, 比如 <code class="docutils literal notranslate"><span class="pre">int</span></code> 与 <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> 运算时，前者被提升为 <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code> 而有可能溢出），总有意想不到的后果。</p>
</div></blockquote>
<p>关于无符号整数:</p>
<blockquote>
<div><p>有些人, 包括一些教科书作者, 推荐使用无符号类型表示非负数. 这种做法试图达到自我文档化. 但是, 在 C 语言中, 这一优点被由其导致的 bug 所淹没. 看看下面的例子:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">Length</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">...</span>
</pre></div>
</div>
</div></blockquote>
<p>上述循环永远不会退出! 有时 gcc 会发现该 bug 并报警, 但大部分情况下都不会. 类似的 bug 还会出现在比较有符合变量和无符号变量时. 主要是 C 的类型提升机制会致使无符号类型的行为出乎你的意料.</p>
<p>因此, 使用断言来指出变量为非负数, 而不是使用无符号型!</p>
</div></blockquote>
</div>
<div class="section" id="section-12">
<h4>6.15. 64 位下的可移植性</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">代码应该对 64 位和 32 位系统友好. 处理打印, 比较, 结构体对齐时应切记:</p>
</div>
<ul>
<li><p class="first">对于某些类型, <code class="docutils literal notranslate"><span class="pre">printf()</span></code> 的指示符在 32 位和 64 位系统上可移植性不是很好. C99 标准定义了一些可移植的格式化指示符. 不幸的是, MSVC 7.1 并非全部支持, 而且标准中也有所遗漏, 所以有时我们不得不自己定义一个丑陋的版本 (头文件 <code class="docutils literal notranslate"><span class="pre">inttypes.h</span></code> 仿标准风格):</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// printf macros for size_t, in the style of inttypes.h</span>
<span class="cp">#ifdef _LP64</span>
<span class="cp">#define __PRIS_PREFIX &quot;z&quot;</span>
<span class="cp">#else</span>
<span class="cp">#define __PRIS_PREFIX</span>
<span class="cp">#endif</span>

<span class="c1">// Use these macros after a % in a printf format string</span>
<span class="c1">// to get correct 32/64 bit behavior, like this:</span>
<span class="c1">// size_t size = records.size();</span>
<span class="c1">// printf(&quot;%&quot;PRIuS&quot;\n&quot;, size);</span>
<span class="cp">#define PRIdS __PRIS_PREFIX &quot;d&quot;</span>
<span class="cp">#define PRIxS __PRIS_PREFIX &quot;x&quot;</span>
<span class="cp">#define PRIuS __PRIS_PREFIX &quot;u&quot;</span>
<span class="cp">#define PRIXS __PRIS_PREFIX &quot;X&quot;</span>
<span class="cp">#define PRIoS __PRIS_PREFIX &quot;o&quot;</span>
</pre></div>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="25%" />
<col width="31%" />
<col width="21%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">不要使用</th>
<th class="head">使用</th>
<th class="head">备注</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>
(或其他指针类型)</td>
<td><code class="docutils literal notranslate"><span class="pre">%lx</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%p</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">int64_t</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%qd,</span> <span class="pre">%lld</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%&quot;PRId64&quot;</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">uint64_t</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%qu,</span> <span class="pre">%llu,</span> <span class="pre">%llx</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%&quot;PRIu64&quot;,</span> <span class="pre">%&quot;PRIx64&quot;</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">size_t</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%u</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%&quot;PRIuS&quot;,</span> <span class="pre">%&quot;PRIxS&quot;</span></code></td>
<td>C99 规定 <code class="docutils literal notranslate"><span class="pre">%zu</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">ptrdiff_t</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%d</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">%&quot;PRIdS&quot;</span></code></td>
<td>C99 规定 <code class="docutils literal notranslate"><span class="pre">%zd</span></code></td>
</tr>
</tbody>
</table>
<p>注意 <code class="docutils literal notranslate"><span class="pre">PRI*</span></code> 宏会被编译器扩展为独立字符串. 因此如果使用非常量的格式化字符串, 需要将宏的值而不是宏名插入格式中. 使用 <code class="docutils literal notranslate"><span class="pre">PRI*</span></code> 宏同样可以在 <code class="docutils literal notranslate"><span class="pre">%</span></code> 后包含长度指示符. 例如, <code class="docutils literal notranslate"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;PRIuS&quot;\n&quot;,</span> <span class="pre">x)</span></code> 在 32 位 Linux 上将被展开为 <code class="docutils literal notranslate"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30&quot;</span> <span class="pre">&quot;u&quot;</span> <span class="pre">&quot;\n&quot;,</span> <span class="pre">x)</span></code>, 编译器当成 <code class="docutils literal notranslate"><span class="pre">printf(&quot;x</span> <span class="pre">=</span> <span class="pre">%30u\n&quot;,</span> <span class="pre">x)</span></code> 处理 (Yang.Y 注: 这在 MSVC 6.0 上行不通, VC 6 编译器不会自动把引号间隔的多个字符串连接一个长字符串).</p>
</div></blockquote>
</li>
<li><p class="first">记住 <code class="docutils literal notranslate"><span class="pre">sizeof(void</span> <span class="pre">*)</span> <span class="pre">!=</span> <span class="pre">sizeof(int)</span></code>. 如果需要一个指针大小的整数要用 <code class="docutils literal notranslate"><span class="pre">intptr_t</span></code>.</p>
</li>
<li><p class="first">你要非常小心的对待结构体对齐, 尤其是要持久化到磁盘上的结构体 (Yang.Y 注: 持久化 - 将数据按字节流顺序保存在磁盘文件或数据库中). 在 64 位系统中, 任何含有 <code class="docutils literal notranslate"><span class="pre">int64_t</span></code>/<code class="docutils literal notranslate"><span class="pre">uint64_t</span></code> 成员的类/结构体, 缺省都以 8 字节在结尾对齐. 如果 32 位和 64 位代码要共用持久化的结构体, 需要确保两种体系结构下的结构体对齐一致. 大多数编译器都允许调整结构体对齐. gcc 中可使用 <code class="docutils literal notranslate"><span class="pre">__attribute__((packed))</span></code>. MSVC 则提供了 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">pack()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__declspec(align())</span></code> (YuleFox 注, 解决方案的项目属性里也可以直接设置).</p>
</li>
<li><p class="first">创建 64 位常量时使用 LL 或 ULL 作为后缀, 如:</p>
<blockquote>
<div><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int64_t</span> <span class="n">my_value</span> <span class="o">=</span> <span class="mh">0x123456789LL</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">my_mask</span> <span class="o">=</span> <span class="mi">3ULL</span> <span class="o">&lt;&lt;</span> <span class="mi">48</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">如果你确实需要 32 位和 64 位系统具有不同代码, 可以使用 <code class="docutils literal notranslate"><span class="pre">#ifdef</span> <span class="pre">_LP64</span></code> 指令来切分 32/64 位代码. (尽量不要这么做, 如果非用不可, 尽量使修改局部化)</p>
</li>
</ul>
</div>
<div class="section" id="section-13">
<span id="preprocessor-macros"></span><h4>6.16. 预处理宏</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之.</p>
</div>
<p>宏意味着你和编译器看到的代码是不同的. 这可能会导致异常行为, 尤其因为宏具有全局作用域.</p>
<p>值得庆幸的是, C++ 中, 宏不像在 C 中那么必不可少. 以往用宏展开性能关键的代码, 现在可以用内联函数替代. 用宏表示常量可被 <code class="docutils literal notranslate"><span class="pre">const</span></code> 变量代替. 用宏 “缩写” 长变量名可被引用代替. 用宏进行条件编译… 这个, 千万别这么做, 会令测试更加痛苦 (<code class="docutils literal notranslate"><span class="pre">#define</span></code> 防止头文件重包含当然是个特例).</p>
<p>宏可以做一些其他技术无法实现的事情, 在一些代码库 (尤其是底层库中) 可以看到宏的某些特性 (如用 <code class="docutils literal notranslate"><span class="pre">#</span></code> 字符串化, 用 <code class="docutils literal notranslate"><span class="pre">##</span></code> 连接等等). 但在使用前, 仔细考虑一下能不能不使用宏达到同样的目的.</p>
<p>下面给出的用法模式可以避免使用宏带来的问题; 如果你要宏, 尽可能遵守:</p>
<blockquote>
<div><ul class="simple">
<li>不要在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件中定义宏.</li>
<li>在马上要使用时才进行 <code class="docutils literal notranslate"><span class="pre">#define</span></code>, 使用后要立即 <code class="docutils literal notranslate"><span class="pre">#undef</span></code>.</li>
<li>不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称；</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为.</li>
<li>不要用 <code class="docutils literal notranslate"><span class="pre">##</span></code> 处理函数，类和变量的名字。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="nullptr-null">
<h4>6.17. 0, <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 和 <code class="docutils literal notranslate"><span class="pre">NULL</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>整数用 <code class="docutils literal notranslate"><span class="pre">0</span></code>, 实数用 <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, 指针用 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> 或 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 字符 (串) 用 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>.</p>
<p>整数用 <code class="docutils literal notranslate"><span class="pre">0</span></code>, 实数用 <code class="docutils literal notranslate"><span class="pre">0.0</span></code>, 这一点是毫无争议的.</p>
<p>对于指针 (地址值), 到底是用 <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. C++11 项目用 <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>; C++03 项目则用 <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, 毕竟它看起来像指针。实际上，一些 C++ 编译器对 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 的定义比较特殊，可以输出有用的警告，特别是 <code class="docutils literal notranslate"><span class="pre">sizeof(NULL)</span></code> 就和 <code class="docutils literal notranslate"><span class="pre">sizeof(0)</span></code> 不一样。</p>
<p class="last">字符 (串) 用 <code class="docutils literal notranslate"><span class="pre">'\0'</span></code>, 不仅类型正确而且可读性好.</p>
</div>
</div>
<div class="section" id="sizeof">
<h4>6.18. sizeof</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>尽可能用 <code class="docutils literal notranslate"><span class="pre">sizeof(varname)</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">sizeof(type)</span></code>.</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">sizeof(varname)</span></code> 是因为当代码中变量类型改变时会自动更新. 您或许会用 <code class="docutils literal notranslate"><span class="pre">sizeof(type)</span></code> 处理不涉及任何变量的代码，比如处理来自外部或内部的数据格式，这时用变量就不合适了。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Struct</span> <span class="n">data</span><span class="p">;</span>
<span class="n">Struct</span> <span class="n">data</span><span class="p">;</span> <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">data</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Struct</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="last highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">raw_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;compressed record not big enough for count: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">raw_size</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="auto">
<h4>6.19. auto</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 绕过烦琐的类型名，只要可读性好就继续用，别用在局部变量之外的地方。</p>
</div>
<p>定义：</p>
<blockquote>
<div><p>C++11 中，若变量被声明成 <code class="docutils literal notranslate"><span class="pre">auto</span></code>, 那它的类型就会被自动匹配成初始化表达式的类型。您可以用 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 来复制初始化或绑定引用。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">auto</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// 创建一份 v[0] 的拷贝。</span>
<span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// s2 是 v[0] 的一个引用。</span>
</pre></div>
</div>
</div></blockquote>
<p>优点：</p>
<blockquote>
<div><p>C++ 类型名有时又长又臭，特别是涉及模板或命名空间的时候。就像：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">sparse_hash_map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</pre></div>
</div>
<p>返回类型好难读，代码目的也不够一目了然。重构其：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</pre></div>
</div>
<p>好多了。</p>
<p>没有 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 的话，我们不得不在同一个表达式里写同一个类型名两次，无谓的重复，就像：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">diagnostics</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="o">*</span> <span class="n">status</span> <span class="o">=</span> <span class="k">new</span> <span class="n">diagnostics</span><span class="o">::</span><span class="n">ErrorStatus</span><span class="p">(</span><span class="s">&quot;xyz&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>有了 auto, 可以更方便地用中间变量，显式编写它们的类型轻松点。</p>
</div></blockquote>
<p>缺点：</p>
<blockquote>
<div><p>类型够明显时，特别是初始化变量时，代码才会够一目了然。但以下就不一样了：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">Lookup</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</pre></div>
</div>
<p>看不出其类型是啥，x 的类型声明恐怕远在几百行之外了。</p>
<p>程序员必须会区分 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 和 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto&amp;</span></code> 的不同之处，否则会复制错东西。</p>
<p>auto 和 C++11 列表初始化的合体令人摸不着头脑：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="nf">x</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>  <span class="c1">// 圆括号。</span>
<span class="k">auto</span> <span class="n">y</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>  <span class="c1">// 大括号。</span>
</pre></div>
</div>
<p>它们不是同一回事——<code class="docutils literal notranslate"><span class="pre">x</span></code> 是 <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code> 则是 <code class="docutils literal notranslate"><span class="pre">std::initializer_list&lt;int&gt;</span></code>. 其它一般不可见的代理类型（acgtyrant 注：normally-invisible proxy types, 它涉及到 C++ 鲜为人知的坑：<a class="reference external" href="http://stackoverflow.com/a/17794965/1546088">Why is vector&lt;bool&gt; not a STL container?</a>）也有大同小异的陷阱。</p>
<p>如果在接口里用 <code class="docutils literal notranslate"><span class="pre">auto</span></code>, 比如声明头文件里的一个常量，那么只要仅仅因为程序员一时修改其值而导致类型变化的话——API 要翻天覆地了。</p>
</div></blockquote>
<p>结论：</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">auto</span></code> 只能用在局部变量里用。别用在文件作用域变量，命名空间作用域变量和类数据成员里。永远别列表初始化 <code class="docutils literal notranslate"><span class="pre">auto</span></code> 变量。</p>
<p><code class="docutils literal notranslate"><span class="pre">auto</span></code> 还可以和 C++11 特性「尾置返回类型（trailing return type）」一起用，不过后者只能用在 lambda 表达式里。</p>
</div></blockquote>
</div>
<div class="section" id="section-14">
<span id="braced-initializer-list"></span><h4>6.20. 列表初始化</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>你可以用列表初始化。</p>
<p>早在 C++03 里，聚合类型（aggregate types）就已经可以被列表初始化了，比如数组和不自带构造函数的结构体：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
<span class="n">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
</pre></div>
</div>
<p>C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Vector 接收了一个初始化列表。</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">};</span>

<span class="c1">// 不考虑细节上的微妙差别，大致上相同。</span>
<span class="c1">// 您可以任选其一。</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">};</span>

<span class="c1">// 可以配合 new 一起用。</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">};</span>

<span class="c1">// map 接收了一些 pair, 列表初始化大显神威。</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;one&quot;</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;2&quot;</span><span class="p">}};</span>

<span class="c1">// 初始化列表也可以用在返回类型上的隐式转换。</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test_function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span> <span class="p">}</span>

<span class="c1">// 初始化列表可迭代。</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">})</span> <span class="p">{}</span>

<span class="c1">// 在函数调用里用列表初始化。</span>
<span class="kt">void</span> <span class="n">TestFunction2</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">TestFunction2</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>
</pre></div>
</div>
<p>用户自定义类型也可以定义接收 <code class="docutils literal notranslate"><span class="pre">std::initializer_list&lt;T&gt;</span></code> 的构造函数和赋值运算符，以自动列表初始化：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyType</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// std::initializer_list 专门接收 init 列表。</span>
  <span class="c1">// 得以值传递。</span>
  <span class="n">MyType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">init_list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">init_list</span><span class="p">)</span> <span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">MyType</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">init_list</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">init_list</span><span class="p">)</span> <span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="n">MyType</span> <span class="n">m</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
</pre></div>
</div>
<p>最后，列表初始化也适用于常规数据类型的构造，哪怕没有接收 <code class="docutils literal notranslate"><span class="pre">std::initializer_list&lt;T&gt;</span></code> 的构造函数。</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">d</span><span class="p">{</span><span class="mf">1.23</span><span class="p">};</span>
<span class="c1">// MyOtherType 没有 std::initializer_list 构造函数，</span>
 <span class="c1">// 直接上接收常规类型的构造函数。</span>
<span class="k">class</span> <span class="nc">MyOtherType</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">MyOtherType</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
  <span class="n">MyOtherType</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">string</span><span class="p">);</span>
<span class="p">};</span>
<span class="n">MyOtherType</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">};</span>
<span class="c1">// 不过如果构造函数是显式的（explict），您就不能用 `= {}` 了。</span>
<span class="n">MyOtherType</span> <span class="n">m</span><span class="p">{</span><span class="s">&quot;b&quot;</span><span class="p">};</span>
</pre></div>
</div>
<p>千万别直接列表初始化 auto 变量，看下一句，估计没人看得懂：</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<div class="last highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.23</span><span class="p">};</span>        <span class="c1">// d 即是 std::initializer_list&lt;double&gt;</span>
</pre></div>
</div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="kt">double</span><span class="p">{</span><span class="mf">1.23</span><span class="p">};</span>  <span class="c1">// 善哉 -- d 即为 double, 并非 std::initializer_list.</span>
</pre></div>
</div>
<p class="last">至于格式化，参见 <a class="reference internal" href="contents.html#braced-initializer-list-format"><span class="std std-ref">9.7. 列表初始化格式</span></a>.</p>
</div>
</div>
<div class="section" id="lambda">
<span id="lambda-expressions"></span><h4>6.21. Lambda 表达式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适当使用 lambda 表达式。别用默认 lambda 捕获，所有捕获都要显式写出来。</p>
</div>
<p>定义：</p>
<blockquote>
<div><p>Lambda 表达式是创建匿名函数对象的一种简易途径，常用于把函数当参数传，例如：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Weight</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Weight</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>C++11 首次提出 Lambdas, 还提供了一系列处理函数对象的工具，比如多态包装器（polymorphic wrapper） <code class="docutils literal notranslate"><span class="pre">std::function</span></code>.</p>
</div></blockquote>
<p>优点：</p>
<blockquote>
<div><ul class="simple">
<li>传函数对象给 STL 算法，Lambdas 最简易，可读性也好。</li>
<li>Lambdas, <code class="docutils literal notranslate"><span class="pre">std::functions</span></code> 和 <code class="docutils literal notranslate"><span class="pre">std::bind</span></code> 可以搭配成通用回调机制（general purpose callback mechanism）；写接收有界函数为参数的函数也很容易了。</li>
</ul>
</div></blockquote>
<p>缺点：</p>
<blockquote>
<div><ul class="simple">
<li>Lambdas 的变量捕获略旁门左道，可能会造成悬空指针。</li>
<li>Lambdas 可能会失控；层层嵌套的匿名函数难以阅读。</li>
</ul>
</div></blockquote>
<p>结论：</p>
<blockquote>
<div><ul class="simple">
<li>按 format 小用 lambda 表达式怡情。</li>
<li>禁用默认捕获，捕获都要显式写出来。打比方，比起 <code class="docutils literal notranslate"><span class="pre">[=](int</span> <span class="pre">x)</span> <span class="pre">{return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">n;}</span></code>, 您该写成 <code class="docutils literal notranslate"><span class="pre">[n](int</span> <span class="pre">x)</span> <span class="pre">{return</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">n;}</span></code> 才对，这样读者也好一眼看出 <code class="docutils literal notranslate"><span class="pre">n</span></code> 是被捕获的值。</li>
<li>匿名函数始终要简短，如果函数体超过了五行，那么还不如起名（acgtyrant 注：即把 lambda 表达式赋值给对象），或改用函数。</li>
<li>如果可读性更好，就显式写出 lambd 的尾置返回类型，就像auto.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-15">
<span id="template-metaprogramming"></span><h4>6.22. 模板编程</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要使用复杂的模板编程</p>
</div>
<p>定义:</p>
<blockquote>
<div>模板编程指的是利用c++ 模板实例化机制是图灵完备性, 可以被用来实现编译时刻的类型判断的一系列编程技巧</div></blockquote>
<p>优点:</p>
<blockquote>
<div>模板编程能够实现非常灵活的类型安全的接口和极好的性能, 一些常见的工具比如Google Test, std::tuple, std::function 和 Boost.Spirit. 这些工具如果没有模板是实现不了的</div></blockquote>
<p>缺点:</p>
<blockquote>
<div><ul class="simple">
<li>模板编程所使用的技巧对于使用c++不是很熟练的人是比较晦涩, 难懂的. 在复杂的地方使用模板的代码让人更不容易读懂, 并且debug 和 维护起来都很麻烦</li>
<li>模板编程经常会导致编译出错的信息非常不友好: 在代码出错的时候, 即使这个接口非常的简单, 模板内部复杂的实现细节也会在出错信息显示. 导致这个编译出错信息看起来非常难以理解.</li>
<li>大量的使用模板编程接口会让重构工具(Visual Assist X, Refactor for C++等等)更难发挥用途. 首先模板的代码会在很多上下文里面扩展开来, 所以很难确认重构对所有的这些展开的代码有用, 其次有些重构工具只对已经做过模板类型替换的代码的AST 有用. 因此重构工具对这些模板实现的原始代码并不有效, 很难找出哪些需要重构.</li>
</ul>
</div></blockquote>
<p>结论:</p>
<blockquote>
<div><ul class="simple">
<li>模板编程有时候能够实现更简洁更易用的接口, 但是更多的时候却适得其反. 因此模板编程最好只用在少量的基础组件, 基础数据结构上, 因为模板带来的额外的维护成本会被大量的使用给分担掉</li>
<li>在使用模板编程或者其他复杂的模板技巧的时候, 你一定要再三考虑一下. 考虑一下你们团队成员的平均水平是否能够读懂并且能够维护你写的模板代码.或者一个非c++ 程序员和一些只是在出错的时候偶尔看一下代码的人能够读懂这些错误信息或者能够跟踪函数的调用流程. 如果你使用递归的模板实例化, 或者类型列表, 或者元函数, 又或者表达式模板, 或者依赖SFINAE, 或者sizeof 的trick 手段来检查函数是否重载, 那么这说明你模板用的太多了, 这些模板太复杂了, 我们不推荐使用</li>
<li>如果你使用模板编程, 你必须考虑尽可能的把复杂度最小化, 并且尽量不要让模板对外暴露. 你最好只在实现里面使用模板, 然后给用户暴露的接口里面并不使用模板, 这样能提高你的接口的可读性. 并且你应该在这些使用模板的代码上写尽可能详细的注释. 你的注释里面应该详细的包含这些代码是怎么用的, 这些模板生成出来的代码大概是什么样子的. 还需要额外注意在用户错误使用你的模板代码的时候需要输出更人性化的出错信息. 因为这些出错信息也是你的接口的一部分, 所以你的代码必须调整到这些错误信息在用户看起来应该是非常容易理解, 并且用户很容易知道如何修改这些错误</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="boost-1">
<span id="boost"></span><h4>6.23. Boost 库</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用 Boost 中被认可的库.</p>
</div>
<p>定义:</p>
<blockquote>
<div><a class="reference external" href="http://www.boost.org/">Boost 库集</a> 是一个广受欢迎, 经过同行鉴定, 免费开源的 C++ 库集.</div></blockquote>
<p>优点:</p>
<blockquote>
<div>Boost代码质量普遍较高, 可移植性好, 填补了 C++ 标准库很多空白, 如型别的特性, 更完善的绑定器, 更好的智能指针。</div></blockquote>
<p>缺点:</p>
<blockquote>
<div>某些 Boost 库提倡的编程实践可读性差, 比如元编程和其他高级模板技术, 以及过度 “函数化” 的编程风格.</div></blockquote>
<p>结论:</p>
<blockquote>
<div><p>为了向阅读和维护代码的人员提供更好的可读性, 我们只允许使用 Boost 一部分经认可的特性子集. 目前允许使用以下库:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://www.boost.org/doc/libs/1_58_0/libs/utility/call_traits.htm">Call Traits</a> : <code class="docutils literal notranslate"><span class="pre">boost/call_traits.hpp</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/utility/compressed_pair.htm">Compressed Pair</a> : <code class="docutils literal notranslate"><span class="pre">boost/compressed_pair.hpp</span></code></li>
<li><a class="reference external" href="http://www.boost.org/doc/libs/1_58_0/libs/graph/doc/index.html">&lt;The Boost Graph Library (BGL)</a> : <code class="docutils literal notranslate"><span class="pre">boost/graph</span></code>, except serialization (<code class="docutils literal notranslate"><span class="pre">adj_list_serialize.hpp</span></code>) and parallel/distributed algorithms and data structures(<code class="docutils literal notranslate"><span class="pre">boost/graph/parallel/*</span></code> and <code class="docutils literal notranslate"><span class="pre">boost/graph/distributed/*</span></code>)</li>
<li><a class="reference external" href="http://www.boost.org/libs/property_map/">Property Map</a> : <code class="docutils literal notranslate"><span class="pre">boost/property_map.hpp</span></code></li>
<li>The part of <a class="reference external" href="http://www.boost.org/libs/iterator/">Iterator</a> that deals with defining iterators: <code class="docutils literal notranslate"><span class="pre">boost/iterator/iterator_adaptor.hpp</span></code>, <code class="docutils literal notranslate"><span class="pre">boost/iterator/iterator_facade.hpp</span></code>, and <code class="docutils literal notranslate"><span class="pre">boost/function_output_iterator.hpp</span></code></li>
<li>The part of <a class="reference external" href="http://www.boost.org/libs/polygon/">Polygon</a> that deals with Voronoi diagram construction and doesn’t depend on the rest of Polygon: <code class="docutils literal notranslate"><span class="pre">boost/polygon/voronoi_builder.hpp</span></code>, <code class="docutils literal notranslate"><span class="pre">boost/polygon/voronoi_diagram.hpp</span></code>, and <code class="docutils literal notranslate"><span class="pre">boost/polygon/voronoi_geometry_type.hpp</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/bimap/">Bimap</a> : <code class="docutils literal notranslate"><span class="pre">boost/bimap</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/math/doc/html/dist.html">Statistical Distributions and Functions</a> : <code class="docutils literal notranslate"><span class="pre">boost/math/distributions</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/multi_index/">Multi-index</a> : <code class="docutils literal notranslate"><span class="pre">boost/multi_index</span></code></li>
<li><a class="reference external" href="http://www.boost.org/libs/heap/">Heap</a> : <code class="docutils literal notranslate"><span class="pre">boost/heap</span></code></li>
<li>The flat containers from <a class="reference external" href="http://www.boost.org/libs/container/">Container</a>: <code class="docutils literal notranslate"><span class="pre">boost/container/flat_map</span></code>, and <code class="docutils literal notranslate"><span class="pre">boost/container/flat_set</span></code></li>
</ul>
</div></blockquote>
<p>我们正在积极考虑增加其它 Boost 特性, 所以列表中的规则将不断变化.</p>
<p>以下库可以用，但由于如今已经被 C++ 11 标准库取代，不再鼓励：</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://www.boost.org/libs/ptr_container/">Pointer Container</a> : <code class="docutils literal notranslate"><span class="pre">boost/ptr_container</span></code>, 改用 <a class="reference external" href="http://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a></li>
<li><a class="reference external" href="http://www.boost.org/libs/array/">Array</a> : <code class="docutils literal notranslate"><span class="pre">boost/array.hpp</span></code>, 改用 <a class="reference external" href="http://en.cppreference.com/w/cpp/container/array">std::array</a></li>
</ul>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="c-11">
<h4>6.24. C++11</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适当用 C++11（前身是 C++0x）的库和语言扩展，在贵项目用 C++11 特性前三思可移植性。</p>
</div>
<p>定义：</p>
<blockquote>
<div>C++11 有众多语言和库上的`变革 &lt;<a class="reference external" href="https://en.wikipedia.org/wiki/C%2B%2B11">https://en.wikipedia.org/wiki/C%2B%2B11</a>&gt;`_ 。</div></blockquote>
<p>优点：</p>
<blockquote>
<div>在二〇一四年八月之前，C++11 一度是官方标准，被大多 C++ 编译器支持。它标准化很多我们早先就在用的 C++ 扩展，简化了不少操作，大大改善了性能和安全。</div></blockquote>
<p>缺点：</p>
<blockquote>
<div><p>C++11 相对于前身，复杂极了：1300 页 vs 800 页！很多开发者也不怎么熟悉它。于是从长远来看，前者特性对代码可读性以及维护代价难以预估。我们说不准什么时候采纳其特性，特别是在被迫依赖老实工具的项目上。</p>
<p>和 <a class="reference internal" href="#boost"><span class="std std-ref">6.23. Boost 库</span></a> 一样，有些 C++11 扩展提倡实则对可读性有害的编程实践——就像去除冗余检查（比如类型名）以帮助读者，或是鼓励模板元编程等等。有些扩展在功能上与原有机制冲突，容易招致困惑以及迁移代价。</p>
</div></blockquote>
<p>结论：</p>
<blockquote>
<div><p>C++11 特性除了个别情况下，可以用一用。除了本指南会有不少章节会加以讨若干 C++11 特性之外，以下特性最好不要用：</p>
<ul class="simple">
<li>尾置返回类型，比如用 <code class="docutils literal notranslate"><span class="pre">auto</span> <span class="pre">foo()</span> <span class="pre">-&gt;</span> <span class="pre">int</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">foo()</span></code>. 为了兼容于现有代码的声明风格。</li>
<li>编译时合数 <code class="docutils literal notranslate"><span class="pre">&lt;ratio&gt;</span></code>, 因为它涉及一个重模板的接口风格。</li>
<li><code class="docutils literal notranslate"><span class="pre">&lt;cfenv&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&lt;fenv.h&gt;</span></code> 头文件，因为编译器尚不支持。</li>
<li>默认 lambda 捕获。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>实际上，<a class="reference external" href="http://www.zhihu.com/question/24439516/answer/27858964">缺省参数会改变函数签名的前提是改变了它接收的参数数量</a>，比如把 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">a()</span></code> 改成 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">a(int</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">0)</span></code>, 开发者改变其代码的初衷也许是，在不改变「代码兼容性」的同时，又提供了可选 int 参数的余地，然而这终究会破坏函数指针上的兼容性，毕竟函数签名确实变了。</li>
<li>此外把自带缺省参数的函数地址赋值给指针时，会丢失缺省参数信息。</li>
<li>我还发现 <a class="reference external" href="http://www.zhihu.com/question/24439516/answer/27896004">滥用缺省参数会害得读者光只看调用代码的话，会误以为其函数接受的参数数量比实际上还要少。</a></li>
<li><code class="docutils literal notranslate"><span class="pre">friend</span></code> 实际上只对函数／类赋予了对其所在类的访问权限，并不是有效的声明语句。所以除了在头文件类内部写 friend 函数／类，还要在类作用域之外正式地声明一遍，最后在对应的 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件加以定义。</li>
<li>本风格指南都强调了「友元应该定义在同一文件内，避免代码读者跑到其它文件查找使用该私有成员的类」。那么可以把其声明放在类声明所在的头文件，定义也放在类定义所在的文件。</li>
<li>由于友元函数／类并不是类的一部分，自然也不会是类可调用的公有接口，于是我主张全集中放在类的尾部，即的数据成员之后，参考 <a class="reference internal" href="contents.html#declaration-order"><span class="std std-ref">声明顺序</span></a> 。</li>
<li><a class="reference external" href="http://www.zhihu.com/question/22889420">对使用 C++ 异常处理应具有怎样的态度？</a> 非常值得一读。</li>
<li>注意初始化 const 对象时，必须在初始化的同时值初始化。</li>
<li>用断言代替无符号整型类型，深有启发。</li>
<li>auto 在涉及迭代器的循环语句里挺常用。</li>
<li><a class="reference external" href="http://stackoverflow.com/questions/11215227/should-the-trailing-return-type-syntax-style-become-the-default-for-new-c11-pr">Should the trailing return type syntax style become the default for new C++11 programs?</a> 讨论了 auto 与尾置返回类型一起用的全新编码风格，值得一看。</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/naming"></span><div class="section" id="section-1">
<h3>7. 命名约定</h3>
<p>最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至. 我们大脑中的模式匹配引擎非常依赖这些命名规则.</p>
<p>命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则.</p>
<div class="section" id="section-2">
<span id="general-naming-rules"></span><h4>7.1. 通用命名规则</h4>
<p><strong>总述</strong></p>
<p>函数命名, 变量命名, 文件命名要有描述性; 少用缩写.</p>
<p><strong>说明</strong></p>
<p>尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">price_count_reader</span><span class="p">;</span>    <span class="c1">// 无缩写</span>
<span class="kt">int</span> <span class="n">num_errors</span><span class="p">;</span>            <span class="c1">// &quot;num&quot; 是一个常见的写法</span>
<span class="kt">int</span> <span class="n">num_dns_connections</span><span class="p">;</span>   <span class="c1">// 人人都知道 &quot;DNS&quot; 是什么</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                     <span class="c1">// 毫无意义.</span>
<span class="kt">int</span> <span class="n">nerr</span><span class="p">;</span>                  <span class="c1">// 含糊不清的缩写.</span>
<span class="kt">int</span> <span class="n">n_comp_conns</span><span class="p">;</span>          <span class="c1">// 含糊不清的缩写.</span>
<span class="kt">int</span> <span class="n">wgc_connections</span><span class="p">;</span>       <span class="c1">// 只有贵团队知道是什么意思.</span>
<span class="kt">int</span> <span class="n">pc_reader</span><span class="p">;</span>             <span class="c1">// &quot;pc&quot; 有太多可能的解释了.</span>
<span class="kt">int</span> <span class="n">cstmr_id</span><span class="p">;</span>              <span class="c1">// 删减了若干字母.</span>
</pre></div>
</div>
<p>注意, 一些特定的广为人知的缩写是允许的, 例如用 <code class="docutils literal notranslate"><span class="pre">i</span></code> 表示迭代变量和用 <code class="docutils literal notranslate"><span class="pre">T</span></code> 表示模板参数.</p>
<p>模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循 <a class="reference internal" href="#type-names"><span class="std std-ref">类型命名</span></a> 的规则, 而非类型模板应当遵循 <a class="reference internal" href="#variable-names"><span class="std std-ref">变量命名</span></a> 的规则.</p>
</div>
<div class="section" id="section-3">
<h4>7.2. 文件命名</h4>
<p><strong>总述</strong></p>
<p>文件名要全部小写, 可以包含下划线 (<code class="docutils literal notranslate"><span class="pre">_</span></code>) 或连字符 (<code class="docutils literal notranslate"><span class="pre">-</span></code>), 依照项目的约定. 如果没有约定, 那么 “<code class="docutils literal notranslate"><span class="pre">_</span></code>” 更好.</p>
<p><strong>说明</strong></p>
<p>可接受的文件命名示例:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">my_useful_class.cc</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">my-useful-class.cc</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">myusefulclass.cc</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">myusefulclass_test.cc</span></code> // <code class="docutils literal notranslate"><span class="pre">_unittest</span></code> 和 <code class="docutils literal notranslate"><span class="pre">_regtest</span></code> 已弃用.</li>
</ul>
<p>C++ 文件要以 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 结尾, 头文件以 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 结尾. 专门插入文本的文件则以 <code class="docutils literal notranslate"><span class="pre">.inc</span></code> 结尾, 参见 <a class="reference internal" href="contents.html#self-contained-headers"><span class="std std-ref">头文件自足</span></a>.</p>
<p>不要使用已经存在于 <code class="docutils literal notranslate"><span class="pre">/usr/include</span></code> 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 <code class="docutils literal notranslate"><span class="pre">db.h</span></code>.</p>
<p>通常应尽量让文件名更加明确. <code class="docutils literal notranslate"><span class="pre">http_server_logs.h</span></code> 就比 <code class="docutils literal notranslate"><span class="pre">logs.h</span></code> 要好. 定义类时文件名一般成对出现, 如 <code class="docutils literal notranslate"><span class="pre">foo_bar.h</span></code> 和 <code class="docutils literal notranslate"><span class="pre">foo_bar.cc</span></code>, 对应于类 <code class="docutils literal notranslate"><span class="pre">FooBar</span></code>.</p>
<p>内联函数定义必须放在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件中. 如果内联函数比较短, 就直接将实现也放在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 中.</p>
</div>
<div class="section" id="section-4">
<span id="type-names"></span><h4>7.3. 类型命名</h4>
<p><strong>总述</strong></p>
<p>类型名称的每个单词首字母均大写, 不包含下划线: <code class="docutils literal notranslate"><span class="pre">MyExcitingClass</span></code>, <code class="docutils literal notranslate"><span class="pre">MyExcitingEnum</span></code>.</p>
<p><strong>说明</strong></p>
<p>所有类型命名 —— 类, 结构体, 类型定义 (<code class="docutils literal notranslate"><span class="pre">typedef</span></code>), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 类和结构体</span>
<span class="k">class</span> <span class="nc">UrlTable</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">class</span> <span class="nc">UrlTableTester</span> <span class="p">{</span> <span class="p">...</span>
<span class="k">struct</span> <span class="n">UrlTableProperties</span> <span class="p">{</span> <span class="p">...</span>

<span class="c1">// 类型定义</span>
<span class="k">typedef</span> <span class="n">hash_map</span><span class="o">&lt;</span><span class="n">UrlTableProperties</span> <span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">PropertiesMap</span><span class="p">;</span>

<span class="c1">// using 别名</span>
<span class="k">using</span> <span class="n">PropertiesMap</span> <span class="o">=</span> <span class="n">hash_map</span><span class="o">&lt;</span><span class="n">UrlTableProperties</span> <span class="o">*</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// 枚举</span>
<span class="k">enum</span> <span class="n">UrlTableErrors</span> <span class="p">{</span> <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<span id="variable-names"></span><h4>7.4. 变量命名</h4>
<p><strong>总述</strong></p>
<p>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: <code class="docutils literal notranslate"><span class="pre">a_local_variable</span></code>, <code class="docutils literal notranslate"><span class="pre">a_struct_data_member</span></code>, <code class="docutils literal notranslate"><span class="pre">a_class_data_member_</span></code>.</p>
<p><strong>说明</strong></p>
<div class="section" id="section-6">
<h5>普通变量命名</h5>
<p>举例:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">string</span> <span class="n">table_name</span><span class="p">;</span>  <span class="c1">// 好 - 用下划线.</span>
<span class="n">string</span> <span class="n">tablename</span><span class="p">;</span>   <span class="c1">// 好 - 全小写.</span>

<span class="n">string</span> <span class="n">tableName</span><span class="p">;</span>  <span class="c1">// 差 - 混合大小写</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<h5>类数据成员</h5>
<p>不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TableInfo</span> <span class="p">{</span>
  <span class="p">...</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="n">table_name_</span><span class="p">;</span>  <span class="c1">// 好 - 后加下划线.</span>
  <span class="n">string</span> <span class="n">tablename_</span><span class="p">;</span>   <span class="c1">// 好.</span>
  <span class="k">static</span> <span class="n">Pool</span><span class="o">&lt;</span><span class="n">TableInfo</span><span class="o">&gt;*</span> <span class="n">pool_</span><span class="p">;</span>  <span class="c1">// 好.</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-8">
<h5>结构体变量</h5>
<p>不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">UrlTableProperties</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>
  <span class="k">static</span> <span class="n">Pool</span><span class="o">&lt;</span><span class="n">UrlTableProperties</span><span class="o">&gt;*</span> <span class="n">pool</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>结构体与类的使用讨论, 参考 <a class="reference internal" href="contents.html#structs-vs-classes"><span class="std std-ref">结构体 vs. 类</span></a>.</p>
</div>
</div>
<div class="section" id="section-9">
<span id="constant-names"></span><h4>7.5. 常量命名</h4>
<p><strong>总述</strong></p>
<p>声明为 <code class="docutils literal notranslate"><span class="pre">constexpr</span></code> 或 <code class="docutils literal notranslate"><span class="pre">const</span></code> 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">kDaysInAWeek</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</pre></div>
</div>
<p><strong>说明</strong></p>
<p>所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">存储类型</a>) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则.</p>
</div>
<div class="section" id="section-10">
<span id="function-names"></span><h4>7.6. 函数命名</h4>
<p><strong>总述</strong></p>
<p>常规函数使用大小写混合, 取值和设值函数则要求与变量名匹配: <code class="docutils literal notranslate"><span class="pre">MyExcitingFunction()</span></code>, <code class="docutils literal notranslate"><span class="pre">MyExcitingMethod()</span></code>, <code class="docutils literal notranslate"><span class="pre">my_exciting_member_variable()</span></code>, <code class="docutils literal notranslate"><span class="pre">set_my_exciting_member_variable()</span></code>.</p>
<p><strong>说明</strong></p>
<p>一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 <code class="docutils literal notranslate"><span class="pre">StartRpc()</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">StartRPC()</span></code>).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">AddTableEntry</span><span class="p">()</span>
<span class="n">DeleteUrl</span><span class="p">()</span>
<span class="n">OpenFileOrDie</span><span class="p">()</span>
</pre></div>
</div>
<p>(同样的命名规则同时适用于类作用域与命名空间作用域的常量, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.)</p>
<p>取值和设值函数的命名与变量一致. 一般来说它们的名称与实际的成员变量对应, 但并不强制要求. 例如 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">count()</span></code> 与 <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">set_count(int</span> <span class="pre">count)</span></code>.</p>
</div>
<div class="section" id="section-11">
<h4>7.7. 命名空间命名</h4>
<p><strong>总述</strong></p>
<p>命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突.</p>
<p>顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中.</p>
<p>注意 <a class="reference internal" href="#general-naming-rules"><span class="std std-ref">不使用缩写作为名称</span></a> 的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写.</p>
<p>要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 <code class="docutils literal notranslate"><span class="pre">std</span></code> 命名空间. 建议使用更独特的项目标识符 (<code class="docutils literal notranslate"><span class="pre">websearch::index</span></code>, <code class="docutils literal notranslate"><span class="pre">websearch::index_util</span></code>) 而非常见的极易发生冲突的名称 (比如 <code class="docutils literal notranslate"><span class="pre">websearch::util</span></code>).</p>
<p>对于 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 命名空间, 要当心加入到同一 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 <code class="docutils literal notranslate"><span class="pre">frobber.h</span></code>, 使用 <code class="docutils literal notranslate"><span class="pre">websearch::index::frobber_internal</span></code>).</p>
</div>
<div class="section" id="section-12">
<h4>7.8. 枚举命名</h4>
<p><strong>总述</strong></p>
<p>枚举的命名应当和 <a class="reference internal" href="#constant-names"><span class="std std-ref">常量</span></a> 或 <a class="reference internal" href="#macro-names"><span class="std std-ref">宏</span></a> 一致: <code class="docutils literal notranslate"><span class="pre">kEnumName</span></code> 或是 <code class="docutils literal notranslate"><span class="pre">ENUM_NAME</span></code>.</p>
<p><strong>说明</strong></p>
<p>单独的枚举值应该优先采用 <a class="reference internal" href="#constant-names"><span class="std std-ref">常量</span></a> 的命名方式. 但 <a class="reference internal" href="#macro-names"><span class="std std-ref">宏</span></a> 方式的命名也可以接受. 枚举名 <code class="docutils literal notranslate"><span class="pre">UrlTableErrors</span></code> (以及 <code class="docutils literal notranslate"><span class="pre">AlternateUrlTableErrors</span></code>) 是类型, 所以要用大小写混合的方式.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">UrlTableErrors</span> <span class="p">{</span>
    <span class="n">kOK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">kErrorOutOfMemory</span><span class="p">,</span>
    <span class="n">kErrorMalformedInput</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">enum</span> <span class="n">AlternateUrlTableErrors</span> <span class="p">{</span>
    <span class="n">OK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">OUT_OF_MEMORY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">MALFORMED_INPUT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>2009 年 1 月之前, 我们一直建议采用 <a class="reference internal" href="#macro-names"><span class="std std-ref">宏</span></a> 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题.</p>
</div>
<div class="section" id="section-13">
<span id="macro-names"></span><h4>7.9. 宏命名</h4>
<p><strong>总述</strong></p>
<p>你并不打算 <a class="reference internal" href="contents.html#preprocessor-macros"><span class="std std-ref">使用宏</span></a>, 对吧? 如果你一定要用, 像这样命名: <code class="docutils literal notranslate"><span class="pre">MY_MACRO_THAT_SCARES_SMALL_CHILDREN</span></code>.</p>
<p><strong>说明</strong></p>
<p>参考 <a class="reference internal" href="contents.html#preprocessor-macros"><span class="std std-ref">预处理宏</span></a>; 通常 <em>不应该</em> 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define ROUND(x) ...</span>
<span class="cp">#define PI_ROUNDED 3.0</span>
</pre></div>
</div>
</div>
<div class="section" id="section-14">
<h4>7.10. 命名规则的特例</h4>
<p><strong>总述</strong></p>
<p>如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略.</p>
<p><code class="docutils literal notranslate"><span class="pre">bigopen()</span></code>: 函数名, 参照 <code class="docutils literal notranslate"><span class="pre">open()</span></code> 的形式</p>
<p><code class="docutils literal notranslate"><span class="pre">uint</span></code>: <code class="docutils literal notranslate"><span class="pre">typedef</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">bigpos</span></code>: <code class="docutils literal notranslate"><span class="pre">struct</span></code> 或 <code class="docutils literal notranslate"><span class="pre">class</span></code>, 参照 <code class="docutils literal notranslate"><span class="pre">pos</span></code> 的形式</p>
<p><code class="docutils literal notranslate"><span class="pre">sparse_hash_map</span></code>: STL 型实体; 参照 STL 命名约定</p>
<p><code class="docutils literal notranslate"><span class="pre">LONGLONG_MAX</span></code>: 常量, 如同 <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code></p>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>感觉 Google 的命名约定很高明, 比如写了简单的类 QueryResult, 接着又可以直接定义一个变量 query_result, 区分度很好; 再次, 类内变量以下划线结尾, 那么就可以直接传入同名的形参, 比如 <code class="docutils literal notranslate"><span class="pre">TextQuery::TextQuery(std::string</span> <span class="pre">word)</span> <span class="pre">:</span> <span class="pre">word_(word)</span> <span class="pre">{}</span></code> , 其中 <code class="docutils literal notranslate"><span class="pre">word_</span></code> 自然是类内私有成员.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/comments"></span><div class="section" id="section-1">
<h3>8. 注释</h3>
<p>注释虽然写起来很痛苦, 但对保证代码可读性至关重要. 下面的规则描述了如何注释以及在哪儿注释. 当然也要记住: 注释固然很重要, 但最好的代码应当本身就是文档. 有意义的类型名和变量名, 要远胜过要用注释解释的含糊不清的名字.</p>
<p>你写的注释是给代码读者看的, 也就是下一个需要理解你的代码的人. 所以慷慨些吧, 下一个读者可能就是你!</p>
<div class="section" id="section-2">
<h4>8.1. 注释风格</h4>
<p><strong>总述</strong></p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">//</span></code> 或 <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code>, 统一就好.</p>
<p><strong>说明</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">//</span></code> 或 <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">*/</span></code> 都可以; 但 <code class="docutils literal notranslate"><span class="pre">//</span></code> <em>更</em> 常用. 要在如何注释及注释风格上确保统一.</p>
</div>
<div class="section" id="section-3">
<h4>8.2. 文件注释</h4>
<p><strong>总述</strong></p>
<p>在每一个文件开头加入版权公告.</p>
<p>文件注释描述了该文件的内容. 如果一个文件只声明, 或实现, 或测试了一个对象, 并且这个对象已经在它的声明处进行了详细的注释, 那么就没必要再加上文件注释. 除此之外的其他文件都需要文件注释.</p>
<p><strong>说明</strong></p>
<div class="section" id="section-4">
<h5>法律公告和作者信息</h5>
<p>每个文件都应该包含许可证引用. 为项目选择合适的许可证版本.(比如, Apache 2.0, BSD, LGPL, GPL)</p>
<p>如果你对原始作者的文件做了重大修改, 请考虑删除原作者信息.</p>
</div>
<div class="section" id="section-5">
<h5>文件内容</h5>
<p>如果一个 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件声明了多个概念, 则文件注释应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系. 一个一到两行的文件注释就足够了, 对于每个概念的详细文档应当放在各个概念中, 而不是文件注释中.</p>
<p>不要在 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 之间复制注释, 这样的注释偏离了注释的实际意义.</p>
</div>
</div>
<div class="section" id="section-6">
<span id="class-comments"></span><h4>8.3. 类注释</h4>
<p><strong>总述</strong></p>
<p>每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Iterates over the contents of a GargantuanTable.</span>
<span class="c1">// Example:</span>
<span class="c1">//    GargantuanTableIterator* iter = table-&gt;NewIterator();</span>
<span class="c1">//    for (iter-&gt;Seek(&quot;foo&quot;); !iter-&gt;done(); iter-&gt;Next()) {</span>
<span class="c1">//      process(iter-&gt;key(), iter-&gt;value());</span>
<span class="c1">//    }</span>
<span class="c1">//    delete iter;</span>
<span class="k">class</span> <span class="nc">GargantuanTableIterator</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><strong>说明</strong></p>
<p>类注释应当为读者理解如何使用与何时使用类提供足够的信息, 同时应当提醒读者在正确使用此类时应当考虑的因素. 如果类有任何同步前提, 请用文档说明. 如果该类的实例可被多线程访问, 要特别注意文档说明多线程环境下相关的规则和常量使用.</p>
<p>如果你想用一小段代码演示这个类的基本用法或通常用法, 放在类注释里也非常合适.</p>
<p>如果类的声明和定义分开了(例如分别放在了 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 和 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件中), 此时, 描述类用法的注释应当和接口定义放在一起, 描述类的操作和实现的注释应当和实现放在一起.</p>
</div>
<div class="section" id="section-7">
<h4>8.4. 函数注释</h4>
<p><strong>总述</strong></p>
<p>函数声明处的注释描述函数功能; 定义处的注释描述函数实现.</p>
<p><strong>说明</strong></p>
<div class="section" id="section-8">
<h5>函数声明</h5>
<p>基本上每个函数声明处前都应当加上注释, 描述函数的功能和用途. 只有在函数的功能简单而明显时才能省略这些注释(例如, 简单的取值和设值函数). 注释使用叙述式 (“Opens the file”) 而非指令式 (“Open the file”); 注释只是为了描述函数, 而不是命令函数做什么. 通常, 注释不会描述函数如何工作. 那是函数定义部分的事情.</p>
<p>函数声明处注释的内容:</p>
<ul class="simple">
<li>函数的输入输出.</li>
<li>对类成员函数而言: 函数调用期间对象是否需要保持引用参数, 是否会释放这些参数.</li>
<li>函数是否分配了必须由调用者释放的空间.</li>
<li>参数是否可以为空指针.</li>
<li>是否存在函数使用上的性能隐患.</li>
<li>如果函数是可重入的, 其同步前提是什么?</li>
</ul>
<p>举例如下:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns an iterator for this table.  It is the client&#39;s</span>
<span class="c1">// responsibility to delete the iterator when it is done with it,</span>
<span class="c1">// and it must not use the iterator once the GargantuanTable object</span>
<span class="c1">// on which the iterator was created has been deleted.</span>
<span class="c1">//</span>
<span class="c1">// The iterator is initially positioned at the beginning of the table.</span>
<span class="c1">//</span>
<span class="c1">// This method is equivalent to:</span>
<span class="c1">//    Iterator* iter = table-&gt;NewIterator();</span>
<span class="c1">//    iter-&gt;Seek(&quot;&quot;);</span>
<span class="c1">//    return iter;</span>
<span class="c1">// If you are going to immediately seek to another place in the</span>
<span class="c1">// returned iterator, it will be faster to use NewIterator()</span>
<span class="c1">// and avoid the extra seek.</span>
<span class="n">Iterator</span><span class="o">*</span> <span class="nf">GetIterator</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>但也要避免罗罗嗦嗦, 或者对显而易见的内容进行说明. 下面的注释就没有必要加上 “否则返回 false”, 因为已经暗含其中了:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns true if the table cannot hold any more entries.</span>
<span class="kt">bool</span> <span class="nf">IsTableFull</span><span class="p">();</span>
</pre></div>
</div>
<p>注释函数重载时, 注释的重点应该是函数中被重载的部分, 而不是简单的重复被重载的函数的注释. 多数情况下, 函数重载不需要额外的文档, 因此也没有必要加上注释.</p>
<p>注释构造/析构函数时, 切记读代码的人知道构造/析构函数的功能, 所以 “销毁这一对象” 这样的注释是没有意义的. 你应当注明的是注明构造函数对参数做了什么 (例如, 是否取得指针所有权) 以及析构函数清理了什么. 如果都是些无关紧要的内容, 直接省掉注释. 析构函数前没有注释是很正常的.</p>
</div>
<div class="section" id="section-9">
<h5>函数定义</h5>
<p>如果函数的实现过程中用到了很巧妙的方式, 那么在函数定义处应当加上解释性的注释. 例如, 你所使用的编程技巧, 实现的大致步骤, 或解释如此实现的理由. 举个例子, 你可以说明为什么函数的前半部分要加锁而后半部分不需要.</p>
<p><em>不要</em> 从 <code class="docutils literal notranslate"><span class="pre">.h</span></code> 文件或其他地方的函数声明处直接复制注释. 简要重述函数功能是可以的, 但注释重点要放在如何实现上.</p>
</div>
</div>
<div class="section" id="section-10">
<h4>8.5. 变量注释</h4>
<p><strong>总述</strong></p>
<p>通常变量名本身足以很好说明变量用途. 某些情况下, 也需要额外的注释说明.</p>
<p><strong>说明</strong></p>
<div class="section" id="section-11">
<h5>类数据成员</h5>
<p>每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途. 如果有非变量的参数(例如特殊值, 数据成员之间的关系, 生命周期等)不能够用类型与变量名明确表达, 则应当加上注释. 然而, 如果变量类型与变量名已经足以描述一个变量, 那么就不再需要加上注释.</p>
<p>特别地, 如果变量可以接受 <code class="docutils literal notranslate"><span class="pre">NULL</span></code> 或 <code class="docutils literal notranslate"><span class="pre">-1</span></code> 等警戒值, 须加以说明. 比如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">private</span><span class="o">:</span>
 <span class="c1">// Used to bounds-check table accesses. -1 means</span>
 <span class="c1">// that we don&#39;t yet know how many entries the table has.</span>
 <span class="kt">int</span> <span class="n">num_total_entries_</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-12">
<h5>全局变量</h5>
<p>和数据成员一样, 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因. 比如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The total number of tests cases that we run through in this regression test.</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">kNumTestCases</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-13">
<h4>8.6. 实现注释</h4>
<p><strong>总述</strong></p>
<p>对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释.</p>
<p><strong>说明</strong></p>
<div class="section" id="section-14">
<h5>代码前注释</h5>
<p>巧妙或复杂的代码段前要加注释. 比如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Divide result by two, taking into account that x</span>
<span class="c1">// contains the carry from the add.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">x</span> <span class="o">&amp;=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-15">
<h5>行注释</h5>
<p>比较隐晦的地方要在行尾加入注释. 在行尾空两格进行注释. 比如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// If we have enough memory, mmap the data portion too.</span>
<span class="n">mmap_budget</span> <span class="o">=</span> <span class="n">max</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mmap_budget</span> <span class="o">-</span> <span class="n">index_</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">());</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mmap_budget</span> <span class="o">&gt;=</span> <span class="n">data_size_</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">MmapData</span><span class="p">(</span><span class="n">mmap_chunk_bytes</span><span class="p">,</span> <span class="n">mlock</span><span class="p">))</span>
  <span class="k">return</span><span class="p">;</span>  <span class="c1">// Error already logged.</span>
</pre></div>
</div>
<p>注意, 这里用了两段注释分别描述这段代码的作用, 和提示函数返回时错误已经被记入日志.</p>
<p>如果你需要连续进行多行注释, 可以使之对齐获得更好的可读性:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DoSomething</span><span class="p">();</span>                  <span class="c1">// Comment here so the comments line up.</span>
<span class="n">DoSomethingElseThatIsLonger</span><span class="p">();</span>  <span class="c1">// Two spaces between the code and the comment.</span>
<span class="p">{</span> <span class="c1">// One space before comment when opening a new scope is allowed,</span>
  <span class="c1">// thus the comment lines up with the following comments and code.</span>
  <span class="n">DoSomethingElse</span><span class="p">();</span>  <span class="c1">// Two spaces before line comments normally.</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">{</span>
                    <span class="c1">// Comments in braced lists describe the next element...</span>
                    <span class="s">&quot;First item&quot;</span><span class="p">,</span>
                    <span class="c1">// .. and should be aligned appropriately.</span>
<span class="s">&quot;Second item&quot;</span><span class="p">};</span>
<span class="n">DoSomething</span><span class="p">();</span> <span class="cm">/* For trailing block comments, one space is fine. */</span>
</pre></div>
</div>
</div>
<div class="section" id="section-16">
<h5>函数参数注释</h5>
<p>如果函数参数的意义不明显, 考虑用下面的方式进行弥补:</p>
<ul class="simple">
<li>如果参数是一个字面常量, 并且这一常量在多处函数调用中被使用, 用以推断它们一致, 你应当用一个常量名让这一约定变得更明显, 并且保证这一约定不会被打破.</li>
<li>考虑更改函数的签名, 让某个 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 类型的参数变为 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 类型, 这样可以让这个参数的值表达其意义.</li>
<li>如果某个函数有多个配置选项, 你可以考虑定义一个类或结构体以保存所有的选项, 并传入类或结构体的实例. 这样的方法有许多优点, 例如这样的选项可以在调用处用变量名引用, 这样就能清晰地表明其意义. 同时也减少了函数参数的数量, 使得函数调用更易读也易写. 除此之外, 以这样的方式, 如果你使用其他的选项, 就无需对调用点进行更改.</li>
<li>用具名变量代替大段而复杂的嵌套表达式.</li>
<li>万不得已时, 才考虑在调用点用注释阐明参数的意义.</li>
</ul>
<p>比如下面的示例的对比:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// What are these arguments?</span>
<span class="k">const</span> <span class="n">DecimalNumber</span> <span class="n">product</span> <span class="o">=</span> <span class="n">CalculateProduct</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p>和</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ProductOptions</span> <span class="n">options</span><span class="p">;</span>
<span class="n">options</span><span class="p">.</span><span class="n">set_precision_decimals</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>
<span class="n">options</span><span class="p">.</span><span class="n">set_use_cache</span><span class="p">(</span><span class="n">ProductOptions</span><span class="o">::</span><span class="n">kDontUseCache</span><span class="p">);</span>
<span class="k">const</span> <span class="n">DecimalNumber</span> <span class="n">product</span> <span class="o">=</span>
    <span class="n">CalculateProduct</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="cm">/*completion_callback=*/</span><span class="k">nullptr</span><span class="p">);</span>
</pre></div>
</div>
<p>哪个更清晰一目了然.</p>
</div>
<div class="section" id="section-17">
<h5>不允许的行为</h5>
<p>不要描述显而易见的现象, <em>永远不要</em> 用自然语言翻译代码作为注释, 除非即使对深入理解 C++ 的读者来说代码的行为都是不明显的. 要假设读代码的人 C++ 水平比你高, 即便他/她可能不知道你的用意:</p>
<p>你所提供的注释应当解释代码 <em>为什么</em> 要这么做和代码的目的, 或者最好是让代码自文档化.</p>
<p>比较这样的注释:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Find the element in the vector.  &lt;-- 差: 这太明显了!</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">element</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>和这样的注释:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Process &quot;element&quot; unless it was already processed.</span>
<span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">element</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>自文档化的代码根本就不需要注释. 上面例子中的注释对下面的代码来说就是毫无必要的:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsAlreadyProcessed</span><span class="p">(</span><span class="n">element</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">Process</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-18">
<h4>8.7. 标点, 拼写和语法</h4>
<p><strong>总述</strong></p>
<p>注意标点, 拼写和语法; 写的好的注释比差的要易读的多.</p>
<p><strong>说明</strong></p>
<p>注释的通常写法是包含正确大小写和结尾句号的完整叙述性语句. 大多数情况下, 完整的句子比句子片段可读性更高. 短一点的注释, 比如代码行尾注释, 可以随意点, 但依然要注意风格的一致性.</p>
<p>虽然被别人指出该用分号时却用了逗号多少有些尴尬, 但清晰易读的代码还是很重要的. 正确的标点, 拼写和语法对此会有很大帮助.</p>
</div>
<div class="section" id="todo">
<h4>8.8. TODO 注释</h4>
<p><strong>总述</strong></p>
<p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 <code class="docutils literal notranslate"><span class="pre">TODO</span></code> 注释.</p>
<p><code class="docutils literal notranslate"><span class="pre">TODO</span></code> 注释要使用全大写的字符串 <code class="docutils literal notranslate"><span class="pre">TODO</span></code>, 在随后的圆括号里写上你的名字, 邮件地址, bug ID, 或其它身份标识和与这一 <code class="docutils literal notranslate"><span class="pre">TODO</span></code> 相关的 issue. 主要目的是让添加注释的人 (也是可以请求提供更多细节的人) 可根据规范的 <code class="docutils literal notranslate"><span class="pre">TODO</span></code> 格式进行查找. 添加 <code class="docutils literal notranslate"><span class="pre">TODO</span></code> 注释并不意味着你要自己来修正, 因此当你加上带有姓名的 <code class="docutils literal notranslate"><span class="pre">TODO</span></code> 时, 一般都是写上自己的名字.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// TODO(kl@gmail.com): Use a &quot;*&quot; here for concatenation operator.</span>
<span class="c1">// TODO(Zeke) change this to use relations.</span>
<span class="c1">// TODO(bug 12345): remove the &quot;Last visitors&quot; feature</span>
</pre></div>
</div>
<p>如果加 <code class="docutils literal notranslate"><span class="pre">TODO</span></code> 是为了在 “将来某一天做某事”, 可以附上一个非常明确的时间 “Fix by November 2005”), 或者一个明确的事项 (“Remove this code when all clients can handle XML responses.”).</p>
</div>
<div class="section" id="section-19">
<h4>8.9. 弃用注释</h4>
<p><strong>总述</strong></p>
<p>通过弃用注释（<code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> comments）以标记某接口点已弃用.</p>
<p>您可以写上包含全大写的 <code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> 的注释, 以标记某接口为弃用状态. 注释可以放在接口声明前, 或者同一行.</p>
<p>在 <code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> 一词后, 在括号中留下您的名字, 邮箱地址以及其他身份标识.</p>
<p>弃用注释应当包涵简短而清晰的指引, 以帮助其他人修复其调用点. 在 C++ 中, 你可以将一个弃用函数改造成一个内联函数, 这一函数将调用新的接口.</p>
<p>仅仅标记接口为 <code class="docutils literal notranslate"><span class="pre">DEPRECATED</span></code> 并不会让大家不约而同地弃用, 您还得亲自主动修正调用点（callsites）, 或是找个帮手.</p>
<p>修正好的代码应该不会再涉及弃用接口点了, 着实改用新接口点. 如果您不知从何下手, 可以找标记弃用注释的当事人一起商量.</p>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>关于注释风格, 很多 C++ 的 coders 更喜欢行注释, C coders 或许对块注释依然情有独钟, 或者在文件头大段大段的注释时使用块注释;</li>
<li>文件注释可以炫耀你的成就, 也是为了捅了篓子别人可以找你;</li>
<li>注释要言简意赅, 不要拖沓冗余, 复杂的东西简单化和简单的东西复杂化都是要被鄙视的;</li>
<li>对于 Chinese coders 来说, 用英文注释还是用中文注释, it is a problem, 但不管怎样, 注释是为了让别人看懂, 难道是为了炫耀编程语言之外的你的母语或外语水平吗；</li>
<li>注释不要太乱, 适当的缩进才会让人乐意看. 但也没有必要规定注释从第几列开始 (我自己写代码的时候总喜欢这样), UNIX/LINUX 下还可以约定是使用 tab 还是 space, 个人倾向于 space;</li>
<li>TODO 很不错, 有时候, 注释确实是为了标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/formatting"></span><div class="section" id="section-1">
<h3>9. 格式</h3>
<p>每个人都可能有自己的代码风格和格式, 但如果一个项目中的所有人都遵循同一风格的话, 这个项目就能更顺利地进行. 每个人未必能同意下述的每一处格式规则, 而且其中的不少规则需要一定时间的适应, 但整个项目服从统一的编程风格是很重要的, 只有这样才能让所有人轻松地阅读和理解代码.</p>
<p>为了帮助你正确的格式化代码, 我们写了一个 <a class="reference external" href="https://raw.githubusercontent.com/google/styleguide/gh-pages/google-c-style.el">emacs 配置文件</a>.</p>
<div class="section" id="section-2">
<span id="line-length"></span><h4>9.1. 行长度</h4>
<p><strong>总述</strong></p>
<p>每一行代码字符数不超过 80.</p>
<p>我们也认识到这条规则是有争议的, 但很多已有代码都遵照这一规则, 因此我们感觉一致性更重要.</p>
<p><strong>优点</strong></p>
<p>提倡该原则的人认为强迫他们调整编辑器窗口大小是很野蛮的行为. 很多人同时并排开几个代码窗口, 根本没有多余的空间拉伸窗口. 大家都把窗口最大尺寸加以限定, 并且 80 列宽是传统标准. 那么为什么要改变呢?</p>
<p><strong>缺点</strong></p>
<p>反对该原则的人则认为更宽的代码行更易阅读. 80 列的限制是上个世纪 60 年代的大型机的古板缺陷; 现代设备具有更宽的显示屏, 可以很轻松地显示更多代码.</p>
<p><strong>结论</strong></p>
<p>80 个字符是最大值.</p>
<p>如果无法在不伤害易读性的条件下进行断行, 那么注释行可以超过 80 个字符, 这样可以方便复制粘贴. 例如, 带有命令示例或 URL 的行可以超过 80 个字符.</p>
<p>包含长路径的 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 语句可以超出80列.</p>
<p><a class="reference internal" href="contents.html#define-guard"><span class="std std-ref">头文件保护</span></a> 可以无视该原则.</p>
</div>
<div class="section" id="ascii">
<h4>9.2. 非 ASCII 字符</h4>
<p><strong>总述</strong></p>
<p>尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码.</p>
<p><strong>说明</strong></p>
<p>即使是英文, 也不应将用户界面的文本硬编码到源代码中, 因此非 ASCII 字符应当很少被用到. 特殊情况下可以适当包含此类字符. 例如, 代码分析外部数据文件时, 可以适当硬编码数据文件中作为分隔符的非 ASCII 字符串; 更常见的是 (不需要本地化的) 单元测试代码可能包含非 ASCII 字符串. 此类情况下, 应使用 UTF-8 编码, 因为很多工具都可以理解和处理 UTF-8 编码.</p>
<p>十六进制编码也可以, 能增强可读性的情况下尤其鼓励 —— 比如 <code class="docutils literal notranslate"><span class="pre">&quot;\xEF\xBB\xBF&quot;</span></code>, 或者更简洁地写作 <code class="docutils literal notranslate"><span class="pre">u8&quot;\uFEFF&quot;</span></code>, 在 Unicode 中是 <em>零宽度 无间断</em> 的间隔符号, 如果不用十六进制直接放在 UTF-8 格式的源文件中, 是看不到的.</p>
<p>(Yang.Y 注: <code class="docutils literal notranslate"><span class="pre">&quot;\xEF\xBB\xBF&quot;</span></code> 通常用作 UTF-8 with BOM 编码标记)</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">u8</span></code> 前缀把带 <code class="docutils literal notranslate"><span class="pre">uXXXX</span></code> 转义序列的字符串字面值编码成 UTF-8. 不要用在本身就带 UTF-8 字符的字符串字面值上, 因为如果编译器不把源代码识别成 UTF-8, 输出就会出错.</p>
<p>别用 C++11 的 <code class="docutils literal notranslate"><span class="pre">char16_t</span></code> 和 <code class="docutils literal notranslate"><span class="pre">char32_t</span></code>, 它们和 UTF-8 文本没有关系, <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code> 同理, 除非你写的代码要调用 Windows API, 后者广泛使用了 <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code>.</p>
</div>
<div class="section" id="section-3">
<h4>9.3. 空格还是制表位</h4>
<p><strong>总述</strong></p>
<p>只使用空格, 每次缩进 2 个空格.</p>
<p><strong>说明</strong></p>
<p>我们使用空格缩进. 不要在代码中使用制表符. 你应该设置编辑器将制表符转为空格.</p>
</div>
<div class="section" id="section-4">
<h4>9.4. 函数声明与定义</h4>
<p><strong>总述</strong></p>
<p>返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 <a class="reference internal" href="#function-calls"><span class="std std-ref">函数调用</span></a> 一致.</p>
<p><strong>说明</strong></p>
<p>函数看上去像这样:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="n">ClassName</span><span class="o">::</span><span class="n">FunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span> <span class="n">Type</span> <span class="n">par_name2</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果同一行文本太多, 放不下所有参数:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="n">ClassName</span><span class="o">::</span><span class="n">ReallyLongFunctionName</span><span class="p">(</span><span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span> <span class="n">Type</span> <span class="n">par_name2</span><span class="p">,</span>
                                             <span class="n">Type</span> <span class="n">par_name3</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>甚至连第一个参数都放不下:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ReturnType</span> <span class="n">LongClassName</span><span class="o">::</span><span class="n">ReallyReallyReallyLongFunctionName</span><span class="p">(</span>
    <span class="n">Type</span> <span class="n">par_name1</span><span class="p">,</span>  <span class="c1">// 4 space indent</span>
    <span class="n">Type</span> <span class="n">par_name2</span><span class="p">,</span>
    <span class="n">Type</span> <span class="n">par_name3</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 space indent</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意以下几点:</p>
<ul class="simple">
<li>使用好的参数名.</li>
<li>只有在参数未被使用或者其用途非常明显时, 才能省略参数名.</li>
<li>如果返回类型和函数名在一行放不下, 分行.</li>
<li>如果返回类型与函数声明或定义分行了, 不要缩进.</li>
<li>左圆括号总是和函数名在同一行.</li>
<li>函数名和左圆括号间永远没有空格.</li>
<li>圆括号与参数间没有空格.</li>
<li>左大括号总在最后一个参数同一行的末尾处, 不另起新行.</li>
<li>右大括号总是单独位于函数最后一行, 或者与左大括号同一行.</li>
<li>右圆括号和左大括号间总是有一个空格.</li>
<li>所有形参应尽可能对齐.</li>
<li>缺省缩进为 2 个空格.</li>
<li>换行后的参数保持 4 个空格的缩进.</li>
</ul>
<p>未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span><span class="p">);</span>
  <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="n">radians</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="n">radians</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span> <span class="cm">/*radians*/</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 差 - 如果将来有人要实现, 很难猜出变量的作用.</span>
<span class="kt">void</span> <span class="n">Circle</span><span class="o">::</span><span class="n">Rotate</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p>属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MUST_USE_RESULT</span> <span class="kt">bool</span> <span class="nf">IsOK</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="lambda">
<h4>9.5. Lambda 表达式</h4>
<p><strong>总述</strong></p>
<p>Lambda 表达式对形参和函数体的格式化和其他函数一致; 捕获列表同理, 表项用逗号隔开.</p>
<p><strong>说明</strong></p>
<p>若用引用捕获, 在变量名和 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 之间不留空格.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">add_to_x</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
<p>短 lambda 就写得和内联函数一样.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">blacklist</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">digits</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
<span class="n">digits</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">digits</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">digits</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">blacklist</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
               <span class="k">return</span> <span class="n">blacklist</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blacklist</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
             <span class="p">}),</span>
             <span class="n">digits</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<span id="function-calls"></span><h4>9.6. 函数调用</h4>
<p><strong>总述</strong></p>
<p>要么一行写完函数调用, 要么在圆括号里对参数分行, 要么参数另起一行且缩进四格. 如果没有其它顾虑的话, 尽可能精简行数, 比如把多个参数适当地放在同一行里.</p>
<p><strong>说明</strong></p>
<p>函数调用遵循如下形式：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span> <span class="n">argument3</span><span class="p">);</span>
</pre></div>
</div>
<p>如果同一行放不下, 可断为多行, 后面每一行都和第一个实参对齐, 左圆括号后和右圆括号前不要留空格：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">averyveryveryverylongargument1</span><span class="p">,</span>
                          <span class="n">argument2</span><span class="p">,</span> <span class="n">argument3</span><span class="p">);</span>
</pre></div>
</div>
<p>参数也可以放在次行, 缩进四格：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="n">DoSomething</span><span class="p">(</span>
        <span class="n">argument1</span><span class="p">,</span> <span class="n">argument2</span><span class="p">,</span>  <span class="c1">// 4 空格缩进</span>
        <span class="n">argument3</span><span class="p">,</span> <span class="n">argument4</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>把多个参数放在同一行以减少函数调用所需的行数, 除非影响到可读性. 有人认为把每个参数都独立成行, 不仅更好读, 而且方便编辑参数. 不过, 比起所谓的参数编辑, 我们更看重可读性, 且后者比较好办：</p>
<p>如果一些参数本身就是略复杂的表达式, 且降低了可读性, 那么可以直接创建临时变量描述该表达式, 并传递给函数：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">my_heuristic</span> <span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">bases</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">my_heuristic</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>或者放着不管, 补充上注释：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">retval</span> <span class="o">=</span> <span class="n">DoSomething</span><span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">bases</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>  <span class="c1">// Score heuristic.</span>
                          <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>如果某参数独立成行, 对可读性更有帮助的话, 那也可以如此做. 参数的格式处理应当以可读性而非其他作为最重要的原则.</p>
<p>此外, 如果一系列参数本身就有一定的结构, 可以酌情地按其结构来决定参数格式：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 通过 3x3 矩阵转换 widget.</span>
<span class="n">my_widget</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span>
                    <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y3</span><span class="p">,</span>
                    <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">z3</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<span id="braced-initializer-list-format"></span><h4>9.7. 列表初始化格式</h4>
<p><strong>总述</strong></p>
<p>您平时怎么格式化函数调用, 就怎么格式化 <a class="reference internal" href="contents.html#braced-initializer-list"><span class="std std-ref">列表初始化</span></a>.</p>
<p><strong>说明</strong></p>
<p>如果列表初始化伴随着名字, 比如类型或变量名, 格式化时将将名字视作函数调用名, <cite>{}</cite> 视作函数调用的括号. 如果没有名字, 就视作名字长度为零.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 一行列表初始化示范.</span>
<span class="k">return</span> <span class="p">{</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">};</span>
<span class="n">functioncall</span><span class="p">({</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">});</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">{</span><span class="n">foo</span><span class="p">,</span> <span class="n">bar</span><span class="p">};</span>

<span class="c1">// 当不得不断行时.</span>
<span class="n">SomeFunction</span><span class="p">(</span>
    <span class="p">{</span><span class="s">&quot;assume a zero-length name before {&quot;</span><span class="p">},</span>  <span class="c1">// 假设在 { 前有长度为零的名字.</span>
    <span class="n">some_other_function_parameter</span><span class="p">);</span>
<span class="n">SomeType</span> <span class="n">variable</span><span class="p">{</span>
    <span class="n">some</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span>
    <span class="p">{</span><span class="s">&quot;assume a zero-length name before {&quot;</span><span class="p">},</span>  <span class="c1">// 假设在 { 前有长度为零的名字.</span>
    <span class="n">SomeOtherType</span><span class="p">{</span>
        <span class="s">&quot;Very long string requiring the surrounding breaks.&quot;</span><span class="p">,</span>  <span class="c1">// 非常长的字符串, 前后都需要断行.</span>
        <span class="n">some</span><span class="p">,</span> <span class="n">other</span> <span class="n">values</span><span class="p">},</span>
    <span class="n">SomeOtherType</span><span class="p">{</span><span class="s">&quot;Slightly shorter string&quot;</span><span class="p">,</span>  <span class="c1">// 稍短的字符串.</span>
                  <span class="n">some</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">values</span><span class="p">}};</span>
<span class="n">SomeType</span> <span class="n">variable</span><span class="p">{</span>
    <span class="s">&quot;This is too long to fit all in one line&quot;</span><span class="p">};</span>  <span class="c1">// 字符串过长, 因此无法放在同一行.</span>
<span class="n">MyType</span> <span class="n">m</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1">// 注意了, 您可以在 { 前断行.</span>
    <span class="n">superlongvariablename1</span><span class="p">,</span>
    <span class="n">superlongvariablename2</span><span class="p">,</span>
    <span class="p">{</span><span class="kt">short</span><span class="p">,</span> <span class="n">interior</span><span class="p">,</span> <span class="n">list</span><span class="p">},</span>
    <span class="p">{</span><span class="n">interiorwrappinglist</span><span class="p">,</span>
     <span class="n">interiorwrappinglist2</span><span class="p">}};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<h4>9.8. 条件语句</h4>
<p><strong>总述</strong></p>
<p>倾向于不在圆括号内使用空格. 关键字 <code class="docutils literal notranslate"><span class="pre">if</span></code> 和 <code class="docutils literal notranslate"><span class="pre">else</span></code> 另起一行.</p>
<p><strong>说明</strong></p>
<p>对基本条件语句有两种可以接受的格式. 一种在圆括号和条件之间有空格, 另一种没有.</p>
<p>最常见的是没有空格的格式. 哪一种都可以, 最重要的是 <em>保持一致</em>. 如果你是在修改一个文件, 参考当前已有格式. 如果是写新的代码, 参考目录下或项目中其它文件. 还在犹豫的话, 就不要加空格了.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 圆括号里没有空格.</span>
  <span class="p">...</span>  <span class="c1">// 2 空格缩进.</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(...)</span> <span class="p">{</span>  <span class="c1">// else 与 if 的右括号同一行.</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果你更喜欢在圆括号内部加空格:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span> <span class="n">condition</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">// 圆括号与空格紧邻 - 不常见</span>
  <span class="p">...</span>  <span class="c1">// 2 空格缩进.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  <span class="c1">// else 与 if 的右括号同一行.</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意所有情况下 <code class="docutils literal notranslate"><span class="pre">if</span></code> 和左圆括号间都有个空格. 右圆括号和左大括号之间也要有个空格:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>     <span class="c1">// 差 - IF 后面没空格.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">){</span>   <span class="c1">// 差 - { 前面没空格.</span>
<span class="k">if</span><span class="p">(</span><span class="n">condition</span><span class="p">){</span>    <span class="c1">// 变本加厉地差.</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 好 - IF 和 { 都与空格紧邻.</span>
</pre></div>
</div>
<p>如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 <code class="docutils literal notranslate"><span class="pre">else</span></code> 子句时使用:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">kFoo</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">kBar</span><span class="p">)</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
</pre></div>
</div>
<p>如果语句有 <code class="docutils literal notranslate"><span class="pre">else</span></code> 分支则不允许:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不允许 - 当有 ELSE 分支时 IF 块却写在同一行</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="n">DoThis</span><span class="p">();</span>
<span class="k">else</span> <span class="nf">DoThat</span><span class="p">();</span>
</pre></div>
</div>
<p>通常, 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 <code class="docutils literal notranslate"><span class="pre">if</span></code> 必须总是使用大括号:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 空格缩进.</span>

<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>  <span class="c1">// 2 空格缩进.</span>
<span class="p">}</span>
</pre></div>
</div>
<p>但如果语句中某个 <code class="docutils literal notranslate"><span class="pre">if-else</span></code> 分支使用了大括号的话, 其它分支也必须使用:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不可以这样子 - IF 有大括号 ELSE 却没有.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span>
  <span class="n">bar</span><span class="p">;</span>

<span class="c1">// 不可以这样子 - ELSE 有大括号 IF 却没有.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span>
  <span class="n">foo</span><span class="p">;</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 只要其中一个分支用了大括号, 两个分支都要用上大括号.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-8">
<h4>9.9. 循环和开关选择语句</h4>
<p><strong>总述</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句可以使用大括号分段, 以表明 cases 之间不是连在一起的. 在单语句循环里, 括号可用可不用. 空循环体应使用 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 或 <code class="docutils literal notranslate"><span class="pre">continue</span></code>.</p>
<p><strong>说明</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句中的 <code class="docutils literal notranslate"><span class="pre">case</span></code> 块可以使用大括号也可以不用, 取决于你的个人喜好. 如果用的话, 要按照下文所述的方法.</p>
<p>如果有不满足 <code class="docutils literal notranslate"><span class="pre">case</span></code> 条件的枚举值, <code class="docutils literal notranslate"><span class="pre">switch</span></code> 应该总是包含一个 <code class="docutils literal notranslate"><span class="pre">default</span></code> 匹配 (如果有输入值没有 case 去处理, 编译器将给出 warning). 如果 <code class="docutils literal notranslate"><span class="pre">default</span></code> 应该永远执行不到, 简单的加条 <code class="docutils literal notranslate"><span class="pre">assert</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="p">{</span>  <span class="c1">// 2 空格缩进</span>
    <span class="p">...</span>      <span class="c1">// 4 空格缩进</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">default</span><span class="o">:</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在单语句循环里, 括号可用可不用：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSomeNumber</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I love you</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSomeNumber</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;I take it back</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>空循环体应使用 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 或 <code class="docutils literal notranslate"><span class="pre">continue</span></code>, 而不是一个简单的分号.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 反复循环直到条件失效.</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">kSomeNumber</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 可 - 空循环体.</span>
<span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>  <span class="c1">// 可 - contunue 表明没有逻辑.</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">condition</span><span class="p">);</span>  <span class="c1">// 差 - 看起来仅仅只是 while/loop 的部分之一.</span>
</pre></div>
</div>
</div>
<div class="section" id="section-9">
<h4>9.10. 指针和引用表达式</h4>
<p><strong>总述</strong></p>
<p>句点或箭头前后不要有空格. 指针/地址操作符 (<code class="docutils literal notranslate"><span class="pre">*,</span> <span class="pre">&amp;</span></code>) 之后不能有空格.</p>
<p><strong>说明</strong></p>
<p>下面是指针和引用表达式的正确使用范例:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">y</span><span class="p">;</span>
</pre></div>
</div>
<p>注意:</p>
<ul class="simple">
<li>在访问成员时, 句点或箭头前后没有空格.</li>
<li>指针操作符 <code class="docutils literal notranslate"><span class="pre">*</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 后没有空格.</li>
</ul>
<p>在声明指针变量或参数时, 星号与类型或变量名紧挨都可以:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 好, 空格前置.</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">;</span>

<span class="c1">// 好, 空格后置.</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">c</span><span class="p">;</span>
<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">;</span>  <span class="c1">// 不允许 - 在多重声明中不能使用 &amp; 或 *</span>
<span class="kt">char</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span>  <span class="c1">// 差 - * 两边都有空格</span>
<span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span> <span class="n">str</span><span class="p">;</span>  <span class="c1">// 差 - &amp; 两边都有空格.</span>
</pre></div>
</div>
<p>在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格.</p>
</div>
<div class="section" id="section-10">
<h4>9.11. 布尔表达式</h4>
<p><strong>总述</strong></p>
<p>如果一个布尔表达式超过 <a class="reference internal" href="#line-length"><span class="std std-ref">标准行宽</span></a>, 断行方式要统一一下.</p>
<p><strong>说明</strong></p>
<p>下例中, 逻辑与 (<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>) 操作符总位于行尾:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">this_one_thing</span> <span class="o">&gt;</span> <span class="n">this_other_thing</span> <span class="o">&amp;&amp;</span>
    <span class="n">a_third_thing</span> <span class="o">==</span> <span class="n">a_fourth_thing</span> <span class="o">&amp;&amp;</span>
    <span class="n">yet_another</span> <span class="o">&amp;&amp;</span> <span class="n">last_one</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意, 上例的逻辑与 (<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>) 操作符均位于行尾. 这个格式在 Google 里很常见, 虽然把所有操作符放在开头也可以. 可以考虑额外插入圆括号, 合理使用的话对增强可读性是很有帮助的. 此外, 直接用符号形式的操作符, 比如 <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">~</span></code>, 不要用词语形式的 <code class="docutils literal notranslate"><span class="pre">and</span></code> 和 <code class="docutils literal notranslate"><span class="pre">compl</span></code>.</p>
</div>
<div class="section" id="section-11">
<h4>9.12. 函数返回值</h4>
<p><strong>总述</strong></p>
<p>不要在 <code class="docutils literal notranslate"><span class="pre">return</span></code> 表达式里加上非必须的圆括号.</p>
<p><strong>说明</strong></p>
<p>只有在写 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">expr</span></code> 要加上括号的时候才在 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">expr;</span></code> 里使用括号.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">result</span><span class="p">;</span>                  <span class="c1">// 返回值很简单, 没有圆括号.</span>
<span class="c1">// 可以用圆括号把复杂表达式圈起来, 改善可读性.</span>
<span class="k">return</span> <span class="p">(</span><span class="n">some_long_condition</span> <span class="o">&amp;&amp;</span>
        <span class="n">another_condition</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="p">);</span>                <span class="c1">// 毕竟您从来不会写 var = (value);</span>
<span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>                <span class="c1">// return 可不是函数！</span>
</pre></div>
</div>
</div>
<div class="section" id="section-12">
<h4>9.13. 变量及数组初始化</h4>
<p><strong>总述</strong></p>
<p>用 <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 均可.</p>
<p><strong>说明</strong></p>
<p>您可以用 <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">{}</span></code>, 以下的例子都是正确的：</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">x</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>
<span class="n">string</span> <span class="nf">name</span><span class="p">(</span><span class="s">&quot;Some Name&quot;</span><span class="p">);</span>
<span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Some Name&quot;</span><span class="p">;</span>
<span class="n">string</span> <span class="n">name</span><span class="p">{</span><span class="s">&quot;Some Name&quot;</span><span class="p">};</span>
</pre></div>
</div>
<p>请务必小心列表初始化 <code class="docutils literal notranslate"><span class="pre">{...}</span></code> 用 <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> 构造函数初始化出的类型. 非空列表初始化就会优先调用 <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code>, 不过空列表初始化除外, 后者原则上会调用默认构造函数. 为了强制禁用 <code class="docutils literal notranslate"><span class="pre">std::initializer_list</span></code> 构造函数, 请改用括号.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 内容为 100 个 1 的向量.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>  <span class="c1">// 内容为 100 和 1 的向量.</span>
</pre></div>
</div>
<p>此外, 列表初始化不允许整型类型的四舍五入, 这可以用来避免一些类型上的编程失误.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">pi</span><span class="p">(</span><span class="mf">3.14</span><span class="p">);</span>  <span class="c1">// 好 - pi == 3.</span>
<span class="kt">int</span> <span class="n">pi</span><span class="p">{</span><span class="mf">3.14</span><span class="p">};</span>  <span class="c1">// 编译错误: 缩窄转换.</span>
</pre></div>
</div>
</div>
<div class="section" id="section-13">
<h4>9.14. 预处理指令</h4>
<p><strong>总述</strong></p>
<p>预处理指令不要缩进, 从行首开始.</p>
<p><strong>说明</strong></p>
<p>即使预处理指令位于缩进代码块中, 指令也应从行首开始.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 好 - 指令从行首开始</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lopsided_score</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#if DISASTER_PENDING      </span><span class="c1">// 正确 - 从行首开始</span>
    <span class="n">DropEverything</span><span class="p">();</span>
<span class="cp"># if NOTIFY               </span><span class="c1">// 非必要 - # 后跟空格</span>
    <span class="n">NotifyClient</span><span class="p">();</span>
<span class="cp"># endif</span>
<span class="cp">#endif</span>
    <span class="n">BackToNormal</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 差 - 指令缩进</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lopsided_score</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#if DISASTER_PENDING  </span><span class="c1">// 差 - &quot;#if&quot; 应该放在行开头</span>
    <span class="n">DropEverything</span><span class="p">();</span>
    <span class="cp">#endif                </span><span class="c1">// 差 - &quot;#endif&quot; 不要缩进</span>
    <span class="n">BackToNormal</span><span class="p">();</span>
  <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-14">
<h4>9.15. 类格式</h4>
<p><strong>总述</strong></p>
<p>访问控制块的声明依次序是 <code class="docutils literal notranslate"><span class="pre">public:</span></code>, <code class="docutils literal notranslate"><span class="pre">protected:</span></code>, <code class="docutils literal notranslate"><span class="pre">private:</span></code>, 每个都缩进 1 个空格.</p>
<p><strong>说明</strong></p>
<p>类声明 (下面的代码中缺少注释, 参考 <a class="reference internal" href="contents.html#class-comments"><span class="std std-ref">类注释</span></a>) 的基本格式如下:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OtherClass</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>      <span class="c1">// 注意有一个空格的缩进</span>
  <span class="n">MyClass</span><span class="p">();</span>  <span class="c1">// 标准的两空格缩进</span>
  <span class="k">explicit</span> <span class="nf">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">);</span>
  <span class="o">~</span><span class="n">MyClass</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">SomeFunction</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">SomeFunctionThatDoesNothing</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">set_some_var</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span> <span class="n">some_var_</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">int</span> <span class="nf">some_var</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">some_var_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">SomeInternalFunction</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">some_var_</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">some_other_var_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>注意事项:</p>
<ul class="simple">
<li>所有基类名应在 80 列限制下尽量与子类名放在同一行.</li>
<li>关键词 <code class="docutils literal notranslate"><span class="pre">public:</span></code>, <code class="docutils literal notranslate"><span class="pre">protected:</span></code>, <code class="docutils literal notranslate"><span class="pre">private:</span></code> 要缩进 1 个空格.</li>
<li>除第一个关键词 (一般是 <code class="docutils literal notranslate"><span class="pre">public</span></code>) 外, 其他关键词前要空一行. 如果类比较小的话也可以不空.</li>
<li>这些关键词后不要保留空行.</li>
<li><code class="docutils literal notranslate"><span class="pre">public</span></code> 放在最前面, 然后是 <code class="docutils literal notranslate"><span class="pre">protected</span></code>, 最后是 <code class="docutils literal notranslate"><span class="pre">private</span></code>.</li>
<li>关于声明顺序的规则请参考 <a class="reference internal" href="contents.html#declaration-order"><span class="std std-ref">声明顺序</span></a> 一节.</li>
</ul>
</div>
<div class="section" id="section-15">
<h4>9.16. 构造函数初始值列表</h4>
<p><strong>总述</strong></p>
<p>构造函数初始化列表放在同一行或按四格缩进并排多行.</p>
<p><strong>说明</strong></p>
<p>下面两种初始值列表方式都可以接受:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 如果所有变量能放在同一行:</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span> <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 如果不能放在同一行,</span>
<span class="c1">// 必须置于冒号后, 并缩进 4 个空格</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">some_other_var_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 如果初始化列表需要置于多行, 将每一个成员放在单独的一行</span>
<span class="c1">// 并逐行对齐</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span>             <span class="c1">// 4 space indent</span>
      <span class="n">some_other_var_</span><span class="p">(</span><span class="n">var</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// lined up</span>
  <span class="n">DoSomething</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 右大括号 } 可以和左大括号 { 放在同一行</span>
<span class="c1">// 如果这样做合适的话</span>
<span class="n">MyClass</span><span class="o">::</span><span class="n">MyClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">var</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">some_var_</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-16">
<h4>9.17. 命名空间格式化</h4>
<p><strong>总述</strong></p>
<p>命名空间内容不缩进.</p>
<p><strong>说明</strong></p>
<p><a class="reference internal" href="contents.html#namespaces"><span class="std std-ref">命名空间</span></a> 不要增加额外的缩进层次, 例如:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="p">{</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// 正确. 命名空间内没有额外的缩进.</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
<p>不要在命名空间内缩进:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="p">{</span>

  <span class="c1">// 错, 缩进多余了.</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>

<span class="p">}</span>  <span class="c1">// namespace</span>
</pre></div>
</div>
<p>声明嵌套命名空间时, 每个命名空间都独立成行.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
</pre></div>
</div>
</div>
<div class="section" id="section-17">
<h4>9.18. 水平留白</h4>
<p><strong>总述</strong></p>
<p>水平留白的使用根据在代码中的位置决定. 永远不要在行尾添加没意义的留白.</p>
<p><strong>说明</strong></p>
<div class="section" id="section-18">
<h5>通用</h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">bool</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 左大括号前总是有空格.</span>
  <span class="p">...</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 分号前不加空格.</span>
<span class="c1">// 列表初始化中大括号内的空格是可选的.</span>
<span class="c1">// 如果加了空格, 那么两边都要加上.</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

<span class="c1">// 继承与初始化列表中的冒号前后恒有空格.</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Bar</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// 对于单行函数的实现, 在大括号内加上空格</span>
  <span class="c1">// 然后是函数实现</span>
  <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">Bar</span><span class="p">(),</span> <span class="n">baz_</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 大括号里面是空的话, 不加空格.</span>
  <span class="kt">void</span> <span class="n">Reset</span><span class="p">()</span> <span class="p">{</span> <span class="n">baz_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// 用空格把大括号与实现分开.</span>
  <span class="p">...</span>
</pre></div>
</div>
<p>添加冗余的留白会给其他人编辑时造成额外负担. 因此, 行尾不要留空格. 如果确定一行代码已经修改完毕, 将多余的空格去掉; 或者在专门清理空格时去掉（尤其是在没有其他人在处理这件事的时候). (Yang.Y 注: 现在大部分代码编辑器稍加设置后, 都支持自动删除行首/行尾空格, 如果不支持, 考虑换一款编辑器或 IDE)</p>
</div>
<div class="section" id="section-19">
<h5>循环和条件语句</h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>          <span class="c1">// if 条件语句和循环语句关键字后均有空格.</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>          <span class="c1">// else 前后有空格.</span>
<span class="p">}</span>
<span class="k">while</span> <span class="p">(</span><span class="n">test</span><span class="p">)</span> <span class="p">{}</span>   <span class="c1">// 圆括号内部不紧邻空格.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span>    <span class="c1">// 循环和条件语句的圆括号里可以与空格紧邻.</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">test</span> <span class="p">)</span> <span class="p">{</span>     <span class="c1">// 圆括号, 但这很少见. 总之要一致.</span>
<span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 循环里内 ; 后恒有空格, ;  前可以加个空格.</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>         <span class="c1">// switch case 的冒号前无空格.</span>
    <span class="p">...</span>
  <span class="k">case</span> <span class="mi">2</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// 如果冒号有代码, 加个空格.</span>
</pre></div>
</div>
</div>
<div class="section" id="section-20">
<h5>操作符</h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 赋值运算符前后总是有空格.</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 其它二元操作符也前后恒有空格, 不过对于表达式的子式可以不加空格.</span>
<span class="c1">// 圆括号内部没有紧邻空格.</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">/</span><span class="n">z</span><span class="p">;</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">);</span>

<span class="c1">// 在参数和一元操作符之间不加空格.</span>
<span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
<span class="o">++</span><span class="n">x</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">y</span><span class="p">)</span>
  <span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="section-21">
<h5>模板和转换</h5>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 尖括号(&lt; and &gt;) 不与空格紧邻, &lt; 前没有空格, &gt; 和 ( 之间也没有.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">;</span>
<span class="n">y</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="c1">// 在类型与指针操作符之间留空格也可以, 但要保持一致.</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-22">
<h4>9.19. 垂直留白</h4>
<p><strong>总述</strong></p>
<p>垂直留白越少越好.</p>
<p><strong>说明</strong></p>
<p>这不仅仅是规则而是原则问题了: 不在万不得已, 不要使用空行. 尤其是: 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行.</p>
<p>基本原则是: 同一屏可以显示的代码越多, 越容易理解程序的控制流. 当然, 过于密集的代码块和过于疏松的代码块同样难看, 这取决于你的判断. 但通常是垂直留白越少越好.</p>
<p>下面的规则可以让加入的空行更有效:</p>
<ul class="simple">
<li>函数体内开头或结尾的空行可读性微乎其微.</li>
<li>在多重 if-else 块里加空行或许有点可读性.</li>
</ul>
</div>
<div class="section" id="yulefox">
<h4>译者 (YuleFox) 笔记</h4>
<ol class="arabic simple">
<li>对于代码格式, 因人, 系统而异各有优缺点, 但同一个项目中遵循同一标准还是有必要的;</li>
<li>行宽原则上不超过 80 列, 把 22 寸的显示屏都占完, 怎么也说不过去;</li>
<li>尽量不使用非 ASCII 字符, 如果使用的话, 参考 UTF-8 格式 (尤其是 UNIX/Linux 下, Windows 下可以考虑宽字符), 尽量不将字符串常量耦合到代码中, 比如独立出资源文件, 这不仅仅是风格问题了;</li>
<li>UNIX/Linux 下无条件使用空格, MSVC 的话使用 Tab 也无可厚非;</li>
<li>函数参数, 逻辑条件, 初始化列表: 要么所有参数和函数名放在同一行, 要么所有参数并排分行;</li>
<li>除函数定义的左大括号可以置于行首外, 包括函数/类/结构体/枚举声明, 各种语句的左大括号置于行尾, 所有右大括号独立成行;</li>
<li><code class="docutils literal notranslate"><span class="pre">.</span></code>/<code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> 操作符前后不留空格, <code class="docutils literal notranslate"><span class="pre">*</span></code>/<code class="docutils literal notranslate"><span class="pre">&amp;</span></code> 不要前后都留, 一个就可, 靠左靠右依各人喜好;</li>
<li>预处理指令/命名空间不使用额外缩进, 类/结构体/枚举/函数/语句使用缩进;</li>
<li>初始化用 <code class="docutils literal notranslate"><span class="pre">=</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">()</span></code> 依个人喜好, 统一就好;</li>
<li><code class="docutils literal notranslate"><span class="pre">return</span></code> 不要加 <code class="docutils literal notranslate"><span class="pre">()</span></code>;</li>
<li>水平/垂直留白不要滥用, 怎么易读怎么来.</li>
<li>关于 UNIX/Linux 风格为什么要把左大括号置于行尾 (<code class="docutils literal notranslate"><span class="pre">.cc</span></code> 文件的函数实现处, 左大括号位于行首), 我的理解是代码看上去比较简约, 想想行首除了函数体被一对大括号封在一起之外, 只有右大括号的代码看上去确实也舒服; Windows 风格将左大括号置于行首的优点是匹配情况一目了然.</li>
</ol>
</div>
<div class="section" id="acgtyrant">
<h4>译者（acgtyrant）笔记</h4>
<ol class="arabic simple">
<li>80 行限制事实上有助于避免代码可读性失控, 比如超多重嵌套块, 超多重函数调用等等.</li>
<li>Linux 上设置好了 Locale 就几乎一劳永逸设置好所有开发环境的编码, 不像奇葩的 Windows.</li>
<li>Google 强调有一对 if-else 时, 不论有没有嵌套, 都要有大括号. Apple 正好 <a class="reference external" href="http://coolshell.cn/articles/11112.html">有栽过跟头</a> .</li>
<li>其实我主张指针／地址操作符与变量名紧邻, <code class="docutils literal notranslate"><span class="pre">int*</span> <span class="pre">a,</span> <span class="pre">b</span></code> vs <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*a,</span> <span class="pre">b</span></code>, 新手会误以为前者的 <code class="docutils literal notranslate"><span class="pre">b</span></code> 是 <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*</span></code> 变量, 但后者就不一样了, 高下立判.</li>
<li>在这风格指南里我才刚知道 C++ 原来还有所谓的 <a class="reference external" href="http://en.cppreference.com/w/cpp/language/operator_alternative">Alternative operator representations</a>, 大概没人用吧.</li>
<li>注意构造函数初始值列表（Constructer Initializer List）与列表初始化（Initializer List）是两码事, 我就差点混淆了它们的翻译.</li>
<li>事实上, 如果您熟悉英语本身的书写规则, 就会发现该风格指南在格式上的规定与英语语法相当一脉相承. 比如普通标点符号和单词后面还有文本的话, 总会留一个空格; 特殊符号与单词之间就不用留了, 比如 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(true)</span></code> 中的圆括号与 <code class="docutils literal notranslate"><span class="pre">true</span></code>.</li>
<li>本风格指南没有明确规定 void 函数里要不要用 return 语句, 不过就 Google 开源项目 leveldb 并没有写; 此外从 <a class="reference external" href="http://stackoverflow.com/questions/9316717/is-a-blank-return-statement-at-the-end-of-a-function-whos-return-type-is-void-ne">Is a blank return statement at the end of a function whos return type is void necessary?</a> 来看, <code class="docutils literal notranslate"><span class="pre">return;</span></code> 比 <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">;</span></code> 更约定俗成（事实上 cpplint 会对后者报错, 指出分号前有多余的空格）, 且可用来提前跳出函数栈.</li>
</ol>
</div>
</div>
<span id="document-google-cpp-styleguide/exceptions"></span><div class="section" id="section-1">
<h3>10. 规则特例</h3>
<p>前面说明的编程习惯基本都是强制性的. 但所有优秀的规则都允许例外, 这里就是探讨这些特例.</p>
<div class="section" id="section-2">
<h4>10.1. 现有不合规范的代码</h4>
<p><strong>总述</strong></p>
<p>对于现有不符合既定编程风格的代码可以网开一面.</p>
<p><strong>说明</strong></p>
<p>当你修改使用其他风格的代码时, 为了与代码原有风格保持一致可以不使用本指南约定. 如果不放心, 可以与代码原作者或现在的负责人员商讨. 记住, <em>一致性</em> 也包括原有的一致性.</p>
</div>
<div class="section" id="windows">
<span id="windows-code"></span><h4>10.2. Windows 代码</h4>
<p><strong>总述</strong></p>
<p>Windows 程序员有自己的编程习惯, 主要源于 Windows 头文件和其它 Microsoft 代码. 我们希望任何人都可以顺利读懂你的代码, 所以针对所有平台的 C++ 编程只给出一个单独的指南.</p>
<p><strong>说明</strong></p>
<p>如果你习惯使用 Windows 编码风格, 这儿有必要重申一下某些你可能会忘记的指南:</p>
<ul class="simple">
<li>不要使用匈牙利命名法 (比如把整型变量命名成 <code class="docutils literal notranslate"><span class="pre">iNum</span></code>). 使用 Google 命名约定, 包括对源文件使用 <code class="docutils literal notranslate"><span class="pre">.cc</span></code> 扩展名.</li>
<li>Windows 定义了很多原生类型的同义词 (YuleFox 注: 这一点, 我也很反感), 如 <code class="docutils literal notranslate"><span class="pre">DWORD</span></code>, <code class="docutils literal notranslate"><span class="pre">HANDLE</span></code> 等等. 在调用 Windows API 时这是完全可以接受甚至鼓励的. 即使如此, 还是尽量使用原有的 C++ 类型, 例如使用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">TCHAR</span> <span class="pre">*</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">LPCTSTR</span></code>.</li>
<li>使用 Microsoft Visual C++ 进行编译时, 将警告级别设置为 3 或更高, 并将所有警告(warnings)当作错误(errors)处理.</li>
<li>不要使用 <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">once</span></code>; 而应该使用 Google 的头文件保护规则. 头文件保护的路径应该相对于项目根目录 (Yang.Y 注: 如 <code class="docutils literal notranslate"><span class="pre">#ifndef</span> <span class="pre">SRC_DIR_BAR_H_</span></code>, 参考 <a class="reference internal" href="contents.html#define-guard"><span class="std std-ref">#define 保护</span></a> 一节).</li>
<li>除非万不得已, 不要使用任何非标准的扩展, 如 <code class="docutils literal notranslate"><span class="pre">#pragma</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__declspec</span></code>. 使用 <code class="docutils literal notranslate"><span class="pre">__declspec(dllimport)</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__declspec(dllexport)</span></code> 是允许的, 但必须通过宏来使用, 比如 <code class="docutils literal notranslate"><span class="pre">DLLIMPORT</span></code> 和 <code class="docutils literal notranslate"><span class="pre">DLLEXPORT</span></code>, 这样其他人在分享使用这些代码时可以很容易地禁用这些扩展.</li>
</ul>
<p>然而, 在 Windows 上仍然有一些我们偶尔需要违反的规则:</p>
<ul class="simple">
<li>通常我们 <a class="reference internal" href="contents.html#multiple-inheritance"><span class="std std-ref">禁止使用多重继承</span></a>, 但在使用 COM 和 ATL/WTL 类时可以使用多重继承. 为了实现 COM 或 ATL/WTL 类/接口, 你可能不得不使用多重实现继承.</li>
<li>虽然代码中不应该使用异常, 但是在 ATL 和部分 STL（包括 Visual C++ 的 STL) 中异常被广泛使用. 使用 ATL 时, 应定义 <code class="docutils literal notranslate"><span class="pre">_ATL_NO_EXCEPTIONS</span></code> 以禁用异常. 你需要研究一下是否能够禁用 STL 的异常, 如果无法禁用, 可以启用编译器异常. (注意这只是为了编译 STL, 自己的代码里仍然不应当包含异常处理).</li>
<li>通常为了利用头文件预编译, 每个每个源文件的开头都会包含一个名为 <code class="docutils literal notranslate"><span class="pre">StdAfx.h</span></code> 或 <code class="docutils literal notranslate"><span class="pre">precompile.h</span></code> 的文件. 为了使代码方便与其他项目共享, 请避免显式包含此文件 (除了在 <code class="docutils literal notranslate"><span class="pre">precompile.cc</span></code> 中), 使用 <code class="docutils literal notranslate"><span class="pre">/FI</span></code> 编译器选项以自动包含该文件.</li>
<li>资源头文件通常命名为 <code class="docutils literal notranslate"><span class="pre">resource.h</span></code> 且只包含宏, 这一文件不需要遵守本风格指南.</li>
</ul>
</div>
</div>
<span id="document-google-cpp-styleguide/end"></span><div class="section" id="section-1">
<h3>11. 结束语</h3>
<p>运用常识和判断力, 并且 <em>保持一致</em>.</p>
<p>编辑代码时, 花点时间看看项目中的其它代码, 并熟悉其风格. 如果其它代码中 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句使用空格, 那么你也要使用. 如果其中的注释用星号 (*) 围成一个盒子状, 那么你同样要这么做.</p>
<p>风格指南的重点在于提供一个通用的编程规范, 这样大家可以把精力集中在实现内容而不是表现形式上. 我们展示的是一个总体的的风格规范, 但局部风格也很重要, 如果你在一个文件中新加的代码和原有代码风格相去甚远, 这就破坏了文件本身的整体美观, 也让打乱读者在阅读代码时的节奏, 所以要尽量避免.</p>
<p>好了, 关于编码风格写的够多了; 代码本身才更有趣. 尽情享受吧!</p>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/contents"></span><div class="section" id="objective-c">
<span id="objc-contents"></span><h2>Objective-C 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-objc-styleguide/index"></span><div class="section" id="google-objective-c-style-guide">
<h3>Google Objective-C Style Guide 中文版</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">2.36</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Mike Pinkerton</div>
<div class="line">Greg Miller</div>
<div class="line">Dave MacLachlan</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://ke.indiebros.com/">ewangke</a></div>
<div class="line"><a class="reference external" href="https://github.com/yangyubo">Yang.Y</a></div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="http://google-styleguide.googlecode.com">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="section" id="section-1">
<h4>译者的话</h4>
<div class="section" id="ewanke">
<h5>ewanke</h5>
<p>一直想翻译这个 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml">style guide</a> ，终于在周末花了7个小时的时间用vim敲出了HTML。很多术语的翻译很难，平时看的中文技术类书籍有限，对很多术语的中文译法不是很清楚，难免有不恰当之处，请读者指出并帮我改进：王轲 ”ewangke at gmail.com” 2011.03.27</p>
</div>
<div class="section" id="yang-y-1">
<h5>Yang.Y</h5>
<p>对 Objective-C 的了解有限，凭着感觉和 C/C++ 方面的理解：</p>
<ul class="simple">
<li>把指南更新到 2.36 版本</li>
<li>调整了一些术语和句子</li>
</ul>
</div>
</div>
<div class="section" id="section-2">
<h4>背景介绍</h4>
<p>Objective-C 是 C 语言的扩展，增加了动态类型和面对对象的特性。它被设计成具有易读易用的，支持复杂的面向对象设计的编程语言。它是 Mac OS X 以及 iPhone 的主要开发语言。</p>
<p>Cocoa 是 Mac OS X 上主要的应用程序框架之一。它由一组 Objective-C 类组成，为快速开发出功能齐全的 Mac OS X 应用程序提供支持。</p>
<p>苹果公司已经有一份非常全面的 Objective-C 编码指南。Google 为 C++ 也写了一份类似的编码指南。而这份 Objective-C 指南则是苹果和 Google 常规建议的最佳结合。因此，在阅读本指南之前，请确定你已经阅读过：</p>
<ul class="simple">
<li><a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/index.html">Apple’s Cocoa Coding Guidelines</a></li>
<li><a class="reference external" href="http://codinn.com/projects/google-cpp-styleguide/">Google’s Open Source C++ Style Guide</a></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">所有在 Google 的 C++ 风格指南中所禁止的事情，如未明确说明，也同样不能在Objective-C++ 中使用。</p>
</div>
<p>本文档的目的在于为所有的 Mac OS X 的代码提供编码指南及实践。许多准则是在实际的项目和小组中经过长期的演化、验证的。Google 开发的开源项目遵从本指南的要求。</p>
<p>Google 已经发布了遵守本指南开源代码，它们属于 <a class="reference external" href="http://code.google.com/p/google-toolbox-for-mac/">Google Toolbox for Mac project</a> 项目（本文以缩写 GTM 指代）。GTM 代码库中的代码通常为了可以在不同项目中复用。</p>
<p>注意，本指南不是 Objective-C 教程。我们假定读者对 Objective-C 非常熟悉。如果你刚刚接触 Objective-C 或者需要温习，请阅读 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/index.html">The Objective-C Programming Language</a> 。</p>
</div>
<div class="section" id="section-3">
<h4>例子</h4>
<p>都说一个例子顶上一千句话，我们就从一个例子开始，来感受一下编码的风格、留白以及命名等等。</p>
<p>一个头文件的例子，展示了在 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> 声明中如何进行正确的注释以及留白。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">//  Foo.h</span>
<span class="c1">//  AwesomeProject</span>
<span class="c1">//</span>
<span class="c1">//  Created by Greg Miller on 6/13/08.</span>
<span class="c1">//  Copyright 2008 Google, Inc. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#import &lt;Foundation/Foundation.h&gt;</span>

<span class="c1">// A sample class demonstrating good Objective-C style. All interfaces,</span>
<span class="c1">// categories, and protocols (read: all top-level declarations in a header)</span>
<span class="c1">// MUST be commented. Comments must also be adjacent to the object they&#39;re</span>
<span class="c1">// documenting.</span>
<span class="c1">//</span>
<span class="c1">// (no blank line between this comment and the interface)</span>
<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">bar_</span><span class="p">;</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">bam_</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Returns an autoreleased instance of Foo. See -initWithBar: for details</span>
<span class="c1">// about |bar|.</span>
<span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">fooWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Designated initializer. |bar| is a thing that represents a thing that</span>
<span class="c1">// does a thing.</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Gets and sets |bar_|.</span>
<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">bar</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span><span class="p">;</span>

<span class="c1">// Does some work with |blah| and returns YES if the work was completed</span>
<span class="c1">// successfully, and NO otherwise.</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doWorkWithBlah:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">blah</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>
</div>
<p>一个源文件的例子，展示了 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 部分如何进行正确的注释、留白。同时也包括了基于引用实现的一些重要方法，如 <code class="docutils literal notranslate"><span class="pre">getters</span></code> 、 <code class="docutils literal notranslate"><span class="pre">setters</span></code> 、 <code class="docutils literal notranslate"><span class="pre">init</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">//  Foo.m</span>
<span class="c1">//  AwesomeProject</span>
<span class="c1">//</span>
<span class="c1">//  Created by Greg Miller on 6/13/08.</span>
<span class="c1">//  Copyright 2008 Google, Inc. All rights reserved.</span>
<span class="c1">//</span>

<span class="cp">#import &quot;Foo.h&quot;</span>


<span class="k">@implementation</span> <span class="nc">Foo</span>

<span class="p">+</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">fooWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithBar</span><span class="p">:</span><span class="n">bar</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// Must always override super&#39;s designated initializer.</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">initWithBar</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">bar_</span> <span class="o">=</span> <span class="p">[</span><span class="n">bar</span> <span class="k">copy</span><span class="p">];</span>
    <span class="n">bam_</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&quot;hi %d&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="k">release</span><span class="p">];</span>
  <span class="p">[</span><span class="n">bam_</span> <span class="k">release</span><span class="p">];</span>
  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">bar</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bar_</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setBar:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">bar</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="n">autorelease</span><span class="p">];</span>
  <span class="n">bar_</span> <span class="o">=</span> <span class="p">[</span><span class="n">bar</span> <span class="k">copy</span><span class="p">];</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">doWorkWithBlah:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">blah</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></div>
</div>
<p>不要求在 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code>、<code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;end</span></code> 前后空行。如果你在 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> 声明了实例变量，则须在关括号 <code class="docutils literal notranslate"><span class="pre">}</span></code> 之后空一行。</p>
<p>除非接口和实现非常短，比如少量的私有方法或桥接类，空行方有助于可读性。</p>
</div>
</div>
<span id="document-google-objc-styleguide/spacing"></span><div class="section" id="section-1">
<h3>留白和格式</h3>
<div class="section" id="vs">
<h4>空格 vs. 制表符</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只使用空格，且一次缩进两个空格。</p>
</div>
<p>我们使用空格缩进。不要在代码中使用制表符。你应该将编辑器设置成自动将制表符替换成空格。</p>
</div>
<div class="section" id="section-2">
<h4>行宽</h4>
<p>尽量让你的代码保持在 80 列之内。</p>
<p>我们深知 Objective-C 是一门繁冗的语言，在某些情况下略超 80 列可能有助于提高可读性，但这也只能是特例而已，不能成为开脱。</p>
<p>如果阅读代码的人认为把把某行行宽保持在 80 列仍然有不失可读性，你应该按他们说的去做。</p>
<p>我们意识到这条规则是有争议的，但很多已经存在的代码坚持了本规则，我们觉得保证一致性更重要。</p>
<p>通过设置 <em>Xcode &gt; Preferences &gt; Text Editing &gt; Show page guide</em>，来使越界更容易被发现。</p>
</div>
<div class="section" id="section-3">
<h4>方法声明和定义</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<ul class="last simple">
<li>/ + 和返回类型之间须使用一个空格，参数列表中只有参数之间可以有空格。</li>
</ul>
</div>
<p>方法应该像这样：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomethingWithString:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">theString</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>星号前的空格是可选的。当写新的代码时，要与先前代码保持一致。</p>
<p>如果一行有非常多的参数，更好的方式是将每个参数单独拆成一行。如果使用多行，将每个参数前的冒号对齐。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">doSomethingWith:</span><span class="p">(</span><span class="n">GTMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">theFoo</span>
                   <span class="nf">rect:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">theRect</span>
               <span class="nf">interval:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">theInterval</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>当第一个关键字比其它的短时，保证下一行至少有 4 个空格的缩进。这样可以使关键字垂直对齐，而不是使用冒号对齐：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">short:</span><span class="p">(</span><span class="n">GTMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">theFoo</span>
    <span class="nf">longKeyword:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">theRect</span>
    <span class="nf">evenLongerKeyword:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">theInterval</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>方法调用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">方法调用应尽量保持与方法声明的格式一致。当格式的风格有多种选择时，新的代码要与已有代码保持一致。</p>
</div>
<p>调用时所有参数应该在同一行：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span> <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span> <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>或者每行一个参数，以冒号对齐：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span>
               <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span>
              <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>不要使用下面的缩进风格：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span> <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span>  <span class="c1">// some lines with &gt;1 arg</span>
              <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>

<span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span>
               <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span> <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>

<span class="p">[</span><span class="n">myObject</span> <span class="nl">doFooWith</span><span class="p">:</span><span class="n">arg1</span>
          <span class="nl">name</span><span class="p">:</span><span class="n">arg2</span>  <span class="c1">// aligning keywords instead of colons</span>
          <span class="nl">error</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
<p>方法定义与方法声明一样，当关键字的长度不足以以冒号对齐时，下一行都要以四个空格进行缩进。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">myObj</span> <span class="kt">short</span><span class="o">:</span><span class="n">arg1</span>
    <span class="nl">longKeyword</span><span class="p">:</span><span class="n">arg2</span>
    <span class="nl">evenLongerKeyword</span><span class="p">:</span><span class="n">arg3</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="public-private">
<h4><code class="docutils literal notranslate"><span class="pre">&#64;public</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">&#64;public</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 访问修饰符应该以一个空格缩进。</p>
</div>
<p>与 C++ 中的 <code class="docutils literal notranslate"><span class="pre">public,</span> <span class="pre">private</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">protected</span></code> 非常相似。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@public</span>
  <span class="p">...</span>
 <span class="k">@private</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 标签应该有独立的一行，在 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 与 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 之间需要有一个空格， <code class="docutils literal notranslate"><span class="pre">&#64;catch</span></code> 与被捕捉到的异常对象的声明之间也要有一个空格。</p>
</div>
<p>如果你决定使用 Objective-C 的异常，那么就按下面的格式。不过你最好先看看 <a class="reference internal" href="contents.html#avoid-throwing-exceptions"><span class="std std-ref">避免抛出异常</span></a> 了解下为什么不要使用异常。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@try</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">@catch</span> <span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@finally</span> <span class="p">{</span>
  <span class="n">baz</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h4>协议名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类型标识符和尖括号内的协议名之间，不能有任何空格。</p>
</div>
<p>这条规则适用于类声明、实例变量以及方法声明。例如：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">MyProtocoledClass</span> : <span class="bp">NSObject</span><span class="o">&lt;</span><span class="n">NSWindowDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span> <span class="n">delegate_</span><span class="p">;</span>
<span class="p">}</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setDelegate</span><span class="p">:(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">MyFancyDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="n">aDelegate</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<h4>块（闭包）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">块（block）适合用在 target/selector 模式下创建回调方法时，因为它使代码更易读。块中的代码应该缩进 4 个空格。</p>
</div>
<p>取决于块的长度，下列都是合理的风格准则：</p>
<ul class="simple">
<li>如果一行可以写完块，则没必要换行。</li>
<li>如果不得不换行，关括号应与块声明的第一个字符对齐。</li>
<li>块内的代码须按 4 空格缩进。</li>
<li>如果块太长，比如超过 20 行，建议把它定义成一个局部变量，然后再使用该变量。</li>
<li>如果块不带参数，<code class="docutils literal notranslate"><span class="pre">^{</span></code> 之间无须空格。如果带有参数，<code class="docutils literal notranslate"><span class="pre">^(</span></code> 之间无须空格，但 <code class="docutils literal notranslate"><span class="pre">)</span> <span class="pre">{</span></code> 之间须有一个空格。</li>
<li>块内允许按两个空格缩进，但前提是和项目的其它代码保持一致的缩进风格。</li>
</ul>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// The entire block fits on one line.</span>
<span class="p">[</span><span class="n">operation</span> <span class="nl">setCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span> <span class="p">[</span><span class="nb">self</span> <span class="n">onOperationDone</span><span class="p">];</span> <span class="p">}];</span>

<span class="c1">// The block can be put on a new line, indented four spaces, with the</span>
<span class="c1">// closing brace aligned with the first character of the line on which</span>
<span class="c1">// block was declared.</span>
<span class="p">[</span><span class="n">operation</span> <span class="nl">setCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="n">newDataAvailable</span><span class="p">];</span>
<span class="p">}];</span>

<span class="c1">// Using a block with a C API follows the same alignment and spacing</span>
<span class="c1">// rules as with Objective-C.</span>
<span class="n">dispatch_async</span><span class="p">(</span><span class="n">fileIOQueue_</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
    <span class="bp">NSString</span><span class="o">*</span> <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">sessionFilePath</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="c1">// An example where the parameter wraps and the block declaration fits</span>
<span class="c1">// on the same line. Note the spacing of |^(SessionWindow *window) {|</span>
<span class="c1">// compared to |^{| above.</span>
<span class="p">[[</span><span class="n">SessionService</span> <span class="n">sharedService</span><span class="p">]</span>
    <span class="nl">loadWindowWithCompletionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">SessionWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
          <span class="p">[</span><span class="nb">self</span> <span class="nl">windowDidLoad</span><span class="p">:</span><span class="n">window</span><span class="p">];</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="p">[</span><span class="nb">self</span> <span class="n">errorLoadingWindow</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}];</span>

<span class="c1">// An example where the parameter wraps and the block declaration does</span>
<span class="c1">// not fit on the same line as the name.</span>
<span class="p">[[</span><span class="n">SessionService</span> <span class="n">sharedService</span><span class="p">]</span>
    <span class="nl">loadWindowWithCompletionBlock</span><span class="p">:</span>
        <span class="o">^</span><span class="p">(</span><span class="n">SessionWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">window</span><span class="p">)</span> <span class="p">{</span>
              <span class="p">[</span><span class="nb">self</span> <span class="nl">windowDidLoad</span><span class="p">:</span><span class="n">window</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="p">[</span><span class="nb">self</span> <span class="n">errorLoadingWindow</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}];</span>

<span class="c1">// Large blocks can be declared out-of-line.</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">largeBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
<span class="p">[</span><span class="n">operationQueue_</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="n">largeBlock</span><span class="p">];</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/naming"></span><div class="section" id="section-1">
<h3>命名</h3>
<p>对于易维护的代码而言，命名规则非常重要。Objective-C 的方法名往往十分长，但代码块读起来就像散文一样，不需要太多的代码注释。</p>
<p>当编写纯粹的 Objective-C 代码时，我们基本遵守标准的 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Objective-C naming rules</a>，这些命名规则可能与 C++ 风格指南中的大相径庭。例如，Google 的 C++ 风格指南中推荐使用下划线分隔的单词作为变量名，而(苹果的)风格指南则使用驼峰命名法，这在 Objective-C 社区中非常普遍。</p>
<p>任何的类、类别、方法以及变量的名字中都使用全大写的 <a class="reference external" href="http://en.wikipedia.org/wiki/Initialism">首字母缩写</a>。这遵守了苹果的标准命名方式，如 URL、TIFF 以及 EXIF。</p>
<p>当编写 Objective-C++ 代码时，事情就不这么简单了。许多项目需要实现跨平台的 C++ API，并混合一些 Objective-C、Cocoa 代码，或者直接以 C++ 为后端，前端用本地 Cocoa 代码。这就导致了两种命名方式直接不统一。</p>
<p>我们的解决方案是：编码风格取决于方法/函数以哪种语言实现。如果在一个 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 语句中，就使用 Objective-C 的风格。如果实现一个 C++ 的类，就使用 C++ 的风格。这样避免了一个函数里面实例变量和局部变量命名规则混乱，严重影响可读性。</p>
<div class="section" id="section-2">
<h4>文件名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">文件名须反映出其实现了什么类 – 包括大小写。遵循你所参与项目的约定。</p>
</div>
<p>文件的扩展名应该如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="21%" />
<col width="79%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.h</span></code></td>
<td>C/C++/Objective-C 的头文件</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">.m</span></code></td>
<td>Objective-C 实现文件</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.mm</span></code></td>
<td>Objective-C++ 的实现文件</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">.cc</span></code></td>
<td>纯 C++ 的实现文件</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">.c</span></code></td>
<td>纯 C 的实现文件</td>
</tr>
</tbody>
</table>
<p>类别的文件名应该包含被扩展的类名，如：<code class="docutils literal notranslate"><span class="pre">GTMNSString+Utils.h</span></code> 或``GTMNSTextView+Autocomplete.h``。</p>
</div>
<div class="section" id="objective-c">
<h4>Objective-C++</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">源代码文件内，Objective-C++ 代码遵循你正在实现的函数/方法的风格。</p>
</div>
<p>为了最小化 Cocoa/Objective-C 与 C++ 之间命名风格的冲突，根据待实现的函数/方法选择编码风格。实现 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 语句块时，使用 Objective-C 的命名规则；如果实现一个 C++ 的类，就使用 C++ 命名规则。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: cross_platform_header.h</span>

<span class="k">class</span> <span class="n">CrossPlatformAPI</span> <span class="p">{</span>
 <span class="nl">public</span><span class="p">:</span>
  <span class="p">...</span>
  <span class="kt">int</span> <span class="n">DoSomethingPlatformSpecific</span><span class="p">();</span>  <span class="c1">// impl on each platform</span>
 <span class="nl">private</span><span class="p">:</span>
  <span class="kt">int</span> <span class="n">an_instance_var_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// file: mac_implementation.mm</span>
<span class="cp">#include</span> <span class="cpf">&quot;cross_platform_header.h&quot;</span><span class="cp"></span>

<span class="c1">// A typical Objective-C class, using Objective-C naming.</span>
<span class="k">@interface</span> <span class="nc">MyDelegate</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">int</span> <span class="n">instanceVar_</span><span class="p">;</span>
  <span class="n">CrossPlatformAPI</span><span class="o">*</span> <span class="n">backEndObject_</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">respondToSomething:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">something</span><span class="p">;</span>
<span class="k">@end</span>
<span class="k">@implementation</span> <span class="nc">MyDelegate</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">respondToSomething:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">something</span> <span class="p">{</span>
  <span class="c1">// bridge from Cocoa through our C++ backend</span>
  <span class="n">instanceVar_</span> <span class="o">=</span> <span class="n">backEndObject</span><span class="o">-&gt;</span><span class="n">DoSomethingPlatformSpecific</span><span class="p">();</span>
  <span class="bp">NSString</span><span class="o">*</span> <span class="n">tempString</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithInt</span><span class="p">:</span><span class="n">instanceVar_</span><span class="p">];</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">tempString</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">@end</span>

<span class="c1">// The platform-specific implementation of the C++ class, using</span>
<span class="c1">// C++ naming.</span>
<span class="kt">int</span> <span class="n">CrossPlatformAPI</span><span class="o">::</span><span class="n">DoSomethingPlatformSpecific</span><span class="p">()</span> <span class="p">{</span>
  <span class="bp">NSString</span><span class="o">*</span> <span class="n">temp_string</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithInt</span><span class="p">:</span><span class="n">an_instance_var_</span><span class="p">];</span>
  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">temp_string</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">temp_string</span> <span class="n">intValue</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h4>类名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词。</p>
</div>
<p><em>应用层</em> 的代码，应该尽量避免不必要的前缀。为每个类都添加相同的前缀无助于可读性。当编写的代码期望在不同应用程序间复用时，应使用前缀（如：<code class="docutils literal notranslate"><span class="pre">GTMSendMessage</span></code>）。</p>
</div>
<div class="section" id="section-4">
<h4>类别名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">类别名应该有两三个字母的前缀以表示类别是项目的一部分或者该类别是通用的。类别名应该包含它所扩展的类的名字。</p>
</div>
<p>比如我们要基于 <code class="docutils literal notranslate"><span class="pre">NSString</span></code> 创建一个用于解析的类别，我们将把类别放在一个名为 <code class="docutils literal notranslate"><span class="pre">GTMNSString+Parsing.h</span></code> 的文件中。类别本身命名为 <code class="docutils literal notranslate"><span class="pre">GTMStringParsingAdditions</span></code> （是的，我们知道类别名和文件名不一样，但是这个文件中可能存在多个不同的与解析有关类别）。类别中的方法应该以 <code class="docutils literal notranslate"><span class="pre">gtm_myCategoryMethodOnAString:</span></code> 为前缀以避免命名冲突，因为 Objective-C 只有一个名字空间。如果代码不会分享出去，也不会运行在不同的地址空间中，方法名字就不那么重要了。</p>
<p>类名与包含类别名的括号之间，应该以一个空格分隔。</p>
</div>
<div class="section" id="objective-c-1">
<h4>Objective-C 方法名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">方法名应该以小写字母开头，并混合驼峰格式。每个具名参数也应该以小写字母开头。</p>
</div>
<p>方法名应尽量读起来就像句子，这表示你应该选择与方法名连在一起读起来通顺的参数名。（例如，<code class="docutils literal notranslate"><span class="pre">convertPoint:fromRect:</span></code> 或 <code class="docutils literal notranslate"><span class="pre">replaceCharactersInRange:withString:</span></code>）。详情参见 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html">Apple’s Guide to Naming Methods</a>。</p>
<p>访问器方法应该与他们 <code class="docutils literal notranslate"><span class="pre">要获取的</span></code> 成员变量的名字一样，但不应该以get作为前缀。例如：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">getDelegate</span><span class="p">;</span>  <span class="c1">// AVOID</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">delegate</span><span class="p">;</span>     <span class="c1">// GOOD</span>
</pre></div>
</div>
<p>这仅限于 Objective-C 的方法名。C++ 的方法与函数的命名规则应该遵从 C++ 风格指南中的规则。</p>
</div>
<div class="section" id="section-5">
<h4>变量名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">变量名应该以小写字母开头，并使用驼峰格式。类的成员变量应该以下划线作为后缀。例如：<code class="docutils literal notranslate"><span class="pre">myLocalVariable</span></code>、<code class="docutils literal notranslate"><span class="pre">myInstanceVariable_</span></code>。如果不能使用 Objective-C 2.0 的 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code>，使用 KVO/KVC 绑定的成员变量可以以一个下划线作为前缀。</p>
</div>
<div class="section" id="section-6">
<h5>普通变量名</h5>
<p>对于静态的属性（<code class="docutils literal notranslate"><span class="pre">int</span></code> 或指针），不要使用匈牙利命名法。尽量为变量起一个描述性的名字。不要担心浪费列宽，因为让新的代码阅读者立即理解你的代码更重要。例如：</p>
<ul>
<li><p class="first">错误的命名：</p>
<blockquote>
<div><div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nerr</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">nCompConns</span><span class="p">;</span>
<span class="n">tix</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">someObject</span> <span class="n">object</span><span class="p">];</span>
<span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span> <span class="n">port</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">正确的命名：</p>
<blockquote>
<div><div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">numErrors</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">numCompletedConnections</span><span class="p">;</span>
<span class="n">tickets</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableArray</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="n">userInfo</span> <span class="o">=</span> <span class="p">[</span><span class="n">someObject</span> <span class="n">object</span><span class="p">];</span>
<span class="n">port</span> <span class="o">=</span> <span class="p">[</span><span class="n">network</span> <span class="n">port</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="section-7">
<h5>实例变量</h5>
<p>实例变量应该混合大小写，并以下划线作为后缀，如 <code class="docutils literal notranslate"><span class="pre">usernameTextField_</span></code>。然而，如果不能使用 Objective-C 2.0（操作系统版本的限制），并且使用了 KVO/KVC 绑定成员变量时，我们允许例外（译者注： <code class="docutils literal notranslate"><span class="pre">KVO=Key</span> <span class="pre">Value</span> <span class="pre">Observing，KVC=Key</span> <span class="pre">Value</span> <span class="pre">Coding</span></code>）。这种情况下，可以以一个下划线作为成员变量名字的前缀，这是苹果所接受的键/值命名惯例。如果可以使用 Objective-C 2.0，<code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">&#64;synthesize</span></code> 提供了遵从这一命名规则的解决方案。</p>
</div>
<div class="section" id="section-8">
<h5>常量</h5>
<p>常量名（如宏定义、枚举、静态局部变量等）应该以小写字母 <code class="docutils literal notranslate"><span class="pre">k</span></code> 开头，使用驼峰格式分隔单词，如：<code class="docutils literal notranslate"><span class="pre">kInvalidHandle，kWritePerm</span></code>。</p>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/comments"></span><div class="section" id="section-1">
<h3>注释</h3>
<p>虽然写起来很痛苦，但注释是保证代码可读性的关键。下面的规则给出了你应该什么时候、在哪进行注释。记住：尽管注释很重要，但最好的代码应该自成文档。与其给类型及变量起一个晦涩难懂的名字，再为它写注释，不如直接起一个有意义的名字。</p>
<p>当你写注释的时候，记得你是在给你的听众写，即下一个需要阅读你所写代码的贡献者。大方一点，下一个读代码的人可能就是你！</p>
<p>记住所有 C++ 风格指南里的规则在这里也同样适用，不同的之处后续会逐步指出。</p>
<div class="section" id="section-2">
<h4>文件注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个文件的开头以文件内容的简要描述起始，紧接着是作者，最后是版权声明和/或许可证样板。</p>
</div>
<div class="section" id="section-3">
<h5>版权信息及作者</h5>
<p>每个文件应该按顺序包括如下项：</p>
<ul class="simple">
<li>文件内容的简要描述</li>
<li>代码作者</li>
<li>版权信息声明（如：<code class="docutils literal notranslate"><span class="pre">Copyright</span> <span class="pre">2008</span> <span class="pre">Google</span> <span class="pre">Inc.</span></code>）</li>
<li>必要的话，加上许可证样板。为项目选择一个合适的授权样板（例如，<code class="docutils literal notranslate"><span class="pre">Apache</span> <span class="pre">2.0,</span> <span class="pre">BSD,</span> <span class="pre">LGPL,</span> <span class="pre">GPL</span></code>）。</li>
</ul>
<p>如果你对其他人的原始代码作出重大的修改，请把你自己的名字添加到作者里面。当另外一个代码贡献者对文件有问题时，他需要知道怎么联系你，这十分有用。</p>
</div>
</div>
<div class="section" id="section-4">
<h4>声明部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个接口、类别以及协议应辅以注释，以描述它的目的及与整个项目的关系。</p>
</div>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// A delegate for NSApplication to handle notifications about app</span>
<span class="c1">// launch and shutdown. Owned by the main app controller.</span>
<span class="k">@interface</span> <span class="nc">MyAppDelegate</span> : <span class="bp">NSObject</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>如果你已经在文件头部详细描述了接口，可以直接说明 “完整的描述请参见文件头部”，但是一定要有这部分注释。</p>
<p>另外，公共接口的每个方法，都应该有注释来解释它的作用、参数、返回值以及其它影响。</p>
<p>为类的线程安全性作注释，如果有的话。如果类的实例可以被多个线程访问，记得注释多线程条件下的使用规则。</p>
</div>
<div class="section" id="section-5">
<h4>实现部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal notranslate"><span class="pre">|</span></code> 来引用注释中的变量名及符号名而不是使用引号。</p>
</div>
<p>这会避免二义性，尤其是当符号是一个常用词汇，这使用语句读起来很糟糕。例如，对于符号 <code class="docutils literal notranslate"><span class="pre">count</span></code> ：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sometimes we need |count| to be less than zero.</span>
</pre></div>
</div>
<p>或者当引用已经包含引号的符号：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h4>对象所有权</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当与 Objective-C 最常规的作法不同时，尽量使指针的所有权模型尽量明确。</p>
</div>
<p>继承自 <code class="docutils literal notranslate"><span class="pre">NSObject</span></code> 的对象的实例变量指针，通常被假定是强引用关系（retained），某些情况下也可以注释为弱引用（weak）或使用 <code class="docutils literal notranslate"><span class="pre">__weak</span></code> 生命周期限定符。同样，声明的属性如果没有被类 <code class="docutils literal notranslate"><span class="pre">retained</span></code>，必须指定是弱引用或赋予 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 属性。然而，Mac 软件中标记上 <code class="docutils literal notranslate"><span class="pre">IBOutlets</span></code> 的实例变量，被认为是不会被类 <code class="docutils literal notranslate"><span class="pre">retained</span></code> 的。</p>
<p>当实例变量指向 <code class="docutils literal notranslate"><span class="pre">CoreFoundation</span></code>、C++ 或者其它非 Objective-C 对象时，不论指针是否会被 <code class="docutils literal notranslate"><span class="pre">retained</span></code>，都需要使用 <code class="docutils literal notranslate"><span class="pre">__strong</span></code> 和 <code class="docutils literal notranslate"><span class="pre">__weak</span></code> 类型修饰符明确指明。<code class="docutils literal notranslate"><span class="pre">CoreFoundation</span></code> 和其它非 Objective-C 对象指针需要显式的内存管理，即便使用了自动引用计数或垃圾回收机制。当不允许使用 <code class="docutils literal notranslate"><span class="pre">__weak</span></code> 类型修饰符（比如，使用 clang 编译时的 C++ 成员变量），应使用注释替代说明。</p>
<p>注意：Objective-C 对象中的 C++ 对象的自动封装，缺省是不允许的，参见 <a class="reference external" href="http://chanson.livejournal.com/154253.html">这里</a> 的说明。</p>
<p>强引用及弱引用声明的例子：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">MyDelegate</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">IBOutlet</span> <span class="n">NSButton</span> <span class="o">*</span><span class="n">okButton_</span><span class="p">;</span>  <span class="c1">// normal NSControl; implicitly weak on Mac only</span>

  <span class="n">AnObjcObject</span><span class="o">*</span> <span class="n">doohickey_</span><span class="p">;</span>  <span class="c1">// my doohickey</span>
  <span class="k">__weak</span> <span class="n">MyObjcParent</span> <span class="o">*</span><span class="n">parent_</span><span class="p">;</span>  <span class="c1">// so we can send msgs back (owns me)</span>

  <span class="c1">// non-NSObject pointers...</span>
  <span class="k">__strong</span> <span class="n">CWackyCPPClass</span> <span class="o">*</span><span class="n">wacky_</span><span class="p">;</span>  <span class="c1">// some cross-platform object</span>
  <span class="k">__strong</span> <span class="n">CFDictionaryRef</span> <span class="o">*</span><span class="n">dict_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">doohickey</span><span class="p">;</span>
<span class="k">@property</span><span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>（译注：强引用 - 对象被类 <code class="docutils literal notranslate"><span class="pre">retained</span></code>。弱引用 - 对象没有被类 <code class="docutils literal notranslate"><span class="pre">retained</span></code>，如委托）</p>
</div>
</div>
<span id="document-google-objc-styleguide/features"></span><div class="section" id="cocoa-objective-c">
<h3>Cocoa 和 Objective-C 特性</h3>
<div class="section" id="private">
<h4>成员变量应该是 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">成员变量应该声明为 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code></p>
</div>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="kt">id</span> <span class="n">myInstanceVariable_</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// public accessors, setter takes ownership</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">myInstanceVariable</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setMyInstanceVariable:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">theVar</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="section-1">
<h4>明确指定构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">注释并且明确指定你的类的构造函数。</p>
</div>
<p>对于需要继承你的类的人来说，明确指定构造函数十分重要。这样他们就可以只重写一个构造函数（可能是几个）来保证他们的子类的构造函数会被调用。这也有助于将来别人调试你的类时，理解初始化代码的工作流程。</p>
</div>
<div class="section" id="section-2">
<h4>重载指定构造函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当你写子类的时候，如果需要 <code class="docutils literal notranslate"><span class="pre">init…</span></code> 方法，记得重载父类的指定构造函数。</p>
</div>
<p>如果你没有重载父类的指定构造函数，你的构造函数有时可能不会被调用，这会导致非常隐秘而且难以解决的 bug。</p>
</div>
<div class="section" id="nsobject">
<h4>重载 <code class="docutils literal notranslate"><span class="pre">NSObject</span></code> 的方法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果重载了 <code class="docutils literal notranslate"><span class="pre">NSObject</span></code> 类的方法，强烈建议把它们放在 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 内的起始处，这也是常见的操作方法。</p>
</div>
<p>通常适用（但不局限）于 <code class="docutils literal notranslate"><span class="pre">init...</span></code>，<code class="docutils literal notranslate"><span class="pre">copyWithZone:</span></code>，以及 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 方法。所有 <code class="docutils literal notranslate"><span class="pre">init...</span></code> 方法应该放在一起，<code class="docutils literal notranslate"><span class="pre">copyWithZone:</span></code> 紧随其后，最后才是 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 方法。</p>
</div>
<div class="section" id="section-3">
<h4>初始化</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要在 init 方法中，将成员变量初始化为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">nil</span></code>；毫无必要。</p>
</div>
<p>刚分配的对象，默认值都是 0，除了 <code class="docutils literal notranslate"><span class="pre">isa</span></code> 指针（译者注：<code class="docutils literal notranslate"><span class="pre">NSObject</span></code> 的 <code class="docutils literal notranslate"><span class="pre">isa</span></code> 指针，用于标识对象的类型）。所以不要在初始化器里面写一堆将成员初始化为 <code class="docutils literal notranslate"><span class="pre">0</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">nil</span></code> 的代码。</p>
</div>
<div class="section" id="new">
<h4>避免 <code class="docutils literal notranslate"><span class="pre">+new</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要调用 <code class="docutils literal notranslate"><span class="pre">NSObject</span></code> 类方法 <code class="docutils literal notranslate"><span class="pre">new</span></code>，也不要在子类中重载它。使用 <code class="docutils literal notranslate"><span class="pre">alloc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">init</span></code> 方法创建并初始化对象。</p>
</div>
<p>现代的 Objective-C 代码通过调用 <code class="docutils literal notranslate"><span class="pre">alloc</span></code> 和 <code class="docutils literal notranslate"><span class="pre">init</span></code> 方法来创建并 retain 一个对象。由于类方法 <code class="docutils literal notranslate"><span class="pre">new</span></code> 很少使用，这使得有关内存分配的代码审查更困难。</p>
</div>
<div class="section" id="api">
<h4>保持公共 API 简单</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">保持类简单；避免 “厨房水槽（kitchen-sink）” 式的 API。如果一个函数压根没必要公开，就不要这么做。用私有类别保证公共头文件整洁。</p>
</div>
<p>与 C++ 不同，Objective-C 没有方法来区分公共的方法和私有的方法 – 所有的方法都是公共的（译者注：这取决于 Objective-C 运行时的方法调用的消息机制）。因此，除非客户端的代码期望使用某个方法，不要把这个方法放进公共 API 中。尽可能的避免了你你不希望被调用的方法却被调用到。这包括重载父类的方法。对于内部实现所需要的方法，在实现的文件中定义一个类别，而不是把它们放进公有的头文件中。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// GTMFoo.m</span>
<span class="cp">#import &quot;GTMFoo.h&quot;</span>

<span class="k">@interface</span> <span class="nc">GTMFoo</span> <span class="nl">(PrivateDelegateHandling)</span>
<span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">doSomethingWithDelegate</span><span class="p">;</span>  <span class="c1">// Declare private method</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">GTMFoo</span><span class="nl">(PrivateDelegateHandling)</span>
<span class="p">...</span>
<span class="o">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">doSomethingWithDelegate</span> <span class="p">{</span>
  <span class="c1">// Implement this method</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">@end</span>
</pre></div>
</div>
<p>Objective-C 2.0 以前，如果你在私有的 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> 中声明了某个方法，但在 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 中忘记定义这个方法，编译器不会抱怨（这是因为你没有在其它的类别中实现这个私有的方法）。解决文案是将方法放进指定类别的 <code class="docutils literal notranslate"><span class="pre">&#64;implemenation</span></code> 中。</p>
<p>如果你在使用 Objective-C 2.0，相反你应该使用 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_4_section_5.html">类扩展</a> 来声明你的私有类别，例如：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="nc">GMFoo</span> <span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>这么做确保如果声明的方法没有在 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 中实现，会触发一个编译器告警。</p>
<p>再次说明，“私有的” 方法其实不是私有的。你有时可能不小心重载了父类的私有方法，因而制造出很难查找的 Bug。通常，私有的方法应该有一个相当特殊的名字以防止子类无意地重载它们。</p>
<p>Objective-C 的类别可以用来将一个大的 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 拆分成更容易理解的小块，同时，类别可以为最适合的类添加新的、特定应用程序的功能。例如，当添加一个 “middle truncation” 方法时，创建一个 <code class="docutils literal notranslate"><span class="pre">NSString</span></code> 的新类别并把方法放在里面，要比创建任意的一个新类把方法放进里面好得多。</p>
</div>
<div class="section" id="import-and-include">
<h4><code class="docutils literal notranslate"><span class="pre">#import</span></code> and <code class="docutils literal notranslate"><span class="pre">#include</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">#import</span></code> Objective-C/Objective-C++ 头文件，<code class="docutils literal notranslate"><span class="pre">#include</span></code> C/C++ 头文件。</p>
</div>
<p>基于你所包括的头文件的编程语言，选择使用 <code class="docutils literal notranslate"><span class="pre">#import</span></code> 或是 <code class="docutils literal notranslate"><span class="pre">#include</span></code>：</p>
<ul class="simple">
<li>当包含一个使用 Objective-C、Objective-C++ 的头文件时，使用 <code class="docutils literal notranslate"><span class="pre">#import</span></code> 。</li>
<li>当包含一个使用标准 C、C++ 头文件时，使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code>。头文件应该使用 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml?showone=The__define_Guard#The__define_Guard">#define 保护</a>。</li>
</ul>
<p>一些 Objective-C 的头文件缺少 <code class="docutils literal notranslate"><span class="pre">#define</span></code> 保护，需要使用 <code class="docutils literal notranslate"><span class="pre">#import</span></code> 的方式包含。由于 Objective-C 的头文件只会被 Objective-C 的源文件及头文件包含，广泛地使用 <code class="docutils literal notranslate"><span class="pre">#import</span></code> 是可以的。</p>
<p>文件中没有 Objective-C 代码的标准 C、C++ 头文件，很可能会被普通的 C、C++ 包含。由于标准 C、C++ 里面没有 <code class="docutils literal notranslate"><span class="pre">#import</span></code> 的用法，这些文件将被 <code class="docutils literal notranslate"><span class="pre">#include</span></code>。在 Objective-C 源文件中使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 包含这些头文件，意味着这些头文件永远会在相同的语义下包含。</p>
<p>这条规则帮助跨平台的项目避免低级错误。某个 Mac 开发者写了一个新的 C 或 C++ 头文件，如果忘记使用 <code class="docutils literal notranslate"><span class="pre">#define</span></code> 保护，在 Mac 下使用 <code class="docutils literal notranslate"><span class="pre">#import</span></code> 这个头文件不回引起问题，但是在其它平台下使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 将可能编译失败。在所有的平台上统一使用 <code class="docutils literal notranslate"><span class="pre">#include</span></code>，意味着构造更可能全都成功或者失败，防止这些文件只能在某些平台下能够工作。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="cp">#import &lt;Cocoa/Cocoa.h&gt;</span>
<span class="cp">#include</span> <span class="cpf">&lt;CoreFoundation/CoreFoundation.h&gt;</span><span class="cp"></span>
<span class="cp">#import &quot;GTMFoo.h&quot;</span>
<span class="cp">#include</span> <span class="cpf">&quot;base/basictypes.h&quot;</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>使用根框架</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">#import</span></code> 根框架而不是单独的零散文件</p>
</div>
<p>当你试图从框架（如 Cocoa 或者 Foundation）中包含若干零散的系统头文件时，实际上包含顶层根框架的话，编译器要做的工作更少。根框架通常已经经过预编译，加载更快。另外记得使用 <code class="docutils literal notranslate"><span class="pre">#import</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">#include</span></code> 来包含 Objective-C 的框架。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="cp">#import &lt;Foundation/Foundation.h&gt;     </span><span class="c1">// good</span>

<span class="cp">#import &lt;Foundation/NSArray.h&gt;        </span><span class="c1">// avoid</span>
<span class="cp">#import &lt;Foundation/NSString.h&gt;</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="autorelease">
<h4>构建时即设定 <code class="docutils literal notranslate"><span class="pre">autorelease</span></code></h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当创建临时对象时，在同一行使用 <code class="docutils literal notranslate"><span class="pre">autolease</span></code>，而不是在同一个方法的后面语句中使用一个单独的 <code class="docutils literal notranslate"><span class="pre">release</span></code>。</p>
</div>
<p>尽管运行效率会差一点，但避免了意外删除 <code class="docutils literal notranslate"><span class="pre">release</span></code> 或者插入 <code class="docutils literal notranslate"><span class="pre">return</span></code> 语句而导致内存泄露的可能。例如：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// AVOID (unless you have a compelling performance reason)</span>
<span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
<span class="c1">// ... code here that might return ...</span>
<span class="p">[</span><span class="n">controller</span> <span class="k">release</span><span class="p">];</span>

<span class="c1">// BETTER</span>
<span class="n">MyController</span><span class="o">*</span> <span class="n">controller</span> <span class="o">=</span> <span class="p">[[[</span><span class="n">MyController</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="autorelease-retain">
<h4><code class="docutils literal notranslate"><span class="pre">autorelease</span></code> 优先 <code class="docutils literal notranslate"><span class="pre">retain</span></code> 其次</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">给对象赋值时遵守 <code class="docutils literal notranslate"><span class="pre">autorelease``之后</span> <span class="pre">``retain</span></code> 的模式。</p>
</div>
<p>当给一个变量赋值新的对象时，必须先释放掉旧的对象以避免内存泄露。有很多 “正确的” 方法可以处理这种情况。我们则选择 “<code class="docutils literal notranslate"><span class="pre">autorelease</span></code> 之后 <code class="docutils literal notranslate"><span class="pre">retain</span></code>” 的方法，因为事实证明它不容易出错。注意大的循环会填满 <code class="docutils literal notranslate"><span class="pre">autorelease</span></code> 池，并且可能效率上会差一点，但权衡之下我们认为是可以接受的。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFoo:</span><span class="p">(</span><span class="n">GMFoo</span> <span class="o">*</span><span class="p">)</span><span class="nv">aFoo</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">foo_</span> <span class="n">autorelease</span><span class="p">];</span>  <span class="c1">// Won&#39;t dealloc if |foo_| == |aFoo|</span>
  <span class="n">foo_</span> <span class="o">=</span> <span class="p">[</span><span class="n">aFoo</span> <span class="k">retain</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="init-dealloc">
<h4><code class="docutils literal notranslate"><span class="pre">init</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 内避免使用访问器</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在 <code class="docutils literal notranslate"><span class="pre">init</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 方法执行的过程中，子类可能会处在一个不一致的状态，所以这些方法中的代码应避免调用访问器。</p>
</div>
<p>子类尚未初始化，或在 <code class="docutils literal notranslate"><span class="pre">init</span></code> 和 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 方法执行时已经被销毁，会使访问器方法很可能不可靠。实际上，应在这些方法中直接对 ivals 进行赋值或释放操作。</p>
<p>正确：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bar_</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSMutableString</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>  <span class="c1">// good</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">bar_</span> <span class="k">release</span><span class="p">];</span>                           <span class="c1">// good</span>
  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
  <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableString</span> <span class="n">string</span><span class="p">];</span>  <span class="c1">// avoid</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">dealloc</span> <span class="p">{</span>
  <span class="nb">self</span><span class="p">.</span><span class="n">bar</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>                         <span class="c1">// avoid</span>
  <span class="p">[</span><span class="nb">super</span> <span class="n">dealloc</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>按声明顺序销毁实例变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 中实例变量被释放的顺序应该与它们在 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> 中声明的顺序一致，这有助于代码审查。</p>
</div>
<p>代码审查者在评审新的或者修改过的 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 实现时，需要保证每个 <code class="docutils literal notranslate"><span class="pre">retained</span></code> 的实例变量都得到了释放。</p>
<p>为了简化 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 的审查，<code class="docutils literal notranslate"><span class="pre">retained</span></code> 实例变量被释放的顺序应该与他们在 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> 中声明的顺序一致。如果 <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> 调用了其它方法释放成员变量，添加注释解释这些方法释放了哪些实例变量。</p>
</div>
<div class="section" id="setter-nsstrings">
<h4><code class="docutils literal notranslate"><span class="pre">setter</span></code> 应复制 NSStrings</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">接受 <code class="docutils literal notranslate"><span class="pre">NSString</span></code> 作为参数的 <code class="docutils literal notranslate"><span class="pre">setter</span></code>，应该总是 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 传入的字符串。</p>
</div>
<p>永远不要仅仅 <code class="docutils literal notranslate"><span class="pre">retain</span></code> 一个字符串。因为调用者很可能在你不知情的情况下修改了字符串。不要假定别人不会修改，你接受的对象是一个 <code class="docutils literal notranslate"><span class="pre">NSString</span></code> 对象而不是 <code class="docutils literal notranslate"><span class="pre">NSMutableString</span></code> 对象。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFoo:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">aFoo</span> <span class="p">{</span>
  <span class="p">[</span><span class="n">foo_</span> <span class="n">autorelease</span><span class="p">];</span>
  <span class="n">foo_</span> <span class="o">=</span> <span class="p">[</span><span class="n">aFoo</span> <span class="k">copy</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<span id="avoid-throwing-exceptions"></span><h4>避免抛异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要 <code class="docutils literal notranslate"><span class="pre">&#64;throw</span></code> Objective-C 异常，同时也要时刻准备捕获从第三方或 OS 代码中抛出的异常。</p>
</div>
<p>我们的确允许 <code class="docutils literal notranslate"><span class="pre">-fobjc-exceptions</span></code> 编译开关（主要因为我们要用到 <code class="docutils literal notranslate"><span class="pre">&#64;synchronized</span></code> ），但我们不使用 <code class="docutils literal notranslate"><span class="pre">&#64;throw</span></code>。为了合理使用第三方的代码，<code class="docutils literal notranslate"><span class="pre">&#64;try</span></code>、<code class="docutils literal notranslate"><span class="pre">&#64;catch</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;finally</span></code> 是允许的。如果你确实使用了异常，请明确注释你期望什么方法抛出异常。</p>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">NS_DURING</span></code>、<code class="docutils literal notranslate"><span class="pre">NS_HANDLER</span></code>、<code class="docutils literal notranslate"><span class="pre">NS_ENDHANDLER</span></code>、<code class="docutils literal notranslate"><span class="pre">NS_VALUERETURN</span></code> 和 <code class="docutils literal notranslate"><span class="pre">NS_VOIDRETURN</span></code> 宏，除非你写的代码需要在 Mac OS X 10.2 或之前的操作系统中运行。</p>
<p>注意：如果抛出 Objective-C 异常，Objective-C++ 代码中基于栈的对象不会被销毁。比如：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="n">exceptiontest</span> <span class="p">{</span>
 <span class="nl">public</span><span class="p">:</span>
  <span class="n">exceptiontest</span><span class="p">()</span> <span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Created&quot;</span><span class="p">);</span> <span class="p">}</span>
  <span class="o">~</span><span class="n">exceptiontest</span><span class="p">()</span> <span class="p">{</span> <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Destroyed&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">exceptiontest</span> <span class="n">a</span><span class="p">;</span>
  <span class="bp">NSException</span> <span class="o">*</span><span class="n">exception</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSException</span> <span class="nl">exceptionWithName</span><span class="p">:</span><span class="s">@&quot;foo&quot;</span>
                                                   <span class="nl">reason</span><span class="p">:</span><span class="s">@&quot;bar&quot;</span>
                                                 <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
  <span class="k">@throw</span> <span class="n">exception</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="n">GMAutoreleasePool</span> <span class="n">pool</span><span class="p">;</span>
  <span class="k">@try</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">@catch</span><span class="p">(</span><span class="bp">NSException</span> <span class="o">*</span><span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;exception raised&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>会输出：</p>
<p>注意：这里析构函数从未被调用。这主要会影响基于栈的 <code class="docutils literal notranslate"><span class="pre">smartptr</span></code>，比如 <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code>、<code class="docutils literal notranslate"><span class="pre">linked_ptr</span></code>，以及所有你可能用到的 STL 对象。因此我们不得不痛苦的说，如果必须在 Objective-C++ 中使用异常，就只用 C++ 的异常机制。永远不应该重新抛出 Objective-C 异常，也不应该在 <code class="docutils literal notranslate"><span class="pre">&#64;try</span></code>、<code class="docutils literal notranslate"><span class="pre">&#64;catch</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&#64;finally</span></code> 语句块中使用基于栈的 C++ 对象。</p>
</div>
<div class="section" id="nil">
<h4>nil 检查</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">nil</span></code> 检查只用在逻辑流程中。</p>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">nil</span></code> 的检查来检查应用程序的逻辑流程，而不是避免崩溃。Objective-C 运行时会处理向 <code class="docutils literal notranslate"><span class="pre">nil</span></code> 对象发送消息的情况。如果方法没有返回值，就没关系。如果有返回值，可能由于运行时架构、返回值类型以及 OS X 版本的不同而不同，参见 <a class="reference external" href="http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/Articles/chapter_2_section_3.html">Apple’s documentation</a> 。</p>
<p>注意，这和 C/C++ 中检查指针是否为 ‵‵NULL`` 很不一样，C/C++ 运行时不做任何检查，从而导致应用程序崩溃。因此你仍然需要保证你不会对一个 C/C++ 的空指针解引用。</p>
</div>
<div class="section" id="bool">
<h4>BOOL 若干陷阱</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将普通整形转换成 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 时要小心。不要直接将 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 值与 <code class="docutils literal notranslate"><span class="pre">YES</span></code> 进行比较。</p>
</div>
<p>Objective-C 中把 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 定义成无符号字符型，这意味着 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 类型的值远不止 <code class="docutils literal notranslate"><span class="pre">YES``(1)或</span> <span class="pre">``NO``(0)。不要直接把整形转换成</span> <span class="pre">``BOOL</span></code>。常见的错误包括将数组的大小、指针值及位运算的结果直接转换成 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> ，取决于整型结果的最后一个字节，很可能会产生一个 <code class="docutils literal notranslate"><span class="pre">NO</span></code> 值。当转换整形至 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 时，使用三目操作符来返回 <code class="docutils literal notranslate"><span class="pre">YES</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">NO</span></code>。（译者注：读者可以试一下任意的 256 的整数的转换结果，如 256、512 …）</p>
<p>你可以安全在 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code>、<code class="docutils literal notranslate"><span class="pre">_Bool</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">bool</span></code> 之间转换（参见 C++ Std 4.7.4, 4.12 以及 C99 Std 6.3.1.2）。你不能安全在 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">Boolean</span></code> 之间转换，因此请把 <code class="docutils literal notranslate"><span class="pre">Boolean</span></code> 当作一个普通整形，就像之前讨论的那样。但 Objective-C 的方法标识符中，只使用 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code>。</p>
<p>对 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 使用逻辑运算符（<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>，<code class="docutils literal notranslate"><span class="pre">||</span></code> 和 <code class="docutils literal notranslate"><span class="pre">!</span></code>）是合法的，返回值也可以安全地转换成 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code>，不需要使用三目操作符。</p>
<p>错误的用法：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isBold</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">fontTraits</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">NSFontBoldTrait</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isValid</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">stringValue</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>正确的用法：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isBold</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">([</span><span class="nb">self</span> <span class="n">fontTraits</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">NSFontBoldTrait</span><span class="p">)</span> <span class="o">?</span> <span class="nb">YES</span> <span class="o">:</span> <span class="nb">NO</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isValid</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">stringValue</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isEnabled</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[</span><span class="nb">self</span> <span class="n">isValid</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="nb">self</span> <span class="n">isBold</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同样，不要直接比较 <code class="docutils literal notranslate"><span class="pre">YES/NO</span></code> 和 <code class="docutils literal notranslate"><span class="pre">BOOL</span></code> 变量。不仅仅因为影响可读性，更重要的是结果可能与你想的不同。</p>
<p>错误的用法：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">BOOL</span> <span class="n">great</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">isGreat</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">great</span> <span class="o">==</span> <span class="nb">YES</span><span class="p">)</span>
  <span class="c1">// ...be great!</span>
</pre></div>
</div>
<p>正确的用法：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="kt">BOOL</span> <span class="n">great</span> <span class="o">=</span> <span class="p">[</span><span class="n">foo</span> <span class="n">isGreat</span><span class="p">];</span>
<span class="k">if</span> <span class="p">(</span><span class="n">great</span><span class="p">)</span>
  <span class="c1">// ...be great!</span>
</pre></div>
</div>
</div>
<div class="section" id="property">
<h4>属性（Property）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">属性（Property）通常允许使用，但需要清楚的了解：属性（Property）是 Objective-C 2.0 的特性，会限制你的代码只能跑在 iPhone 和 Mac OS X 10.5 (Leopard) 及更高版本上。点引用只允许访问声明过的 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code>。</p>
</div>
<div class="section" id="section-7">
<h5>命名</h5>
<p>属性所关联的实例变量的命名必须遵守以下划线作为后缀的规则。属性的名字应该与成员变量去掉下划线后缀的名字一模一样。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">&#64;synthesize</span></code> 指示符来正确地重命名属性。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">name_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="bp">MyClass</span>
<span class="k">@synthesize</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="section-8">
<h5>位置</h5>
<p>属性的声明必须紧靠着类接口中的实例变量语句块。属性的定义必须在 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 的类定义的最上方。他们的缩进与包含他们的 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> 以及 <code class="docutils literal notranslate"><span class="pre">&#64;implementation</span></code> 语句一样。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="k">@interface</span> <span class="bp">MyClass</span> : <span class="bp">NSObject</span> <span class="p">{</span>
 <span class="k">@private</span>
  <span class="bp">NSString</span> <span class="o">*</span><span class="n">name_</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">@property</span><span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="bp">MyClass</span>
<span class="k">@synthesize</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span>
<span class="p">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
<div class="section" id="copy-attribute">
<h5>字符串应使用 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 属性（Attribute）</h5>
<p>应总是用 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 属性（attribute）声明 <code class="docutils literal notranslate"><span class="pre">NSString</span></code> 属性（property）。</p>
<p>从逻辑上，确保遵守 <code class="docutils literal notranslate"><span class="pre">NSString</span></code> 的 <code class="docutils literal notranslate"><span class="pre">setter</span></code> 必须使用 <code class="docutils literal notranslate"><span class="pre">copy</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">retain</span></code> 的原则。</p>
</div>
<div class="section" id="section-9">
<h5>原子性</h5>
<p>一定要注意属性（property）的开销。缺省情况下，所有 <code class="docutils literal notranslate"><span class="pre">synthesize</span></code> 的 <code class="docutils literal notranslate"><span class="pre">setter</span></code> 和 <code class="docutils literal notranslate"><span class="pre">getter</span></code> 都是原子的。这会给每个 <code class="docutils literal notranslate"><span class="pre">get</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">set</span></code> 带来一定的同步开销。将属性（property）声明为 <code class="docutils literal notranslate"><span class="pre">nonatomic</span></code>，除非你需要原子性。</p>
</div>
<div class="section" id="section-10">
<h5>点引用</h5>
<p>点引用是地道的 Objective-C 2.0 风格。它被使用于简单的属性 <code class="docutils literal notranslate"><span class="pre">set</span></code>、<code class="docutils literal notranslate"><span class="pre">get</span></code> 操作，但不应该用它来调用对象的其它操作。</p>
<p>正确的做法：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="bp">NSString</span> <span class="o">*</span><span class="n">oldName</span> <span class="o">=</span> <span class="n">myObject</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="n">myObject</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;Alice&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>错误的做法：</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="bp">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSArray</span> <span class="nl">arrayWithObject</span><span class="p">:</span><span class="s">@&quot;hello&quot;</span><span class="p">]</span> <span class="k">retain</span><span class="p">];</span>

<span class="n">NSUInteger</span> <span class="n">numberOfItems</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>  <span class="c1">// not a property</span>
<span class="n">array</span><span class="p">.</span><span class="k">release</span><span class="p">;</span>                           <span class="c1">// not a property</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-11">
<h4>没有实例变量的接口</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">没有声明任何实例变量的接口，应省略空花括号。</p>
</div>
<p>正确的做法：</p>
<blockquote>
<div>&#64;interface MyClass : NSObject
// Does a lot of stuff
- (void)fooBarBam;
&#64;end</div></blockquote>
<p>错误的做法：</p>
<blockquote>
<div>&#64;interface MyClass : NSObject {
}
// Does a lot of stuff
- (void)fooBarBam;
&#64;end</div></blockquote>
</div>
<div class="section" id="synthesize">
<h4>自动 <code class="docutils literal notranslate"><span class="pre">synthesize</span></code> 实例变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只运行在 iOS 下的代码，优先考虑使用自动 <code class="docutils literal notranslate"><span class="pre">synthesize</span></code> 实例变量。</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">synthesize</span></code> 实例变量时，使用 <code class="docutils literal notranslate"><span class="pre">&#64;synthesize</span> <span class="pre">var</span> <span class="pre">=</span> <span class="pre">var_;</span></code> 防止原本想调用 <code class="docutils literal notranslate"><span class="pre">self.var</span> <span class="pre">=</span> <span class="pre">blah;</span></code> 却不慎写成了 <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">=</span> <span class="pre">blah;</span></code>。</p>
<p>不要synthesize CFType的属性 CFType应该永远使用&#64;dynamic实现指示符。 尽管CFType不能使用retain属性特性，开发者必须自己处理retain和release。很少有情况你需要仅仅对它进行赋值，因此最好显示地实现getter和setter，并作出注释说明。 列出所有的实现指示符 尽管&#64;dynamic是默认的，显示列出它以及其它的实现指示符会提高可读性，代码阅读者可以一眼就知道类的每个属性是如何实现的。</p>
<div class="highlight-objc notranslate"><div class="highlight"><pre><span></span><span class="c1">// Header file</span>
<span class="k">@interface</span> <span class="nc">Foo</span> : <span class="bp">NSObject</span>
<span class="c1">// A guy walks into a bar.</span>
<span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">bar</span><span class="p">;</span>
<span class="k">@end</span>

<span class="c1">// Implementation file</span>
<span class="k">@interface</span> <span class="nc">Foo</span> <span class="p">()</span>
<span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">retain</span><span class="p">)</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">baz</span><span class="p">;</span>
<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">Foo</span>
<span class="k">@synthesize</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">bar_</span><span class="p">;</span>
<span class="k">@synthesize</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">baz_</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-objc-styleguide/patterns"></span><div class="section" id="cocoa">
<h3>Cocoa 模式</h3>
<div class="section" id="section-1">
<h4>委托模式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">委托对象不应该被 <code class="docutils literal notranslate"><span class="pre">retain</span></code></p>
</div>
<p>实现委托模式的类应：</p>
<ol class="arabic simple">
<li>拥有一个名为 <code class="docutils literal notranslate"><span class="pre">delegate_</span></code> 的实例变量来引用委托。</li>
<li>因此，访问器方法应该命名为 <code class="docutils literal notranslate"><span class="pre">delegate</span></code> 和 <code class="docutils literal notranslate"><span class="pre">setDelegate:</span></code>。</li>
<li><code class="docutils literal notranslate"><span class="pre">delegate_</span></code> 对象不应该被 <code class="docutils literal notranslate"><span class="pre">retain</span></code>。</li>
</ol>
</div>
<div class="section" id="mvc">
<h4>模型/视图/控制器（MVC）</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">分离模型与视图。分离控制器与视图、模型。回调 API 使用 <code class="docutils literal notranslate"><span class="pre">&#64;protocol</span></code>。</p>
</div>
<ul class="simple">
<li>分离模型与视图：不要假设模型或者数据源的表示方法。保持数据源与表示层之间的接口抽象。视图不需要了解模型的逻辑（主要的规则是问问你自己，对于数据源的一个实例，有没有可能有多种不同状态的表示方法）。</li>
<li>分离控制器与模型、视图：不要把所有的 “业务逻辑” 放进跟视图有关的类中。这使代码非常难以复用。使用控制器类来处理这些代码，但保证控制器不需要了解太多表示层的逻辑。</li>
<li>使用 <code class="docutils literal notranslate"><span class="pre">&#64;protocol</span></code> 来定义回调 API，如果不是所有的方法都必须实现，使用 <code class="docutils literal notranslate"><span class="pre">&#64;optional``（特例：使用</span> <span class="pre">Objective-C</span> <span class="pre">1.0</span> <span class="pre">时，``&#64;optional</span></code> 不可用，可使用类别来定义一个 “非正规的协议”）。</li>
</ul>
</div>
</div>
</div>
</div>
<span id="document-google-python-styleguide/contents"></span><div class="section" id="python">
<span id="python-contents"></span><h2>Python 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-python-styleguide/index"></span><div class="section" id="section-1">
<h3>扉页</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Amit Patel</div>
<div class="line">Antoine Picard</div>
<div class="line">Eugene Jhong</div>
<div class="line">Jeremy Hylton</div>
<div class="line">Matt Smart</div>
<div class="line">Mike Shields</div>
</div>
<p>详细作者列表请参见英文原版的 Git 仓库.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://guoqiao.me/">guoqiao</a> v2.19</div>
<div class="line"><a class="reference external" href="https://github.com/xuxinkun">xuxinkun</a> v2.59</div>
<div class="line"><a class="reference external" href="https://github.com/captainfffsama">captainfffsama</a> v2.6</div>
<div class="line"><a class="reference external" href="https://github.com/LouYu2015">楼宇</a> 2023 年 4 月 16 日更新</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first simple">
<li><a class="reference external" href="https://github.com/google/styleguide">Google Style Guide (英文原版)</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">协议:</th><td class="field-body"><p class="first last">Python风格指南的源文件采用Apache License 2.0协议, 文本内容采用 <a class="reference external" href="https://creativecommons.org/licenses/by/3.0/">CC-BY 3.0</a> 协议.</p>
</td>
</tr>
</tbody>
</table>
</div>
<span id="document-google-python-styleguide/background"></span><div class="section" id="section-1">
<h3>背景</h3>
<p>Python 是谷歌使用的重要动态语言。这本风格指南列举了 Python 程序应采纳和避免的风格。</p>
<p>为帮助你正确地格式化代码，我们创建了 <a class="reference external" href="https://github.com/google/styleguide/blob/gh-pages/google_python_style.vim">Vim的配置文件</a> 。对于Emacs用户，保持默认设置即可。</p>
<p>许多团队采用 <a class="reference external" href="https://github.com/psf/black">Black</a> 和 <a class="reference external" href="https://github.com/google/pyink">Pyink</a> 作为自动格式化工具,以避免格式上的争论。</p>
</div>
<span id="document-google-python-styleguide/python_language_rules"></span><div class="section" id="python">
<h3>Python语言规范</h3>
<div class="section" id="lint">
<h4>Lint</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用 <a class="reference external" href="https://google.github.io/styleguide/pylintrc">pylintrc</a> 运行 pylint, 以检查你的代码.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>pylint 是在 Python 代码中寻找 bug 和格式问题的工具. 它寻找的问题就像 C 和 C++ 这些更静态的(译者注: 原文是less dynamic)语言中编译器捕捉的问题. 出于Python的动态特性, 部分警告可能有误. 不过, 误报应该不常见.</dd>
<dt>优点:</dt>
<dd>可以发现疏忽, 例如拼写错误, 使用未赋值的变量等.</dd>
<dt>缺点:</dt>
<dd>pylint 不完美. 要利用其优势, 我们有时侯需要: a) 绕过它 b) 抑制它的警告 或者 c) 改进它.</dd>
<dt>结论:</dt>
<dd><p class="first">一定要用pylint检查你的代码.</p>
<p>抑制不恰当的警告, 以免其他问题被警告淹没。你可以用行注释来抑制警告. 例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_PUT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># WSGI 接口名, 所以 pylint: disable=invalid-name</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>pylint的警告均以符号名(如 <code class="docutils literal notranslate"><span class="pre">empty-docstring</span></code> )来区分. 谷歌特有的警告以 <code class="docutils literal notranslate"><span class="pre">g-</span></code> 为前缀.</p>
<p>如果警告的符号名不够见名知意，那么请添加注释。</p>
<p>这种抑制方式的好处是, 我们可以轻易搜索并重新评判这些注释.</p>
<p>你可以用命令 <code class="docutils literal notranslate"><span class="pre">pylint</span> <span class="pre">--list-msgs</span></code> 来列出 pylint 的所有警告. 你可以用命令 <code class="docutils literal notranslate"><span class="pre">pylint</span> <span class="pre">--help-msg=invalid-name</span></code>  来查询某个警告的详情.</p>
<p>相较于旧的格式 <code class="docutils literal notranslate"><span class="pre">pylint:</span> <span class="pre">disable-msg</span></code> , 本文推荐使用 <code class="docutils literal notranslate"><span class="pre">pylint:</span> <span class="pre">disable</span></code> .</p>
<p>如果有“参数未使用”的警告，你可以在函数体开头删除无用的变量，以消除警告. 一定要用注释说明你为什么删除这些变量. 注明”未使用.”即可. 例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">viking_cafe_order</span><span class="p">(</span><span class="n">spam</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">beans</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">eggs</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">del</span> <span class="n">beans</span><span class="p">,</span> <span class="n">eggs</span>  <span class="c1"># 未被维京人使用.</span>
    <span class="k">return</span> <span class="n">spam</span> <span class="o">+</span> <span class="n">spam</span> <span class="o">+</span> <span class="n">spam</span>
</pre></div>
</div>
<p>(译者注：Viking 意为维京人.)</p>
<p class="last">其他避免这种警告的常用方法还有: 用`_`作为未使用参数的名称; 给这些参数名加上前缀 <code class="docutils literal notranslate"><span class="pre">unused_</span></code>; 或者把它们赋值给变量 <code class="docutils literal notranslate"><span class="pre">_</span></code>. 我们允许但是不再推荐这些方法. 这会导致调用者无法通过参数名来传参，也不能保证变量确实没被引用。</p>
</dd>
</dl>
</div>
<div class="section" id="section-1">
<h4>导入</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal notranslate"><span class="pre">import</span></code> 语句时, 只导入包和模块, 而不单独导入函数或者类。</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>用于方便模块间共享代码的重用机制.</dd>
<dt>优点:</dt>
<dd>命名空间的管理规范十分简单. 每个标识符的来源都用一致的方式来表示. <code class="docutils literal notranslate"><span class="pre">x.Obj</span></code> 表示 <code class="docutils literal notranslate"><span class="pre">Obj</span></code> 对象定义在模块 <code class="docutils literal notranslate"><span class="pre">x</span></code> 中.</dd>
<dt>缺点:</dt>
<dd>模块名可能有命名冲突. 有些模块名的长度过长以至于不方便.</dd>
<dt>结论:</dt>
<dd><ol class="first arabic simple">
<li>用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">x</span></code> 来导入包和模块.</li>
<li>用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">x</span> <span class="pre">import</span> <span class="pre">y</span></code> , 其中x是包前缀, y是不带前缀的模块名.</li>
<li>在以下情况使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">x</span> <span class="pre">import</span> <span class="pre">y</span> <span class="pre">as</span> <span class="pre">z</span></code>: 如果有两个模块都叫 <code class="docutils literal notranslate"><span class="pre">y</span></code>; 如果 <code class="docutils literal notranslate"><span class="pre">y</span></code> 和当前模块的某个全局名称冲突; 如果 <code class="docutils literal notranslate"><span class="pre">y</span></code> 是长度过长的名称.</li>
<li>仅当缩写 <code class="docutils literal notranslate"><span class="pre">z</span></code> 是标准缩写时才能使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">y</span> <span class="pre">as</span> <span class="pre">z</span></code>.(比如 <code class="docutils literal notranslate"><span class="pre">np</span></code> 代表 <code class="docutils literal notranslate"><span class="pre">numpy</span></code>.)</li>
</ol>
<p>例如, 可以用如下方式导入模块 <code class="docutils literal notranslate"><span class="pre">sound.effects.echo</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sound.effects</span> <span class="kn">import</span> <span class="n">echo</span>
<span class="o">...</span>
<span class="n">echo</span><span class="o">.</span><span class="n">EchoFilter</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">atten</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">导入时禁止使用相对包名. 即使模块在同一个包中, 也要使用完整包名. 这能避免无意间重复导入同一个包.</p>
</dd>
</dl>
<p>例外:</p>
<blockquote>
<div><p>这一规定的例外是：</p>
<ol class="arabic">
<li><p class="first">以下用于静态分析和类型检查的模块:</p>
<blockquote>
<div><ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块</li>
<li><code class="docutils literal notranslate"><span class="pre">collections.abc</span></code> 模块</li>
<li><code class="docutils literal notranslate"><span class="pre">typing_extensions</span></code> 模块</li>
</ol>
</div></blockquote>
</li>
<li><p class="first"><a class="reference external" href="https://six.readthedocs.io/#module-six.moves">six.moves</a> 模块中的重定向.</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="section-2">
<h4>包</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用每个模块的完整路径名来导入模块.</p>
</div>
<dl class="docutils">
<dt>优点:</dt>
<dd>避免模块名冲突, 或是因模块搜索路径与作者的想法不符而导入错误的包. 也更容易找到模块.</dd>
<dt>缺点:</dt>
<dd>部署代码更难, 因为你必须完整复刻包的层次. 在现代的部署模式下不再是问题.</dd>
<dt>结论:</dt>
<dd><p class="first">所有新的代码都应该用完整包名来导入每个模块.</p>
<p>应该像下面这样导入:</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在代码中引用完整名称 absl.flags (详细版).</span>
<span class="kn">import</span> <span class="nn">absl.flags</span>
<span class="kn">from</span> <span class="nn">doctor.who</span> <span class="kn">import</span> <span class="n">jodie</span>

<span class="n">_FOO</span> <span class="o">=</span> <span class="n">absl</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">DEFINE_string</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在代码中仅引用模块名 flags (常见情况).</span>
<span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">flags</span>
<span class="kn">from</span> <span class="nn">doctor.who</span> <span class="kn">import</span> <span class="n">jodie</span>

<span class="n">_FOO</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">DEFINE_string</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>错误: (假设当前文件和 <cite>jodie.py</cite> 都在目录 <cite>doctor/who/</cite> 下)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 没有清晰地表达作者想要导入的模块和最终导入的模块.</span>
<span class="c1"># 实际导入的模块取决于由外部环境控制的 sys.path.</span>
<span class="c1"># 那些名为 jodie 的模块中, 哪个才是作者想导入的?</span>
<span class="kn">import</span> <span class="nn">jodie</span>
</pre></div>
</div>
<p class="last">不能臆测 <cite>sys.path</cite> 包含主程序所在的目录, 即使这种环境的确存在. 因此, 代码必须认定 <cite>import jodie</cite> 表示的是名为 <cite>jodie</cite> 的第三方库或者顶层的包，而非当前目录的 <cite>jodie.py</cite>.</p>
</dd>
</dl>
</div>
<div class="section" id="section-3">
<h4>异常</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">允许使用异常, 但必须谨慎使用.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>异常是一种跳出正常的控制流, 以处理错误或其它异常情况的方法.</dd>
<dt>优点:</dt>
<dd>处理正常情况的控制流不会和错误处理代码混在一起. 在特定情况下, 它也能让控制流跳出多层调用帧. 例如, 一步跳出N多层嵌套的函数, 而不必逐层传递错误代码.</dd>
<dt>缺点:</dt>
<dd>可能导致控制流晦涩难懂. 调用库函数时容易忘记处理异常.</dd>
<dt>结论:</dt>
<dd><p class="first">使用异常时必须遵守特定要求:</p>
<ol class="last arabic">
<li><p class="first">优先使用合适的内置异常类. 比如, 用 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> 表示前置条件错误 (例如给必须为正数的参数传入了负值). 不要使用 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 语句来验证公开API的参数值. 应该用 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 来保证内部正确性, 不应该用 <code class="docutils literal notranslate"><span class="pre">assert</span></code> 来纠正参数或表示意外情况. 若要用异常来表示意外情况, 应该用 <code class="docutils literal notranslate"><span class="pre">raise</span></code>. 例如:</p>
<blockquote>
<div><p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">connect_to_next_port</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;连接到下一个可用的端口.</span>

<span class="sd">    Args:</span>
<span class="sd">    minimum: 一个大于等于 1024 的端口号.</span>

<span class="sd">    Returns:</span>
<span class="sd">    新的最小端口.</span>

<span class="sd">    Raises:</span>
<span class="sd">    ConnectionError: 没有可用的端口.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">minimum</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">:</span>
        <span class="c1"># 注意这里抛出 ValueError 的情况没有在文档里说明，因为 API 的</span>
        <span class="c1"># 错误用法应该是未定义行为.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;最小端口号至少为 1024，不能是 </span><span class="si">{minimum}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_next_open_port</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">port</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ConnectionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;未能通过 </span><span class="si">{minimum}</span><span class="s1"> 或更高的端口号连接到服务.&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">port</span> <span class="o">&gt;=</span> <span class="n">minimum</span><span class="p">,</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;意外的端口号 </span><span class="si">{port}</span><span class="s1">, 端口号不应小于 </span><span class="si">{minimum}</span><span class="s1">.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">port</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">connect_to_next_port</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimum</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;连接到下一个可用的端口.</span>

<span class="sd">    Args:</span>
<span class="sd">    minimum: 一个大于等于 1024 的端口号.</span>

<span class="sd">    Returns:</span>
<span class="sd">    新的最小端口.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">minimum</span> <span class="o">&gt;=</span> <span class="mi">1024</span><span class="p">,</span> <span class="s1">&#39;最小端口号至少为 1024.&#39;</span>
    <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_next_open_port</span><span class="p">(</span><span class="n">minimum</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">port</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">port</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">模块或包可以定义自己的异常类型, 这些类必须继承已有的异常类. 异常类型名应该以 <code class="docutils literal notranslate"><span class="pre">Error</span></code> 为后缀, 并且不应该有重复 (例如 <code class="docutils literal notranslate"><span class="pre">foo.FooError</span></code>).</p>
</li>
<li><p class="first">永远不要使用 <code class="docutils literal notranslate"><span class="pre">except:</span></code> 语句来捕获所有异常, 也不要捕获 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">StandardError</span></code> , 除非你想:</p>
<blockquote>
<div><ol class="arabic simple">
<li>重新抛出异常.</li>
<li>在程序中创造一个隔离点, 记录并抑制异常, 让异常不再继续传播. 这种写法可以用在线程的最外层, 以避免程序崩溃.</li>
</ol>
<p>如果你使用这种写法, Python 将非常宽容. <code class="docutils literal notranslate"><span class="pre">except:</span></code> 真的会捕获任何错误, 包括拼写错误的符号名、 <code class="docutils literal notranslate"><span class="pre">sys.exit()</span></code> 调用、 <code class="docutils literal notranslate"><span class="pre">Ctrl+C</span></code> 中断、单元测试错误和各种你不想捕获的错误.</p>
</div></blockquote>
</li>
<li><p class="first">最小化 <code class="docutils literal notranslate"><span class="pre">try/except</span></code> 代码块中的代码量. <code class="docutils literal notranslate"><span class="pre">try</span></code> 的范围越大, 就越容易把你没想到的那些能抛出异常的代码囊括在内. 这样的话, <code class="docutils literal notranslate"><span class="pre">try/except</span></code> 代码块就掩盖了真正的错误.</p>
</li>
<li><p class="first">用 <code class="docutils literal notranslate"><span class="pre">finally</span></code> 表示无论异常与否都应执行的代码. 这种写法常用于清理资源, 例如关闭文件.</p>
</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="section-4">
<h4>全局变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">避免全局变量.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>在程序运行时可以发生变化的模块级变量和类属性.</dd>
<dt>优点:</dt>
<dd>偶尔有用.</dd>
<dt>缺点:</dt>
<dd><ol class="first last arabic simple">
<li>破坏封装: 这种设计会阻碍一些有用的目标. 例如, 如果用全局变量来管理数据库连接, 那就难以同时连接两个数据库 (比如为了在数据迁移时比较差异). 全局注册表也有类似的问题.</li>
<li>导入模块时可能改变模块的行为, 因为首次导入模块时会对全局变量赋值.</li>
</ol>
</dd>
<dt>结论:</dt>
<dd><p class="first">避免使用全局变量.</p>
<p>在特殊情况下需要用到全局变量时, 应将全局变量声明为模块级变量或者类属性, 并在名称前加 <cite>_</cite> 以示为内部状态. 如需从外部访问全局变量, 必须通过公有函数或类方法实现. 详见 <a class="reference external" href="https://google.github.io/styleguide/pyguide.html#s3.16-naming">命名规则</a> 章节. 请用注释或文档链接解释这些全局变量的设计思想.</p>
<p class="last">我们允许并鼓励使用模块级常量,例如 <code class="docutils literal notranslate"><span class="pre">_MAX_HOLY_HANDGRENADE_COUNT</span> <span class="pre">=</span> <span class="pre">3</span></code> 表示内部常量, <code class="docutils literal notranslate"><span class="pre">SIR_LANCELOTS_FAVORITE_COLOR</span> <span class="pre">=</span> <span class="pre">&quot;blue&quot;</span></code> 表示公开API的常量. 注意常量名必须全部大写, 用下划线分隔单词. 详见 <a class="reference external" href="https://google.github.io/styleguide/pyguide.html#s3.16-naming">命名规则</a> 章节.</p>
</dd>
</dl>
</div>
<div class="section" id="section-5">
<h4>嵌套/局部/内部类和函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以用局部类和局部函数来捕获局部变量. 可以用内部类.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>可以在方法、函数和类中定义内部类. 可以在方法和函数中定义嵌套函数. 嵌套函数可以只读访问外层作用域中的变量. (译者注:即内嵌函数可以读外部函数中定义的变量,但是无法改写,除非使用 <cite>nonlocal</cite>)</dd>
<dt>优点:</dt>
<dd>方便定义作用域有限的工具类和函数. 便于实现 <a class="reference external" href="https://en.wikipedia.org/wiki/Abstract_data_type">抽象数据类型</a>. 常用于实现装饰器.</dd>
<dt>缺点:</dt>
<dd>无法直接测试嵌套的函数和类. 嵌套函数和嵌套类会让外层函数的代码膨胀, 可读性变差.</dd>
<dt>结论:</dt>
<dd>可以谨慎使用. 尽量避免使用嵌套函数和嵌套类, 除非需要捕获 <code class="docutils literal notranslate"><span class="pre">self</span></code> 和 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 以外的局部变量. 不要仅仅为了隐藏一个函数而使用嵌套函数. 应将需要隐藏的函数定义在模块级别, 并给名称加上 <code class="docutils literal notranslate"><span class="pre">_</span></code> 前缀, 以便在测试代码中调用此函数.</dd>
</dl>
</div>
<div class="section" id="section-6">
<h4>推导式和生成式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于简单情况.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>列表、字典和集合的推导式和生成式可以用于简洁高效地创建容器和迭代器, 而无需借助循环、 <code class="docutils literal notranslate"><span class="pre">map()</span></code>、 <code class="docutils literal notranslate"><span class="pre">filter()</span></code>, 或者 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> . (译者注: 元组是没有推导式的, <code class="docutils literal notranslate"><span class="pre">()</span></code> 内加类似推导式的句式返回的是个生成器)</dd>
<dt>优点:</dt>
<dd>相较于其它创建字段、列表和集合的方法, 简单的列表推导式更加清晰和简洁. 生成器表达式十分高效, 因为无需创建整个列表.</dd>
<dt>缺点:</dt>
<dd>复杂的列表推导式和生成式难以理解.</dd>
<dt>结论:</dt>
<dd><p class="first">可以用于简单情况. 以下每个部分不应超过一行: 映射表达式、for语句和过滤表达式. 禁止多重for语句和多层过滤. 情况复杂时, 应该用循环.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapping_expr</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span> <span class="k">if</span> <span class="n">filter_expr</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iterable</span>
          <span class="k">if</span> <span class="n">a_long_filter_expression</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">complicated_transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

<span class="n">descriptive_name</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">transform</span><span class="p">({</span><span class="s1">&#39;key&#39;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">value</span><span class="p">},</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">generate_iterable</span><span class="p">(</span><span class="n">some_input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">complicated_condition_is_met</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">complicated_transform</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">long_generator_function</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

<span class="n">squares_generator</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

<span class="n">unique_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">user</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">users</span> <span class="k">if</span> <span class="n">user</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

<span class="n">eat</span><span class="p">(</span><span class="n">jelly_bean</span> <span class="k">for</span> <span class="n">jelly_bean</span> <span class="ow">in</span> <span class="n">jelly_beans</span>
    <span class="k">if</span> <span class="n">jelly_bean</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;black&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">complicated_transform</span><span class="p">(</span>
              <span class="n">x</span><span class="p">,</span> <span class="n">some_argument</span><span class="o">=</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">]</span>

<span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span>
        <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="section-7">
<h4>默认迭代器和操作符</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">只要可行, 就用列表、字典和文件等类型的默认迭代器和操作符.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>字典和列表等容器类型具有默认的迭代器和关系运算符 ( <code class="docutils literal notranslate"><span class="pre">in</span></code> 和 <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> ).</dd>
<dt>优点:</dt>
<dd>默认迭代器和操作符简单高效. 这种写法可以直白地表达运算, 无需调用额外的函数. 使用默认操作符的函数是泛型函数, 可以用于任何支持该操作符的类型.</dd>
<dt>缺点:</dt>
<dd>你不能通过方法名来辨别对象的类型 (除非变量有类型注解). 不过这也是优点.</dd>
<dt>结论:</dt>
<dd><p class="first">只要是支持的类型 (例如列表、字典和文件), 就使用默认迭代器和操作符. 内置类型也定义了一些返回迭代器的方法. 优先使用返回迭代器的方法, 而非返回列表的方法, 不过注意使用迭代器时不能修改容器.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adict</span><span class="p">:</span> <span class="o">...</span>
<span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">alist</span><span class="p">:</span> <span class="o">...</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">afile</span><span class="p">:</span> <span class="o">...</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
<p>错误:</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">adict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span> <span class="o">...</span>
<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">afile</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="section-8">
<h4>生成器</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">按需使用生成器.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>生成器函数会返回一个迭代器. 每当函数执行 <code class="docutils literal notranslate"><span class="pre">yield</span></code> 语句时, 迭代器就生成一个值. 随后, 生成器的运行状态将暂停, 直到需要下一个值的时候.</dd>
<dt>优点:</dt>
<dd>代码简单, 因为生成器可以保存局部变量和控制流. 相较于直接创建整个列表的函数, 生成器使用的内存更少.</dd>
<dt>缺点:</dt>
<dd>必须等到生成结束或者生成器本身被内存回收的时候, 生成器的局部变量才能被内存回收.</dd>
<dt>结论:</dt>
<dd><p class="first">可以使用. 生成器的文档字符串中应使用”Yields:”而不是”Returns:”.</p>
<p>(译者注: 参看 <a class="reference internal" href="contents.html#comments"><span class="std std-ref">注释</span></a> )</p>
<p>如果生成器占用了大量资源, 一定要强制清理资源.</p>
<p class="last">一种清理资源的好方法是用上下文管理器包裹生成器 <a class="reference external" href="https://peps.python.org/pep-0533/">PEP-0533</a>.</p>
</dd>
</dl>
</div>
<div class="section" id="lambda">
<h4>Lambda函数</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于单行函数. 建议用生成式替代 <code class="docutils literal notranslate"><span class="pre">map()/filter()</span></code> 与 <code class="docutils literal notranslate"><span class="pre">lambda</span></code> 的组合.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>lambda 定义匿名函数, 不像语句那样定义具名函数.</dd>
<dt>优点:</dt>
<dd>方便.</dd>
<dt>缺点:</dt>
<dd>比局部函数更难理解和调试. 缺失函数名会导致调用栈晦涩难懂. 由于 lambda 函数只能包含一个表达式, 因此其表达能力有限.</dd>
<dt>结论:</dt>
<dd><p class="first">适用于单行函数. 如果函数体超过60-80个字符, 最好还是定义为常规的嵌套函数.</p>
<p class="last">对于乘法等常见操作, 应该用 <code class="docutils literal notranslate"><span class="pre">operator</span></code> 模块中的函数代替lambda函数. 例如, 推荐用 <code class="docutils literal notranslate"><span class="pre">operator.mul</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x,</span> <span class="pre">y:</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">y</span></code> .</p>
</dd>
</dl>
</div>
<div class="section" id="section-9">
<h4>条件表达式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">适用于简单情况.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>条件表达式(又名三元运算符)是if语句的缩略版. 例如: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">if</span> <span class="pre">cond</span> <span class="pre">else</span> <span class="pre">2</span></code> .</dd>
<dt>优点:</dt>
<dd>比if语句更简短, 更方便.</dd>
<dt>缺点:</dt>
<dd>有时比if语句更难理解. 如果表达式很长，就难以一眼望到条件.</dd>
<dt>结论:</dt>
<dd><p class="first">适用于简单情况. 以下每部分均不得长于一行: 真值分支, if 部分和 else 部分. 情况复杂时应使用完整的if语句.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">one_line</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;no&#39;</span>
<span class="n">slightly_split</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;yes&#39;</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                  <span class="k">else</span> <span class="s1">&#39;no, nein, nyet&#39;</span><span class="p">)</span>
<span class="n">the_longest_ternary_style_that_can_be_done</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s1">&#39;yes, true, affirmative, confirmed, correct&#39;</span>
    <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">else</span> <span class="s1">&#39;no, false, negative, nay&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bad_line_breaking</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;yes&#39;</span> <span class="k">if</span> <span class="n">predicate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">else</span>
                     <span class="s1">&#39;no&#39;</span><span class="p">)</span>  <span class="c1"># 换行位置错误</span>
<span class="n">portion_too_long</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;yes&#39;</span>
                    <span class="k">if</span> <span class="n">some_long_module</span><span class="o">.</span><span class="n">some_long_predicate_function</span><span class="p">(</span>
                        <span class="n">really_long_variable_name</span><span class="p">)</span>
                    <span class="k">else</span> <span class="s1">&#39;no, false, negative, nay&#39;</span><span class="p">)</span>   <span class="c1"># 过长</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="section-10">
<h4>默认参数值</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">大部分情况下允许.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>你可以为参数列表的最后几个参数赋予默认值, 例如, <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">foo(a,</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">0):</span></code> . 如果调用foo时只带一个参数, 则b为0. 如果调用时带两个参数, 则b的值等于第二个参数.</dd>
<dt>优点:</dt>
<dd>很多时候, 你需要一个拥有大量默认值的函数, 并且偶尔需要覆盖这些默认值. 通过默认参数值可以轻松实现这种功能, 不需要为了覆盖默认值而编写大量额外的函数. 同时, Python不支持重载方法和函数, 而默认参数的写法可以轻松”仿造”重载行为.</dd>
<dt>缺点:</dt>
<dd>默认参数在模块被导入时求值且只计算一次. 如果值是列表和字典等可变类型, 就可能引发问题. 如果函数修改了这个值(例如往列表内添加元素), 默认值就变化了.</dd>
<dt>结论:</dt>
<dd><p class="first">可以使用, 不过有如下注意事项:</p>
<p>函数和方法的默认值不能是可变对象.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Sequence</span> <span class="o">=</span> <span class="p">()):</span>  <span class="c1"># 允许空元组，因为元组是不可变的</span>
</pre></div>
</div>
<p>错误:</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">flags</span>
<span class="n">_FOO</span> <span class="o">=</span> <span class="n">flags</span><span class="o">.</span><span class="n">DEFINE_string</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="p">[]):</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()):</span>  <span class="c1"># 确定要用模块的导入时间吗???</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">_FOO</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>  <span class="c1"># 此时还没有解析 sys.argv...</span>
    <span class="o">...</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Mapping</span> <span class="o">=</span> <span class="p">{}):</span>  <span class="c1"># 可能会赋值给未经过静态检查的代码</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="properties">
<h4>特性 (properties)</h4>
<p>(译者注:参照fluent python.这里将 “property” 译为”特性”,而 “attribute” 译为属性. python中数据的属性和处理数据的方法统称属性”(arrtibute)”, 而在不改变类接口的前提下用来修改数据属性的存取方法我们称为”特性(property)”.)</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以用特性来读取或设置涉及简单计算、逻辑的属性. 特性的实现必须和属性 (attribute) 一样满足这些通用要求: 轻量、直白、明确.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>把读取、设置属性的函数包装为常规属性操作的写法.</dd>
<dt>优点:</dt>
<dd><ol class="first last arabic simple">
<li>可以直接实现属性的访问、赋值接口, 而不必添加获取器 (getter) 和设置器 (setter).</li>
<li>可以让属性变为只读.</li>
<li>可以实现惰性求值.</li>
<li>类的内部实现发生变化时, 可以用这种方法让用户看到的公开接口保持不变.</li>
</ol>
</dd>
<dt>缺点:</dt>
<dd><ol class="first last arabic simple">
<li>可能掩盖副作用, 类似运算符重载 (operator overload).</li>
<li>子类继承时可能产生困惑.</li>
</ol>
</dd>
<dt>结论:</dt>
<dd><p class="first">允许使用特性. 但是, 和运算符重载一样, 只能在必要时使用, 并且要模仿常规属性的存取特点. 若无法满足要求, 请参考 <a class="reference internal" href="contents.html#getter-setter"><span class="std std-ref">设置器和写入器</span></a> 的规则.</p>
<p>举个例子, 一个特性不能仅仅用于获取和设置一个内部属性: 因为不涉及计算, 没有必要用特性 (应该把该属性设为公有). 而用特性来限制属性的访问或者计算 <strong>简单</strong> 的衍生值则是正确的: 这种逻辑简单明了.</p>
<p>应该用 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/pyguide.html#Function_and_Method_Decorators">装饰器 (decorator)</a> 来创建特性. 自行实现的特性装饰器属于威力过大的功能.</p>
<p class="last">特性的继承机制难以理解. 不要用特性实现子类能覆写 (override) 或扩展的计算功能.</p>
</dd>
</dl>
</div>
<div class="section" id="true-false">
<h4>True/False的求值</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能使用”隐式”假值.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>Python在计算布尔值时会把一些值视为 <code class="docutils literal notranslate"><span class="pre">False</span></code>. 简单来说, 所有的”空”值都是假值. 因此, <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">None,</span> <span class="pre">[],</span> <span class="pre">{},</span> <span class="pre">&quot;&quot;</span></code> 作为布尔值使用时相当于 <code class="docutils literal notranslate"><span class="pre">False</span></code>.</dd>
<dt>优点:</dt>
<dd>Python布尔值可以让条件语句更易懂, 减少失误. 多数时候运行速度也更快.</dd>
<dt>缺点:</dt>
<dd>对C/C++开发人员来说, 可能看起来有点怪.</dd>
<dt>结论:</dt>
<dd><p class="first">尽可能使用”隐式”假值, 例如: 使用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">foo:</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">foo</span> <span class="pre">!=</span> <span class="pre">[]:</span></code> . 不过还是有一些注意事项需要你铭记在心:</p>
<ol class="last arabic">
<li><p class="first">一定要用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">foo</span> <span class="pre">is</span> <span class="pre">None:</span></code> (或者 <code class="docutils literal notranslate"><span class="pre">is</span> <span class="pre">not</span> <span class="pre">None</span></code>) 来检测 <code class="docutils literal notranslate"><span class="pre">None</span></code> 值. 例如, 如果你要检查某个默认值为 <code class="docutils literal notranslate"><span class="pre">None</span></code> 的参数有没有被调用者覆盖, 覆盖的值在布尔语义下可能也是假值!</p>
</li>
<li><p class="first">永远不要用 <code class="docutils literal notranslate"><span class="pre">==</span></code> 比较一个布尔值是否等于 <code class="docutils literal notranslate"><span class="pre">False</span></code>. 应该用 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">x:</span></code> 代替. 如果你需要区分 <code class="docutils literal notranslate"><span class="pre">False</span></code> 和 <code class="docutils literal notranslate"><span class="pre">None</span></code>, 你应该用复合表达式, 例如 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">x</span> <span class="pre">and</span> <span class="pre">x</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">None:</span></code>.</p>
</li>
<li><p class="first">多利用空序列(字符串, 列表, 元组)是假值的特性. 因此 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">seq:</span></code>  比 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">len(seq):</span></code> 更好, <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">seq:</span></code> 比 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">len(seq):</span></code> 更好.</p>
</li>
<li><p class="first">处理整数时, 使用隐式false可能会得不偿失(例如不小心将 <code class="docutils literal notranslate"><span class="pre">None</span></code> 当做0来处理). 你可以显式比较整型值与0的关系 (<code class="docutils literal notranslate"><span class="pre">len()</span></code> 的返回值例外).</p>
<blockquote>
<div><p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="ow">not</span> <span class="n">users</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;无用户&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">handle_multiple_of_ten</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">users</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span> <span class="s1">&#39;无用户&#39;</span>

<span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">handle_multiple_of_ten</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="ow">or</span> <span class="p">[]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">注意, ‘0’(字符串, 不是整数)作为布尔值时等于 <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</li>
<li><p class="first">注意, Numpy 数组转换为布尔值时可能抛出异常. 因此建议用 <cite>.size</cite> 属性检查 <code class="docutils literal notranslate"><span class="pre">np.array</span></code> 是否为空 (例如 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">not</span> <span class="pre">users.size</span></code>).</p>
</li>
</ol>
</dd>
</dl>
</div>
<div class="section" id="lexical-scoping">
<h4>词法作用域(Lexical Scoping, 又名静态作用域)</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以使用.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first">嵌套的Python函数可以引用外层函数中定义的变量, 但是不能对这些变量赋值. 变量的绑定分析基于词法作用域, 也就是基于静态的程序文本. 任何在代码块内给标识符赋值的操作, 都会让Python将该标识符的所有引用变成局部变量, 即使读取语句写在赋值语句之前. 如果有全局声明, 该标识符会被视为全局变量.</p>
<p>一个使用这个特性的例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_adder</span><span class="p">(</span><span class="n">summand1</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;返回一个函数，该函数会给一个数字加上指定的值.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">adder</span><span class="p">(</span><span class="n">summand2</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">summand1</span> <span class="o">+</span> <span class="n">summand2</span>

    <span class="k">return</span> <span class="n">adder</span>
</pre></div>
</div>
<p class="last">(译者注: 这个函数的用法大概是: <code class="docutils literal notranslate"><span class="pre">fn</span> <span class="pre">=</span> <span class="pre">get_adder(1.2);</span> <span class="pre">sum</span> <span class="pre">=</span> <span class="pre">fn(3.4)</span></code>, 结果是 <code class="docutils literal notranslate"><span class="pre">sum</span> <span class="pre">==</span> <span class="pre">4.6</span></code>.)</p>
</dd>
<dt>优点:</dt>
<dd>通常会产生更清晰、更优雅的代码. 尤其是让熟练使用Lisp和Scheme(还有Haskell, ML等)的程序员感到舒适.</dd>
<dt>缺点:</dt>
<dd><p class="first">可能引发让人困惑的bug, 例如下面这个依据 <a class="reference external" href="http://www.python.org/dev/peps/pep-0227/">PEP-0227</a> 改编的例子:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">4</span>
<span class="k">def</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="c1"># ...</span>
    <span class="c1"># 很多其他代码</span>
    <span class="c1"># ...</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>  <span class="c1"># 啊哈, i 是 Foo 的局部变量, 所以 bar 得到的是这个变量</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">bar</span><span class="p">()</span>
</pre></div>
</div>
<p>因此 <code class="docutils literal notranslate"><span class="pre">foo([1,</span> <span class="pre">2,</span> <span class="pre">3])</span></code> 会输出 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">3</span></code> , 而非 <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">3</span> <span class="pre">4</span></code> .</p>
<p class="last">(译者注: x是一个列表, for循环其实是将x中的值依次赋给i.这样对i的赋值就隐式的发生了, 整个foo函数体中的i都会被当做局部变量, 包括bar()中的那个. 这一点与C++之类的语言还是有很大差别的.)</p>
</dd>
<dt>结论:</dt>
<dd>可以使用.</dd>
</dl>
</div>
<div class="section" id="section-11">
<h4>函数与方法装饰器</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">仅在有显著优势时, 审慎地使用装饰器. 避免使用 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code>. 减少使用 <code class="docutils literal notranslate"><span class="pre">classmethod</span></code>.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first"><a class="reference external" href="https://docs.python.org/release/2.4.3/whatsnew/node6.html">装饰器(也就是&#64;标记)作用在函数和方法上</a>. 常见的装饰器是 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code>, 用于把方法转化为动态求值的属性. 不过, 也可以用装饰器语法自行定义装饰器. 具体地说, 若有一个函数 <code class="docutils literal notranslate"><span class="pre">my_decorator</span></code> , 下面两段代码是等效的:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
   <span class="nd">@my_decorator</span>
   <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
       <span class="c1"># 函数体 ...</span>
</pre></div>
</div>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">C</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 函数体 ...</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">my_decorator</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>优点:</dt>
<dd>优雅地实现函数的变换; 这种变换可用于减少重复的代码, 或帮助检查不变式 (invariant).</dd>
<dt>缺点:</dt>
<dd>装饰器可以在函数的参数和返回值上执行任何操作, 这可能产生意外且隐蔽的效果. 而且, 装饰是在定义对象时执行. 模块级对象(类、模块级函数)的装饰器在导入模块时执行. 当装饰器代码出错时, 很难恢复正常控制流.</dd>
<dt>结论:</dt>
<dd><p class="first">仅在有显著优势时, 审慎地使用装饰器. 装饰器的导入和命名规则与函数相同. 装饰器的pydoc注释应清楚地说明该函数是装饰器. 请为装饰器编写单元测试.</p>
<p>避免装饰器自身对外界的依赖(即不要依赖于文件, 套接字, 数据库连接等), 因为执行装饰器时(即导入模块时. <code class="docutils literal notranslate"><span class="pre">pydoc</span></code> 和其他工具也会导入你的模块) 可能无法连接到这些环境. 只要装饰器的调用参数正确, 装饰器应该 (尽最大努力) 保证运行成功.</p>
<p>装饰器是一种特殊形式的”顶级代码”. 参见关于 <span class="xref std std-ref">Main</span> 的章节.</p>
<p>不得使用 <code class="docutils literal notranslate"><span class="pre">staticmethod</span></code>, 除非为了兼容老代码库的 API 不得已而为之. 应该把静态方法改写为模块级函数.</p>
<p class="last">仅在以下情况可以使用 <code class="docutils literal notranslate"><span class="pre">classmethod</span></code>: 实现具名构造函数(named constructor); 在类方法中修改必要的全局状态 (例如进程内共享的缓存等)。</p>
</dd>
</dl>
</div>
<div class="section" id="section-12">
<h4>线程</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要依赖内置类型的原子性.</p>
</div>
<p>虽然Python的内置类型表面上有原子性, 但是在特定情形下可能打破原子性(例如用Python实现 <code class="docutils literal notranslate"><span class="pre">__hash__</span></code> 或 <code class="docutils literal notranslate"><span class="pre">__eq__</span></code> 的情况下). 因此它们的原子性不可靠. 你也不能臆测赋值是原子性的(因为赋值的原子性依赖于字典的原子性).</p>
<p>选择线程间的数据传递方式时, 应优先考虑 <code class="docutils literal notranslate"><span class="pre">queue</span></code> 模块的 <code class="docutils literal notranslate"><span class="pre">Queue</span></code> 数据类型. 如果不适用, 则使用 <code class="docutils literal notranslate"><span class="pre">threading</span></code> 模块及其提供的锁原语(locking primitives). 如果可行, 应该用条件变量和 <code class="docutils literal notranslate"><span class="pre">threading.Condition</span></code> 替代低级的锁.</p>
</div>
<div class="section" id="section-13">
<h4>威力过大的特性</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">避开这些特性.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>Python是一种异常灵活的语言, 有大量花哨的特性, 诸如自定义元类(metaclasses), 读取字节码(bytecode), 及时编译(on-the-fly compilation), 动态继承, 对象父类重定义(object reparenting), 导入(import)技巧, 反射(例如 <code class="docutils literal notranslate"><span class="pre">getattr()</span></code>), 系统内部状态的修改, <code class="docutils literal notranslate"><span class="pre">__del__</span></code> 实现的自定义清理等等.</dd>
<dt>优点:</dt>
<dd>强大的语言特性让代码紧凑.</dd>
<dt>缺点:</dt>
<dd>这些很”酷”的特性十分诱人, 但多数情况下没必要使用. 包含奇技淫巧的代码难以阅读、理解和调试. 一开始可能还好(对原作者而言), 但以后回顾代码时, 这种代码通常比那些长而直白的代码更加深奥.</dd>
<dt>结论:</dt>
<dd><p class="first">避开这些特性.</p>
<p class="last">可以使用那些在内部利用了这些特性的标准模块和类, 比如 <code class="docutils literal notranslate"><span class="pre">abc.ABCMeta</span></code>, <code class="docutils literal notranslate"><span class="pre">dataclasses</span></code> 和 <code class="docutils literal notranslate"><span class="pre">enum</span></code>.</p>
</dd>
</dl>
</div>
<div class="section" id="python-from-future-imports">
<h4>现代python: from __future__ imports</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以通过导入 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 包, 在较老的运行时上启用新语法, 并且只在特定文件上生效.</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd>通过使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span></code> 并启用现代的语法, 可以提前使用未来的 Python 特性.</dd>
<dt>优点:</dt>
<dd>实践表明, 该功能可以让版本升级过程更稳定, 因为可以逐步修改各个文件, 并用这样的兼容性声明来防止退化 (regression). 现代的代码便于维护, 因为不容易积累那些阻碍运行时升级的技术债.</dd>
<dt>缺点:</dt>
<dd>此类代码无法在过老的运行时上运行, 过老的版本可能没有实现所需的 <code class="docutils literal notranslate"><span class="pre">future</span></code> 功能. 这个问题在那些需要支持大量不同环境的项目中尤为明显.</dd>
<dt>结论:</dt>
<dd><p class="first"><strong>from __future__ imports</strong></p>
<p>鼓励使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span></code> 语句. 这样, 你的源代码从今天起就能使用更现代的 Python 语法. 当你不再需要支持老版本时, 请自行删除这些导入语句.</p>
<p>如果你的代码要支持 3.5 版本, 而不是常规的 <code class="docutils literal notranslate"><span class="pre">&gt;=3.7</span></code>, 请导入:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">generator_stop</span>
</pre></div>
</div>
<p>详情参见 <a class="reference external" href="https://docs.python.org/3/library/__future__.html">Python future 语句</a> 的文档.</p>
<p>除非你确定代码的运行环境已经足够现代, 否则不要删除 future 语句. 即使你用不到 future 语句, 也要保留它们, 以免其他编辑者不小心对旧的特性产生依赖.</p>
<p class="last">在你认为恰当的时候, 可以使用其他来自 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span></code> 的语句.</p>
</dd>
</dl>
</div>
<div class="section" id="section-14">
<h4>代码类型注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">你可以根据 <a class="reference external" href="https://www.python.org/dev/peps/pep-0484/">PEP-484</a> 来对 python3 代码进行注释,并使用诸如 <a class="reference external" href="https://github.com/google/pytype">pytype</a> 之类的类型检查工具来检查代码.
类型注释既可以写在源码里,也可以写在 <a class="reference external" href="https://www.python.org/dev/peps/pep-0484/#stub-files">pyi</a> 中. 推荐尽量写在源码里. 对于第三方代码和扩展包, 请使用 pyi 文件里</p>
</div>
<dl class="docutils">
<dt>定义:</dt>
<dd><p class="first">用在函数参数和返回值上:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
</pre></div>
</div>
<p>也可以使用 <a class="reference external" href="https://www.python.org/dev/peps/pep-0526/">PEP-526</a> 中的语法来声明变量类型:</p>
<div class="last highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">:</span> <span class="n">SomeType</span> <span class="o">=</span> <span class="n">some_func</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt>优点:</dt>
<dd>可以提高代码可读性和可维护性. 类型检查器可以把运行时错误变成编译错误, 并阻止你使用威力过大的特性.</dd>
<dt>缺点:</dt>
<dd>必须时常更新类型声明. 正确的代码也可能有误报. 无法使用威力大的特性.</dd>
<dt>结论:</dt>
<dd><p class="first">强烈推荐你在更新代码时启用 python 类型分析. 在添加或修改公开API时, 请添加类型注释, 并在构建系统(build system)中启用 pytype. 由于python静态分析是新功能, 因此一些意外的副作用(例如类型推导错误)可能会阻碍你的项目采纳这一功能. 在这种情况下, 建议作者在 BUILD 文件或者代码中添加一个 TODO 注释或者链接, 描述那些阻碍采用类型注释的问题.</p>
<p class="last">(译者注: 代码类型注释在帮助IDE或是vim等进行补全倒是很有效)</p>
</dd>
</dl>
</div>
</div>
<span id="document-google-python-styleguide/python_style_rules"></span><div class="section" id="python">
<h3>Python风格规范</h3>
<div class="section" id="section-1">
<h4>分号</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">不要在行尾加分号, 也不要用分号将两条语句合并到一行.</p>
</div>
</div>
<div class="section" id="section-2">
<span id="line-length"></span><h4>行宽</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">最大行宽是 80 个字符.</p>
</div>
<p>例外:</p>
<ol class="arabic simple">
<li>长的导入 (import) 语句.</li>
<li>注释里的 URL、路径名以及长的标志 (flag).</li>
<li>不便于换行、不包含空格、模块级的长字符串常量, 比如 URL 或路径名.</li>
<li>Pylint 禁用注释. (例如: <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">pylint:</span> <span class="pre">disable=invalid-name</span></code>)</li>
</ol>
<p>不要用反斜杠表示 <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#explicit-line-joining">显式续行 (explicit line continuation)</a>.</p>
<p>应该利用 Python 的 <a class="reference external" href="http://docs.python.org/2/reference/lexical_analysis.html#implicit-line-joining">圆括号, 中括号和花括号的隐式续行 (implicit line joining)</a> . 如有需要, 你可以在表达式外围添加一对括号.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">foo_bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;黑&#39;</span><span class="p">,</span> <span class="n">design</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span>
        <span class="n">emphasis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">highlight</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span>
    <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;红&#39;</span> <span class="ow">and</span> <span class="n">emphasis</span> <span class="o">==</span> <span class="s1">&#39;加粗&#39;</span><span class="p">):</span>

 <span class="p">(</span><span class="n">bridge_questions</span><span class="o">.</span><span class="n">clarification_on</span>
  <span class="o">.</span><span class="n">average_airspeed_of</span><span class="o">.</span><span class="n">unladen_swallow</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;美国的还是欧洲的?&#39;</span>

 <span class="k">with</span> <span class="p">(</span>
     <span class="n">very_long_first_expression_function</span><span class="p">()</span> <span class="k">as</span> <span class="n">spam</span><span class="p">,</span>
     <span class="n">very_long_second_expression_function</span><span class="p">()</span> <span class="k">as</span> <span class="n">beans</span><span class="p">,</span>
     <span class="n">third_thing</span><span class="p">()</span> <span class="k">as</span> <span class="n">eggs</span><span class="p">,</span>
 <span class="p">):</span>
   <span class="n">place_order</span><span class="p">(</span><span class="n">eggs</span><span class="p">,</span> <span class="n">beans</span><span class="p">,</span> <span class="n">spam</span><span class="p">,</span> <span class="n">beans</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> \
     <span class="n">color</span> <span class="o">==</span> <span class="s1">&#39;红&#39;</span> <span class="ow">and</span> <span class="n">emphasis</span> <span class="o">==</span> <span class="s1">&#39;加粗&#39;</span><span class="p">:</span>

<span class="n">bridge_questions</span><span class="o">.</span><span class="n">clarification_on</span> \
    <span class="o">.</span><span class="n">average_airspeed_of</span><span class="o">.</span><span class="n">unladen_swallow</span> <span class="o">=</span> <span class="s1">&#39;美国的还是欧洲的?&#39;</span>

<span class="k">with</span> <span class="n">very_long_first_expression_function</span><span class="p">()</span> <span class="k">as</span> <span class="n">spam</span><span class="p">,</span> \
      <span class="n">very_long_second_expression_function</span><span class="p">()</span> <span class="k">as</span> <span class="n">beans</span><span class="p">,</span> \
      <span class="n">third_thing</span><span class="p">()</span> <span class="k">as</span> <span class="n">eggs</span><span class="p">:</span>
  <span class="n">place_order</span><span class="p">(</span><span class="n">eggs</span><span class="p">,</span> <span class="n">beans</span><span class="p">,</span> <span class="n">spam</span><span class="p">,</span> <span class="n">beans</span><span class="p">)</span>
</pre></div>
</div>
<p>如果字符串的字面量 (literal) 超过一行, 应该用圆括号实现隐式续行:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;这是一个很长很长很长很长很长很长&#39;</span>
     <span class="s1">&#39;很长很长很长很长很长的字符串&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>最好在最外层的语法结构上分行. 如果你需要多次换行, 应该在同一层语法结构上换行.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bridgekeeper</span><span class="o">.</span><span class="n">answer</span><span class="p">(</span>
     <span class="n">name</span><span class="o">=</span><span class="s2">&quot;亚瑟&quot;</span><span class="p">,</span> <span class="n">quest</span><span class="o">=</span><span class="n">questlib</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">owner</span><span class="o">=</span><span class="s2">&quot;亚瑟&quot;</span><span class="p">,</span> <span class="n">perilous</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

 <span class="n">answer</span> <span class="o">=</span> <span class="p">(</span><span class="n">a_long_line</span><span class="p">()</span><span class="o">.</span><span class="n">of_chained_methods</span><span class="p">()</span>
           <span class="o">.</span><span class="n">that_eventually_provides</span><span class="p">()</span><span class="o">.</span><span class="n">an_answer</span><span class="p">())</span>

 <span class="k">if</span> <span class="p">(</span>
     <span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span>
     <span class="ow">or</span> <span class="s1">&#39;editor.language&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">config</span>
     <span class="ow">or</span> <span class="n">config</span><span class="p">[</span><span class="s1">&#39;editor.language&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">use_spaces</span> <span class="ow">is</span> <span class="kc">False</span>
 <span class="p">):</span>
   <span class="n">use_tabs</span><span class="p">()</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">bridgekeeper</span><span class="o">.</span><span class="n">answer</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;亚瑟&quot;</span><span class="p">,</span> <span class="n">quest</span><span class="o">=</span><span class="n">questlib</span><span class="o">.</span><span class="n">find</span><span class="p">(</span>
    <span class="n">owner</span><span class="o">=</span><span class="s2">&quot;亚瑟&quot;</span><span class="p">,</span> <span class="n">perilous</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

<span class="n">answer</span> <span class="o">=</span> <span class="n">a_long_line</span><span class="p">()</span><span class="o">.</span><span class="n">of_chained_methods</span><span class="p">()</span><span class="o">.</span><span class="n">that_eventually_provides</span><span class="p">(</span>
    <span class="p">)</span><span class="o">.</span><span class="n">an_answer</span><span class="p">()</span>

<span class="k">if</span> <span class="p">(</span><span class="n">config</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="s1">&#39;editor.language&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">config</span> <span class="ow">or</span> <span class="n">config</span><span class="p">[</span>
    <span class="s1">&#39;editor.language&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">use_spaces</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">):</span>
  <span class="n">use_tabs</span><span class="p">()</span>
</pre></div>
</div>
<p>必要时, 注释中的长 URL 可以独立成行.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 详情参见</span>
<span class="c1"># http://www.example.com/us/developer/documentation/api/content/v2.0/csv_file_name_extension_full_specification.html</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 详情参见</span>
<span class="c1"># http://www.example.com/us/developer/documentation/api/content/\</span>
<span class="c1"># v2.0/csv_file_name_extension_full_specification.html</span>
</pre></div>
</div>
<p>注意上面各个例子中的缩进; 详情参见 <a class="reference internal" href="#indentation"><span class="std std-ref">缩进</span></a> 章节的解释.</p>
<p>如果一行超过 80 个字符, 且 <a class="reference external" href="https://github.com/psf/black">Black</a> 或 <a class="reference external" href="https://github.com/google/pyink">Pyink</a> 自动格式化工具无法继续缩减行宽, 则允许该行超过 80 个字符. 我们也鼓励作者根据上面的规则手动拆分.</p>
</div>
<div class="section" id="section-3">
<h4>括号</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用括号时宁缺毋滥.</p>
</div>
<p>可以把元组 (tuple) 括起来, 但不强制. 不要在返回语句或条件语句中使用括号, 除非用于隐式续行或表示元组.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">foo</span><span class="p">:</span>
    <span class="n">bar</span><span class="p">()</span>
<span class="k">while</span> <span class="n">x</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">bar</span><span class="p">()</span>
<span class="k">if</span> <span class="n">x</span> <span class="ow">and</span> <span class="n">y</span><span class="p">:</span>
    <span class="n">bar</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="p">:</span>
    <span class="n">bar</span><span class="p">()</span>
<span class="c1"># 对于包含单个元素的元组, 括号比逗号更直观.</span>
<span class="n">onesie</span> <span class="o">=</span> <span class="p">(</span><span class="n">foo</span><span class="p">,)</span>
<span class="k">return</span> <span class="n">foo</span>
<span class="k">return</span> <span class="n">spam</span><span class="p">,</span> <span class="n">beans</span>
<span class="k">return</span> <span class="p">(</span><span class="n">spam</span><span class="p">,</span> <span class="n">beans</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> <span class="o">...</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">bar</span><span class="p">()</span>
<span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">bar</span><span class="p">()</span>
<span class="k">return</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<span id="indentation"></span><h4>缩进</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">用4个空格作为缩进.</p>
</div>
<p>不要使用制表符. 使用隐式续行时, 应该把括起来的元素垂直对齐(参见 <a class="reference internal" href="#line-length"><span class="std std-ref">行宽</span></a> 章节的示例), 或者添加4个空格的悬挂缩进. 右括号 (圆括号, 方括号或花括号) 可以置于表达式结尾或者另起一行. 另起一行时右括号应该和左括号所在的那一行缩进相同.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 与左括号对齐.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span><span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span>
                         <span class="n">var_three</span><span class="p">,</span> <span class="n">var_four</span><span class="p">)</span>
<span class="n">meal</span> <span class="o">=</span> <span class="p">(</span><span class="n">spam</span><span class="p">,</span>
        <span class="n">beans</span><span class="p">)</span>

<span class="c1"># 与字典的左括号对齐.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;long_dictionary_key&#39;</span><span class="p">:</span> <span class="n">value1</span> <span class="o">+</span>
                           <span class="n">value2</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>

<span class="c1"># 4个空格的悬挂缩进; 首行没有元素</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span>
    <span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span> <span class="n">var_three</span><span class="p">,</span>
    <span class="n">var_four</span><span class="p">)</span>
<span class="n">meal</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">spam</span><span class="p">,</span>
    <span class="n">beans</span><span class="p">)</span>

<span class="c1"># 4个空格的悬挂缩进; 首行没有元素</span>
<span class="c1"># 右括号另起一行.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span>
    <span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span> <span class="n">var_three</span><span class="p">,</span>
    <span class="n">var_four</span>
<span class="p">)</span>
<span class="n">meal</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">spam</span><span class="p">,</span>
    <span class="n">beans</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># 字典中的4空格悬挂缩进.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;long_dictionary_key&#39;</span><span class="p">:</span>
        <span class="n">long_dictionary_value</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 首行不能有元素.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span><span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span>
    <span class="n">var_three</span><span class="p">,</span> <span class="n">var_four</span><span class="p">)</span>

<span class="c1"># 禁止2个空格的悬挂缩进.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="n">long_function_name</span><span class="p">(</span>
  <span class="n">var_one</span><span class="p">,</span> <span class="n">var_two</span><span class="p">,</span> <span class="n">var_three</span><span class="p">,</span>
  <span class="n">var_four</span><span class="p">)</span>

<span class="c1"># 字典没有悬挂缩进.</span>
<span class="n">foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;long_dictionary_key&#39;</span><span class="p">:</span>
    <span class="n">long_dictionary_value</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>序列的尾部要添加逗号吗?</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">仅当 <code class="docutils literal notranslate"><span class="pre">]</span></code>, <code class="docutils literal notranslate"><span class="pre">)</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code> 和最后一个元素不在同一行时, 推荐在序列尾部添加逗号. 我们的 Python 自动格式化工具会把尾部的逗号视为一种格式提示.</p>
</div>
</div>
<div class="section" id="shebang">
<h4>Shebang行</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">大部分 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 文件不必以 <code class="docutils literal notranslate"><span class="pre">#!</span></code> 开始. 可以根据 <a class="reference external" href="http://www.python.org/dev/peps/pep-0394/">PEP-394</a> , 在程序的主文件开头添加 <code class="docutils literal notranslate"><span class="pre">#!/usr/bin/env</span> <span class="pre">python3</span></code> (以支持 virtualenv) 或者 <code class="docutils literal notranslate"><span class="pre">#!/usr/bin/python3</span></code>.</p>
</div>
<p>(译者注: 在计算机科学中, <a class="reference external" href="http://en.wikipedia.org/wiki/Shebang_(Unix)">Shebang</a> (也称为Hashbang)是一个由井号和叹号构成的字符串行(#!), 其出现在文本文件的第一行的前两个字符. 在文件中存在Shebang的情况下, 类Unix操作系统的程序载入器会分析Shebang后的内容, 将这些内容作为解释器指令, 并调用该指令, 并将载有Shebang的文件路径作为该解释器的参数. 例如, 以指令#!/bin/sh开头的文件在执行时会实际调用/bin/sh程序.)</p>
<p>内核会通过这行内容找到Python解释器, 但是Python解释器在导入模块时会忽略这行内容. 这行内容仅对需要直接运行的文件有效.</p>
</div>
<div class="section" id="docstring">
<span id="comments"></span><h4>注释和文档字符串 (docstring)</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">模块、函数、方法的文档字符串和内部注释一定要采用正确的风格.</p>
</div>
<p><strong>文档字符串</strong></p>
<blockquote>
<div>Python 的文档字符串用于注释代码. 文档字符串是位于包、模块、类或函数里第一个语句的字符串. 可以用对象的 <code class="docutils literal notranslate"><span class="pre">__doc__</span></code> 成员自动提取这些字符串, 并为 <code class="docutils literal notranslate"><span class="pre">pydoc</span></code> 所用. (可以试试在你的模块上运行 <code class="docutils literal notranslate"><span class="pre">pydoc</span></code> 并观察结果). 文档字符串一定要用三重双引号 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code> 的格式 (依据 <a class="reference external" href="http://www.python.org/dev/peps/pep-0257/">PEP-257</a> ). 文档字符串应该是一行概述 (整行不超过 80 个字符), 以句号、问号或感叹号结尾. 如果要写更多注释 (推荐), 那么概述后面必须紧接着一个空行, 然后是剩下的内容, 缩进与文档字符串的第一行的第一个引号对齐. 下面是更多有关文档字符串的格式规范.</div></blockquote>
<p><strong>模块</strong></p>
<blockquote>
<div><p>每个文件应该包含一个许可协议模版. 应根据项目使用的许可协议 (例如, Apache 2.0, BSD, LGPL, GPL) 选择合适的模版.</p>
<p>文件的开头应该是文档字符串, 其中应该描述该模块内容和用法.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;模块或程序的一行概述, 以句号结尾.</span>

<span class="sd">留一个空行. 接下来应该写模块或程序的总体描述. 也可以选择简要描述导出的类和函数,</span>
<span class="sd">和/或描述使用示例.</span>

<span class="sd">经典的使用示例:</span>

<span class="sd">foo = ClassFoo()</span>
<span class="sd">bar = foo.FunctionBar()</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>测试模块</strong></p>
<blockquote>
<div><p>测试文件不必包含模块级文档字符串. 只有在文档字符串可以提供额外信息时才需要写入文件.</p>
<p>例如, 你可以描述运行测试时所需的特殊要求, 解释不常见的初始化模式, 描述外部环境的依赖等等.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;这个blaze测试会使用样板文件.</span>

<span class="sd">若要更新这些文件, 你可以在 `google3` 文件夹中运行</span>
<span class="sd">`blaze run //foo/bar:foo_test -- --update_golden_files`</span>
<span class="sd">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>不要使用不能提供额外信息的文档字符串.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;foo.bar 的测试.&quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>函数和方法</strong></p>
<blockquote>
<div><p>本节中的函数是指函数、方法、生成器 (generator) 和特性 (property).</p>
<p>满足下列任意特征的任何函数都必须有文档字符串:</p>
<ol class="arabic simple">
<li>公开 API 的一部分</li>
<li>长度过长</li>
<li>逻辑不能一目了然</li>
</ol>
<p>文档字符串应该提供充分的信息, 让调用者无需阅读函数的代码就能调用函数. 文档字符串应该描述函数的调用语法和语义信息, 而不应该描述具体的实现细节, 除非这些细节会影响函数的用法. 比如, 如果函数的副作用是会修改某个传入的对象, 那就需要在文档字符串中说明. 对于微妙、重要但是与调用者无关的实现细节, 相较于在文档字符串里说明, 还是在代码中间加注释更好.</p>
<p>文档字符串可以是陈述句 (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;Fetches</span> <span class="pre">rows</span> <span class="pre">from</span> <span class="pre">a</span> <span class="pre">Bigtable.&quot;&quot;&quot;</span></code>) 或者祈使句 (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;Fetch</span> <span class="pre">rows</span> <span class="pre">from</span> <span class="pre">a</span> <span class="pre">Bigtable.&quot;&quot;&quot;</span></code>), 不过一个文件内的风格应当一致. 对于 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 修饰的数据描述符 (data descriptor), 文档字符串应采用和属性 (attribute) 或 <a class="reference internal" href="#doc-function-args"><span class="std std-ref">函数参数</span></a> 一样的风格 (<code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;Bigtable</span> <span class="pre">路径.&quot;&quot;&quot;</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;返回</span> <span class="pre">Bigtable</span> <span class="pre">路径.&quot;&quot;&quot;</span></code>).</p>
<p>对于覆写 (override) 基类 (base class) 方法的子类方法, 可以用简单的文档字符串引导读者阅读基类方法的文档字符串, 比如 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;参见基类.&quot;&quot;&quot;&quot;</span></code>. 这样是为了避免到处复制基类方法中已有的文档字符串. 然而, 如果覆写的子类方法与基类方法截然不同, 或者有更多细节需要记录 (例如有额外的的副作用), 那么子类方法的文档字符串中至少要描述这些区别.</p>
<p>函数的部分特征应该在以下列出特殊小节中记录. 每小节有一行标题, 标题以冒号结尾. 除标题行外, 小节的其他部分应有2个或4个空格 (同一文件内应保持一致) 的悬挂缩进. 如果函数名和函数签名 (signature) 可以见名知意, 以至于一行文档字符串就能恰当地描述该函数, 那么可以省略这些小节.</p>
</div></blockquote>
<blockquote id="doc-function-args">
<div><dl class="docutils">
<dt>Args: (参数:)</dt>
<dd>列出所有参数名. 参数名后面是一个冒号, 然后是一个空格或者换行符, 最后是描述. 如果描述过长以至于一行超出了 80 字符, 则描述部分应该比参数名所在的行多2个或者4个空格 (文件内应当一致) 的悬挂缩进. 如果代码没有类型注解, 则描述中应该说明所需的类型. 如果一个函数有形如 <code class="docutils literal notranslate"><span class="pre">*foo</span></code> (可变长参数列表) 或者 <code class="docutils literal notranslate"><span class="pre">**bar</span></code> (任意关键字参数) 的参数, 那么列举参数名时应该写成 <code class="docutils literal notranslate"><span class="pre">*foo</span></code> 和 <code class="docutils literal notranslate"><span class="pre">**bar</span></code> 的这样的格式.</dd>
<dt>Returns: (“返回:”)</dt>
<dd><p class="first">生成器应该用 “Yields:” (“生成:” )</p>
<p class="last">描述返回值的类型和意义. 如果函数仅仅返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>, 这一小节可以省略. 如果文档字符串以 Returns (返回) 或者 Yields (生成) 开头 (例如 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;返回</span> <span class="pre">Bigtable</span> <span class="pre">的行,</span> <span class="pre">类型是字符串构成的元组.&quot;&quot;&quot;</span></code>) 且这句话已经足以描述返回值, 也可以省略这一小节. 不要模仿 Numpy 风格的文档 (<a class="reference external" href="http://numpy.org/doc/stable/reference/generated/numpy.linalg.qr.html">例子</a>). 他们在文档中记录作为返回值的元组时, 写得就像返回值是多个值且每个值都有名字 (没有提到返回的是元组). 应该这样描述此类情况: “返回: 一个元组 (mat_a, mat_b), 其中 mat_a 是…, 且 …”. 文档字符串中使用的辅助名称不需要和函数体的内部变量名一致 (因为这些名称不是 API 的一部分).</p>
</dd>
<dt>Raises: (抛出:)</dt>
<dd>列出与接口相关的所有异常和异常描述. 用类似 Args (参数) 小节的格式，写成异常名+冒号+空格/换行, 并添加悬挂缩进. 不要在文档中记录违反 API 的使用条件时会抛出的异常 (因为这会让违背 API 时出现的效果成为 API 的一部分, 这是矛盾的).</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fetch_smalltable_rows</span><span class="p">(</span>
    <span class="n">table_handle</span><span class="p">:</span> <span class="n">smalltable</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">keys</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span> <span class="o">|</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">require_all_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;从 Smalltable 获取数据行.</span>

<span class="sd">    从 table_handle 代表的 Table 实例中检索指定键值对应的行. 如果键值是字符串,</span>
<span class="sd">    字符串将用 UTF-8 编码.</span>

<span class="sd">    参数:</span>
<span class="sd">        table_handle: 处于打开状态的 smalltable.Table 实例.</span>
<span class="sd">        keys: 一个字符串序列, 代表要获取的行的键值. 字符串将用 UTF-8 编码.</span>
<span class="sd">        require_all_keys: 如果为 True, 只返回那些所有键值都有对应数据的</span>
<span class="sd">            行.</span>

<span class="sd">    返回:</span>
<span class="sd">        一个字典, 把键值映射到行数据上. 行数据是字符串构成的元组. 例如:</span>

<span class="sd">        {b&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),</span>
<span class="sd">         b&#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),</span>
<span class="sd">         b&#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}</span>

<span class="sd">        返回的键值一定是字节串. 如果字典中没有 keys 参数中的某个键值, 说明</span>
<span class="sd">        表格中没有找到这一行 (且 require_all_keys 一定是 false).</span>

<span class="sd">    抛出:</span>
<span class="sd">        IOError: 访问 smalltable 时出现错误.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
<p>以下这种在 Args (参数) 小节中换行的写法也是可以的:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fetch_smalltable_rows</span><span class="p">(</span>
    <span class="n">table_handle</span><span class="p">:</span> <span class="n">smalltable</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">keys</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bytes</span> <span class="o">|</span> <span class="nb">str</span><span class="p">],</span>
    <span class="n">require_all_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;从 Smalltable 获取数据行.</span>

<span class="sd">    从 table_handle 代表的 Table 实例中检索指定键值对应的行. 如果键值是字符串,</span>
<span class="sd">    字符串将用 UTF-8 编码.</span>

<span class="sd">    参数:</span>
<span class="sd">        table_handle:</span>
<span class="sd">          处于打开状态的 smalltable.Table 实例.</span>
<span class="sd">        keys:</span>
<span class="sd">          一个字符串序列, 代表要获取的行的键值. 字符串将用 UTF-8 编码.</span>
<span class="sd">        require_all_keys:</span>
<span class="sd">          如果为 True, 只返回那些所有键值都有对应数据的行.</span>

<span class="sd">    返回:</span>
<span class="sd">        一个字典, 把键值映射到行数据上. 行数据是字符串构成的元组. 例如:</span>

<span class="sd">        {b&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),</span>
<span class="sd">         b&#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),</span>
<span class="sd">         b&#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)}</span>

<span class="sd">        返回的键值一定是字节串. 如果字典中没有 keys 参数中的某个键值, 说明</span>
<span class="sd">        表格中没有找到这一行 (且 require_all_keys 一定是 false).</span>

<span class="sd">    抛出:</span>
<span class="sd">        IOError: 访问 smalltable 时出现错误.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>类 (class)</strong></p>
<blockquote>
<div><p>类的定义下方应该有一个描述该类的文档字符串. 如果你的类包含公有属性 (attributes), 应该在 <code class="docutils literal notranslate"><span class="pre">Attributes</span></code> (属性) 小节中记录这些属性, 格式与函数的 <code class="docutils literal notranslate"><span class="pre">Args</span></code> (参数) 小节类似.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SampleClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;这里是类的概述.</span>

<span class="sd">    这里是更多信息....</span>
<span class="sd">    这里是更多信息....</span>

<span class="sd">    属性:</span>
<span class="sd">        likes_spam: 布尔值, 表示我们是否喜欢午餐肉.</span>
<span class="sd">        eggs: 用整数记录的下蛋的数量.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">likes_spam</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;用某某某初始化 SampleClass.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">likes_spam</span> <span class="o">=</span> <span class="n">likes_spam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eggs</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">public_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;执行某某操作.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>类的文档字符串开头应该是一行概述, 描述类的实例所代表的事物. 这意味着 <code class="docutils literal notranslate"><span class="pre">Exception</span></code> 的子类 (subclass) 应该描述这个异常代表什么, 而不是描述抛出异常时的环境. 类的文档字符串不应该有无意义的重复, 例如说这个类是一种类.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CheeseShopAddress</span><span class="p">:</span>
<span class="sd">&quot;&quot;&quot;奶酪店的地址.</span>

<span class="sd">...</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">OutOfCheeseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot;没有可用的奶酪.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CheeseShopAddress</span><span class="p">:</span>
<span class="sd">&quot;&quot;&quot;一个描述奶酪店地址的类.</span>

<span class="sd">...</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">class</span> <span class="nc">OutOfCheeseError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="sd">&quot;&quot;&quot;在没有可用的奶酪时抛出.&quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>块注释和行注释</strong></p>
<blockquote>
<div><p>最后一种需要写注释的地方是代码中复杂的部分. 如果你可能在以后 <a class="reference external" href="http://en.wikipedia.org/wiki/Code_review">代码评审 (code review)</a> 时要解释某段代码, 那么现在就应该给这段代码加上注释. 应该在复杂的操作开始前写上若干行注释. 对于不是一目了然的代码, 应该在行尾添加注释.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 我们用加权的字典搜索, 寻找 i 在数组中的位置. 我们基于数组中的最大值和数组</span>
<span class="c1"># 长度, 推断一个位置, 然后用二分搜索获得最终准确的结果.</span>

<span class="k">if</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 如果 i 是 0 或者 2 的整数次幂, 则为真.</span>
</pre></div>
</div>
<p>为了提高可读性, 注释的井号和代码之间应有至少2个空格, 井号和注释之间应该至少有一个空格.</p>
<p>除此之外, 绝不要仅仅描述代码. 应该假设读代码的人比你更懂Python, 只是不知道你的代码要做什么.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 不好的注释: 现在遍历数组 b, 确保每次 i 出现时, 下一个元素是 i+1</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="section-6">
<h4>标点符号、拼写和语法</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">注意标点符号、拼写和语法. 文笔好的注释比差的注释更容易理解.</p>
</div>
<p>注释应该和记叙文一样可读, 使用恰当的大小写和标点. 一般而言, 完整的句子比残缺句更可读. 较短的注释 (比如行尾注释) 可以更随意, 但是你要保持风格一致.</p>
<p>尽管你可能会因为代码审稿人指出你误把冒号写作逗号而灰心, 但是保持源代码清晰可读也是非常重要的. 正确的标点、拼写和语法有助于实现这一目标.</p>
</div>
<div class="section" id="section-7">
<h4>字符串</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">应该用 <a class="reference external" href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings">f-string</a>、 <code class="docutils literal notranslate"><span class="pre">%</span></code> 运算符或 <code class="docutils literal notranslate"><span class="pre">format</span></code> 方法来格式化字符串. 即使所有参数都是字符串, 也如此. 你可以自行评判合适的选项. 可以用 <code class="docutils literal notranslate"><span class="pre">+</span></code> 实现单次拼接, 但是不要用 <code class="docutils literal notranslate"><span class="pre">+</span></code> 实现格式化.</p>
</div>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;名称: </span><span class="si">{name}</span><span class="s1">; 分数: </span><span class="si">{n}</span><span class="s1">&#39;</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">imperative</span><span class="p">,</span> <span class="n">expletive</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;名称: </span><span class="si">%s</span><span class="s1">; 分数: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;名称: </span><span class="si">%(name)s</span><span class="s1">; 分数: </span><span class="si">%(score)d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">:</span><span class="n">n</span><span class="p">}</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;名称: </span><span class="si">{}</span><span class="s1">; 分数: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span> <span class="o">+</span> <span class="n">second</span>
<span class="n">x</span> <span class="o">=</span> <span class="s1">&#39;名称: &#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;; 分数: &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>不要在循环中用 <code class="docutils literal notranslate"><span class="pre">+</span></code> 和 <code class="docutils literal notranslate"><span class="pre">+=</span></code> 操作符来堆积字符串. 这有时会产生平方而不是线性的时间复杂度. 有时 CPython 会优化这种情况, 但这是一种实现细节. 我们无法轻易预测这种优化是否生效, 而且未来情况可能出现变化. 作为替代方案, 你可以将每个子串加入列表, 然后在循环结束后用 <code class="docutils literal notranslate"><span class="pre">''.join</span></code> 拼接列表. 也可以将每个子串写入一个 <code class="docutils literal notranslate"><span class="pre">io.StringIO</span></code> 缓冲区中. 这些技巧保证始终有线性的平摊 (amortized) 时间复杂度.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;table&gt;&#39;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span> <span class="ow">in</span> <span class="n">employee_list</span><span class="p">:</span>
    <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span><span class="p">))</span>
<span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&lt;/table&gt;&#39;</span><span class="p">)</span>
<span class="n">employee_table</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">employee_table</span> <span class="o">=</span> <span class="s1">&#39;&lt;table&gt;&#39;</span>
<span class="k">for</span> <span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span> <span class="ow">in</span> <span class="n">employee_list</span><span class="p">:</span>
    <span class="n">employee_table</span> <span class="o">+=</span> <span class="s1">&#39;&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">last_name</span><span class="p">,</span> <span class="n">first_name</span><span class="p">)</span>
<span class="n">employee_table</span> <span class="o">+=</span> <span class="s1">&#39;&lt;/table&gt;&#39;</span>
</pre></div>
</div>
<p>应该保持同一文件中字符串引号的一致性. 选择 <code class="docutils literal notranslate"><span class="pre">'</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> 以后不要改变主意. 如果需要避免用反斜杠来转义引号, 则可以使用另一种引号.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Python</span><span class="p">(</span><span class="s1">&#39;为什么你要捂眼睛?&#39;</span><span class="p">)</span>
<span class="n">Gollum</span><span class="p">(</span><span class="s2">&quot;I&#39;m scared of lint errors. (我害怕格式错误.)&quot;</span><span class="p">)</span>
<span class="n">Narrator</span><span class="p">(</span><span class="s1">&#39;&quot;很好!&quot; 一个开心的 Python 审稿人心想.&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(译者注: 注意 “I’m” 中间有一个单引号，所以这一行的外层引号可以用不同的引号.)</p>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Python</span><span class="p">(</span><span class="s2">&quot;为什么你要捂眼睛?&quot;</span><span class="p">)</span>
<span class="n">Gollum</span><span class="p">(</span><span class="s1">&#39;格式检查器. 它在闪耀. 它要亮瞎我们.&#39;</span><span class="p">)</span>
<span class="n">Gollum</span><span class="p">(</span><span class="s2">&quot;伟大的格式检查器永在. 它在看. 它在看.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>多行字符串推荐使用 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">'''</span></code>. 当且仅当项目中用 <code class="docutils literal notranslate"><span class="pre">'</span></code> 给常规字符串打引号时, 才能在文档字符串以外的多行字符串上使用 <code class="docutils literal notranslate"><span class="pre">'''</span></code>. 无论如何, 文档字符串必须使用 <code class="docutils literal notranslate"><span class="pre">&quot;&quot;&quot;</span></code>.</p>
<p>多行字符串不会跟进代码其他部分的缩进. 如果需要避免字符串中的额外空格, 可以用多个单行字符串拼接, 或者用 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/textwrap.html#textwrap.dedent">textwrap.dedent()</a> 删除每行开头的空格.</p>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>    <span class="n">long_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;这样很难看.</span>
<span class="s2">不要这样做.</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">long_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;如果你可以接受多余的空格,</span>
<span class="s2">    就可以这样.&quot;&quot;&quot;</span>

<span class="n">long_string</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;如果你不能接受多余的空格,</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
               <span class="s2">&quot;可以这样.&quot;</span><span class="p">)</span>

<span class="n">long_string</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;如果你不能接受多余的空格,</span><span class="se">\n</span><span class="s2">&quot;</span>
               <span class="s2">&quot;也可以这样.&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">textwrap</span>

<span class="n">long_string</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">  这样也行, 因为 textwrap.dedent()</span>
<span class="s2">  会删除每一行开头共有的空格.&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>注意, 这里的反斜杠没有违反 <a class="reference internal" href="#line-length"><span class="std std-ref">显式续行的禁令</span></a>. 此时, 反斜杠用于在字符串字面量 (literal) 中 <a class="reference external" href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#string-and-bytes-literals">对换行符转义</a>.</p>
<p><strong>日志</strong></p>
<blockquote>
<div><p>对于那些第一个参数是格式字符串 (包含 <code class="docutils literal notranslate"><span class="pre">%</span></code> 占位符) 的日志函数: 一定要用字符串字面量 (而非 f-string!) 作为第一个参数, 并用占位符的参数作为其他参数. 有些日志的实现会收集未展开的格式字符串, 作为可搜索的项目. 这样也可以免于渲染那些被设置为不用输出的消息.</p>
<p>正确；</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span>
<span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;TensorFlow 的版本是: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;当前的 $PAGER 是: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;PAGER&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="n">homedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">homedir</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">homedir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;无法写入主目录, $HOME=</span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">homedir</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;当前的 $PAGER 是:&#39;</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;PAGER&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">))</span>

<span class="n">homedir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;HOME&#39;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">homedir</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">homedir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">W_OK</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;无法写入主目录, $HOME=</span><span class="si">{homedir!r}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>错误信息</strong></p>
<blockquote>
<div><p>错误信息 (例如: 诸如 <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> 等异常的信息字符串和展示给用户的信息) 应该遵守以下三条规范:</p>
<ol class="arabic simple">
<li>信息需要精确地匹配真正的错误条件.</li>
<li>插入的片段一定要能清晰地分辨出来.</li>
<li>要便于简单的自动化处理 (例如正则搜索, 也就是 grepping).</li>
</ol>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;这不是概率值: </span><span class="si">{p!r}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;无法删除这个文件夹 (原因: </span><span class="si">%r</span><span class="s1">): </span><span class="si">%r</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">error</span><span class="p">,</span> <span class="n">workdir</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># 问题: 遇到 float(&#39;nan&#39;) 时也为假!</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;这不是概率值: </span><span class="si">{p!r}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
    <span class="c1"># 问题: 信息中存在错误的揣测，</span>
    <span class="c1"># 删除操作可能因为其他原因而失败, 此时会误导调试人员.</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;文件夹已被删除: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">workdir</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">rmdir</span><span class="p">(</span><span class="n">workdir</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
    <span class="c1"># 问题: 这个信息难以搜索, 而且某些 `workdir` 的值会让人困惑.</span>
    <span class="c1"># 假如有人调用这段代码时让 workdir = &#39;已删除&#39;. 这个警告会变成:</span>
    <span class="c1"># &quot;无法删除已删除文件夹.&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;无法删除</span><span class="si">%s</span><span class="s1">文件夹.&#39;</span><span class="p">,</span> <span class="n">workdir</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="socket">
<h4>文件、套接字 (socket) 和类似的有状态资源</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用完文件和套接字以后, 显式地关闭它们. 自然地, 这条规则也应该扩展到其他在内部使用套接字的可关闭资源 (比如数据库连接) 和其他需要用类似方法关停的资源. 其他例子还有 <a class="reference external" href="https://docs.python.org/zh-cn/3/library/mmap.html">mmap</a> 映射、 <a class="reference external" href="https://docs.h5py.org/en/stable/high/file.html">h5py 的文件对象</a> 和 <a class="reference external" href="https://matplotlib.org/2.1.0/api/_as_gen/matplotlib.pyplot.close.html">matplotlib.pyplot 的图像窗口</a> .</p>
</div>
<p>如果保持不必要的文件、套接字或其他有状态对象开启, 会产生很多缺点:</p>
<ol class="arabic simple">
<li>它们可能消耗有限的系统资源, 例如文件描述符. 如果代码需要使用大量类似的资源而没有及时返还给系统, 就有可能出现原本可以避免的资源枯竭情况.</li>
<li>保持文件的开启状态会阻碍其他操作, 例如移动、删除文件, 卸载 (unmont) 文件系统等等.</li>
<li>如果程序的多个部分共享文件和套接字, 即使逻辑上文件已经关闭了, 仍然有可能出现意外的读写操作. 如果这些资源真正关闭了, 读写操作会抛出异常, 让问题早日浮出水面.</li>
</ol>
<p>此外, 即使文件和套接字 (以及其他行为类似的资源) 会在析构 (destruct) 时自动关闭, 把对象的生命周期和资源状态绑定的行为依然不妥:</p>
<ol class="arabic simple">
<li>无法保证运行时 (runtime) 调用 <code class="docutils literal notranslate"><span class="pre">__del__</span></code> 方法的真正时机. 不同的 Python 实现采用了不同的内存管理技巧 (比如延迟垃圾处理机制, delayed garbage collection), 可能会随意、无限期地延长对象的生命周期.</li>
<li>意想不到的文件引用 (例如全局对象和异常的堆栈跟踪, exception tracebacks) 可能让文件的存续时间比想象的更长.</li>
</ol>
<p>依赖于终结器 (finalizer) 实现自动清理的方法有显著的副作用. 这在几十年的时间里、在多种语言中 (参见 <a class="reference external" href="https://wiki.sei.cmu.edu/confluence/display/java/MET12-J.+Do+not+use+finalizers">这篇</a> Java 的文章) 多次引发严重问题.</p>
<p>推荐使用 <a class="reference external" href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#the-with-statement">“with”语句</a> 管理文件和类似的资源:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;hello.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">hello_file</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">hello_file</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span>
</pre></div>
</div>
<p>对于不支持 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句且类似文件的对象, 应该使用 <code class="docutils literal notranslate"><span class="pre">contextlib.closing()</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">contextlib</span>

<span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">closing</span><span class="p">(</span><span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s2">&quot;http://www.python.org/&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">front_page</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">front_page</span><span class="p">:</span>
        <span class="nb">print</span> <span class="n">line</span>
</pre></div>
</div>
<p>少数情况下无法使用基于上下文 (context) 的资源管理, 此时文档应该清楚地解释代码会如何管理资源的生命周期.</p>
</div>
<div class="section" id="todo">
<h4>TODO (待办) 注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在临时、短期和不够完美的代码上添加 TODO (待办) 注释.</p>
</div>
<p>待办注释以 <code class="docutils literal notranslate"><span class="pre">TODO</span></code> (待办) 这个全部大写的词开头, 紧跟着是用括号括起来的上下文标识符 (最好是 bug 链接, 有时是你的用户名). 最好是诸如 <code class="docutils literal notranslate"><span class="pre">TODO(https://crbug.com/&lt;bug编号&gt;):</span></code> 这样的 bug 链接, 因为 bug 有历史追踪和评论, 而程序员可能发生变动并忘记上下文. TODO 后面应该解释待办的事情.</p>
<p>统一 TODO 的格式是为了方便搜索并查看详情. TODO 不代表注释中提到的人要做出修复问题的保证. 所以, 当你创建带有用户名的 TODO 时, 大部分情况下应该用你自己的用户名.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># TODO(crbug.com/192795): 研究 cpufreq 的优化.</span>
<span class="c1"># TODO(你的用户名): 提交一个议题 (issue), 用 &#39;*&#39; 代表重复.</span>
</pre></div>
</div>
<p>如果你的 TODO 形式类似于”将来做某事”, 请确保其中包含特别具体的日期 (“2009年11月前解决”) 或者特别具体的事件 (“当所有客户端都能处理 XML 响应时, 删除这些代码”), 以便于未来的代码维护者理解.</p>
</div>
<div class="section" id="import">
<h4>导入 (import) 语句的格式</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">导入语句应该各自独占一行. <a class="reference internal" href="#typing-imports"><span class="std std-ref">typing 和 collections.abc 的导入除外</span></a>. 例如:</p>
</div>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">NewType</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
</pre></div>
</div>
<p>导入语句必须在文件顶部, 位于模块的注释和文档字符串之后、全局变量和全局常量之前. 导入语句应该按照如下顺序分组, 从通用到特殊:</p>
<ol class="arabic">
<li><p class="first">导入 Python 的 <code class="docutils literal notranslate"><span class="pre">__future__</span></code>. 例如:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
</pre></div>
</div>
<p>参见前文有关 <code class="docutils literal notranslate"><span class="pre">__future__</span></code> 语句的描述.</p>
</div></blockquote>
</li>
<li><p class="first">导入 Python 的标准库. 例如:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">导入 <a class="reference external" href="https://pypi.org/">第三方</a> 模块和包. 例如:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">导入代码仓库中的子包. 例如:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">otherproject.ai</span> <span class="kn">import</span> <span class="n">mind</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first"><strong>已废弃的规则</strong>: 导入应用专属的、与该文件属于同一个子包的模块. 例如:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">myproject.backend.hgwells</span> <span class="kn">import</span> <span class="n">time_machine</span>
</pre></div>
</div>
<p>你可能会在较老的谷歌风格 Python 代码中遇到这样的模式, 但现在不再执行这条规则. <strong>我们建议新代码忽略这条规则.</strong> 同等对待应用专属的子包和其他子包即可.</p>
</div></blockquote>
</li>
</ol>
<p>在每个分组内部, 应该按照模块完整包路径 (例如 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">path</span> <span class="pre">import</span> <span class="pre">...</span></code> 中的 <code class="docutils literal notranslate"><span class="pre">path</span></code>) 的字典序排序, 忽略大小写. 可以选择在分组之间插入空行.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">queue</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">app</span>
<span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">flags</span>
<span class="kn">import</span> <span class="nn">bs4</span>
<span class="kn">import</span> <span class="nn">cryptography</span>
<span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>

<span class="kn">from</span> <span class="nn">book.genres</span> <span class="kn">import</span> <span class="n">scifi</span>
<span class="kn">from</span> <span class="nn">myproject.backend</span> <span class="kn">import</span> <span class="n">huxley</span>
<span class="kn">from</span> <span class="nn">myproject.backend.hgwells</span> <span class="kn">import</span> <span class="n">time_machine</span>
<span class="kn">from</span> <span class="nn">myproject.backend.state_machine</span> <span class="kn">import</span> <span class="n">main_loop</span>
<span class="kn">from</span> <span class="nn">otherproject.ai</span> <span class="kn">import</span> <span class="n">body</span>
<span class="kn">from</span> <span class="nn">otherproject.ai</span> <span class="kn">import</span> <span class="n">mind</span>
<span class="kn">from</span> <span class="nn">otherproject.ai</span> <span class="kn">import</span> <span class="n">soul</span>

<span class="c1"># 旧的代码可能会把这些导入语句放在下面这里:</span>
<span class="c1">#from myproject.backend.hgwells import time_machine</span>
<span class="c1">#from myproject.backend.state_machine import main_loop</span>
</pre></div>
</div>
</div>
<div class="section" id="section-8">
<h4>语句</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">通常每个语句应该独占一行.</p>
</div>
<p>不过, 如果判断语句的主体与判断条件可以挤进一行, 你可以将它们放在同一行. 特别注意这不适用于 <code class="docutils literal notranslate"><span class="pre">try</span></code> / <code class="docutils literal notranslate"><span class="pre">except</span></code>, 因为 <code class="docutils literal notranslate"><span class="pre">try</span></code> 和 <code class="docutils literal notranslate"><span class="pre">except</span></code> 不能放在同一行. 只有在 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句没有对应的 <code class="docutils literal notranslate"><span class="pre">else</span></code> 时才适用.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">foo</span><span class="p">:</span> <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">foo</span><span class="p">:</span> <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>   <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>               <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">bar</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span> <span class="n">baz</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="getter-setter-1">
<span id="getter-setter"></span><h4>访问器 (getter) 和设置器 (setter)</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在访问和设置变量值时, 如果访问器和设置器 (又名为访问子 accessor 和变异子 mutator) 可以产生有意义的作用或效果, 则可以使用.</p>
</div>
<p>特别来说, 如果在当下或者可以预见的未来, 读写某个变量的过程很复杂或者成本高昂, 则应该使用这种函数.</p>
<p>如果一对访问器和设置器仅仅用于读写一个内部属性 (attribute), 你应该直接用公有属性取代它们. 相较而言, 如果设置操作会让部分状态无效化或引发重建, 则需要使用设置器. 显式的函数调用表示可能出现特殊的操作. 如果只有简单的逻辑, 或者在重构代码后不再需要访问器和设置器, 你可以用属性 (property) 替代.</p>
<p>(译者注: 重视封装的面向对象程序员看到这个可能会很反感, 因为他们一直被教育: 所有成员变量都必须是私有的! 其实, 那真的是有点麻烦啊. 试着去接受Pythonic哲学吧)</p>
<p>访问器和设置器应该遵守命名规范, 例如 <code class="docutils literal notranslate"><span class="pre">get_foo()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">set_foo()</span></code>.</p>
<p>如果之前的代码通过属性获取数据, 则不能把重新编写的访问器/设置器与这一属性绑定. 应该让任何用老办法访问变量的代码出现显眼的错误, 让使用者意识到代码复杂度有变化.</p>
</div>
<div class="section" id="section-9">
<h4>命名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">模块名: <code class="docutils literal notranslate"><span class="pre">module_name</span></code>; 包名: <code class="docutils literal notranslate"><span class="pre">package_name</span></code>; 类名: <code class="docutils literal notranslate"><span class="pre">ClassName</span></code>; 方法名: <code class="docutils literal notranslate"><span class="pre">method_name</span></code>; 异常名: <code class="docutils literal notranslate"><span class="pre">ExceptionName</span></code>; 函数名: <code class="docutils literal notranslate"><span class="pre">function_name</span></code>, <code class="docutils literal notranslate"><span class="pre">query_proper_noun_for_thing</span></code>, <code class="docutils literal notranslate"><span class="pre">send_acronym_via_https</span></code>; 全局常量名: <code class="docutils literal notranslate"><span class="pre">GLOBAL_CONSTANT_NAME</span></code> ; 全局变量名: <code class="docutils literal notranslate"><span class="pre">global_var_name</span></code>; 实例名: <code class="docutils literal notranslate"><span class="pre">instance_var_name</span></code>; 函数参数名: <code class="docutils literal notranslate"><span class="pre">function_parameter_name</span></code>; 局部变量名: <code class="docutils literal notranslate"><span class="pre">local_var_name</span></code>.</p>
</div>
<p>函数名、变量名和文件名应该是描述性的, 避免缩写. 特别要避免那些对于项目之外的人有歧义或不熟悉的缩写, 也不要通过省略单词中的字母来进行缩写.</p>
<p>必须用 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 作为文件后缀名. 不要用连字符.</p>
<p><strong>需要避免的名称</strong></p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">只有单个字符的名称, 除了以下特别批准的情况:</p>
<blockquote>
<div><ol class="arabic simple">
<li>计数器和迭代器 (例如, <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code> 等等).</li>
<li>在 <code class="docutils literal notranslate"><span class="pre">try/except</span></code> 语句中代表异常的 <code class="docutils literal notranslate"><span class="pre">e</span></code>.</li>
<li>在 <code class="docutils literal notranslate"><span class="pre">with</span></code> 语句中代表文件句柄的 <code class="docutils literal notranslate"><span class="pre">f</span></code>.</li>
<li>私有的、没有约束 (constrain) 的类型变量 (type variable, 例如 <code class="docutils literal notranslate"><span class="pre">_T</span> <span class="pre">=</span> <span class="pre">TypeVar(&quot;_T&quot;)</span></code>, <code class="docutils literal notranslate"><span class="pre">_P</span> <span class="pre">=</span> <span class="pre">ParamSpec(&quot;_P&quot;)</span></code>).</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">包含连字符(<code class="docutils literal notranslate"><span class="pre">-</span></code>) 的包名/模块名.</p>
</li>
<li><p class="first">首尾均为双下划线的名称, 例如 <code class="docutils literal notranslate"><span class="pre">__double_leading_and_trailing_underscore__</span></code> (此类名称是 Python 的保留名称).</p>
</li>
<li><p class="first">包含冒犯性词语的名称.</p>
</li>
<li><p class="first">在不必要的情况下包含变量类型的名称 (例如 <code class="docutils literal notranslate"><span class="pre">id_to_name_dict</span></code>).</p>
</li>
</ol>
</div></blockquote>
<p><strong>命名规范</strong></p>
<blockquote>
<div><ol class="arabic simple">
<li>“内部(Internal)”这个词表示仅在模块内可用, 或者在类内是保护/私有的.</li>
<li>在一定程度上, 在名称前加单下划线 (<code class="docutils literal notranslate"><span class="pre">_</span></code>) 可以保护模块变量和函数 (格式检查器会对受保护的成员访问操作发出警告).</li>
<li>在实例的变量或方法名称前加双下划线 (<code class="docutils literal notranslate"><span class="pre">__</span></code>, 又名为 dunder) 可以有效地把变量或方法变成类的私有成员 (基于名称修饰 name mangling 机制). 我们不鼓励这种用法, 因为这会严重影响可读性和可测试性, 而且没有 <strong>真正</strong> 实现私有. 建议使用单下划线.</li>
<li>应该把相关的类和顶级函数放在同一个模块里. 与Java不同, 不必限制一个模块只有一个类.</li>
<li>类名应该使用首字母大写的形式 (如 CapWords), 但是模块名应该用小写加下划线的形式 (如 lower_with_under.py). 尽管有些旧的模块使用类似于 CapWords.py 这样的形式, 现在我们不再鼓励这种命名方式, 因为模块名和类名相同时会让人困惑 (“等等, 我刚刚写的是 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">StringIO</span></code> 还是 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">StringIO</span> <span class="pre">import</span> <span class="pre">StringIO</span></code>?”).</li>
<li>新的 <strong>单元测试</strong> 文件应该遵守 PEP 8, 用小写加下划线格式的方法名, 例如 <code class="docutils literal notranslate"><span class="pre">test_&lt;被测试的方法名&gt;_&lt;状态&gt;.</span></code>. 有些老旧的模块有 <code class="docutils literal notranslate"><span class="pre">CapWords</span></code> 这样大写方法名, 为了保持风格一致, 可以在 test 这个词和方法名之后, 用下划线分割名称中不同的逻辑成分. 比如一种可行的格式之一是 <code class="docutils literal notranslate"><span class="pre">test&lt;被测试的方法&gt;_&lt;状态&gt;</span></code>.</li>
</ol>
</div></blockquote>
<p><strong>文件名</strong></p>
<blockquote>
<div>所有 Python 文件名都应该以 <code class="docutils literal notranslate"><span class="pre">.py</span></code> 为文件后缀且不能包含连字符 (<code class="docutils literal notranslate"><span class="pre">-</span></code>). 这样便于导入这些文件并编写单元测试. 如果想通过不含后缀的命令运行程序, 可以使用软链接文件 (symbolic link) 或者 <code class="docutils literal notranslate"><span class="pre">exec</span> <span class="pre">&quot;$0.py&quot;</span> <span class="pre">&quot;$&#64;&quot;</span></code> 这样简单的 bash 脚本.</div></blockquote>
<p><strong>根据Python之父Guido的建议所制定的规范</strong></p>
<table border="1" class="docutils" id="table-1">
<caption><span class="caption-text">描述</span></caption>
<colgroup>
<col width="30%" />
<col width="30%" />
<col width="40%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">公有</th>
<th class="head">内部</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>包</td>
<td>小写下划线</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>模块</td>
<td>小写下划线</td>
<td>下划线+小写下划线</td>
</tr>
<tr class="row-even"><td>类</td>
<td>大驼峰</td>
<td>下划线+大驼峰</td>
</tr>
<tr class="row-odd"><td>异常</td>
<td>大驼峰</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>函数</td>
<td>小写下划线</td>
<td>下划线+小写下划线</td>
</tr>
<tr class="row-odd"><td>全局常量/类常量</td>
<td>大写下划线</td>
<td>下划线+大写下划线</td>
</tr>
<tr class="row-even"><td>全局变量/类变量</td>
<td>小写下划线</td>
<td>下划线+小写下划线</td>
</tr>
<tr class="row-odd"><td>实例变量</td>
<td>小写下划线</td>
<td>下划线+小写下划线 (受保护)</td>
</tr>
<tr class="row-even"><td>方法名</td>
<td>小写下划线</td>
<td>下划线+小写下划线 (受保护)</td>
</tr>
<tr class="row-odd"><td>函数参数/方法参数</td>
<td>小写下划线</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>局部变量</td>
<td>小写下划线</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="table-2">
<caption><span class="caption-text">例子</span></caption>
<colgroup>
<col width="30%" />
<col width="35%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">公有</th>
<th class="head">内部</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>包</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>模块</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">_lower_with_under</span></code></td>
</tr>
<tr class="row-even"><td>类</td>
<td><code class="docutils literal notranslate"><span class="pre">CapWords</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">_CapWords</span></code></td>
</tr>
<tr class="row-odd"><td>异常</td>
<td><code class="docutils literal notranslate"><span class="pre">CapWords</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>函数</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under()</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">_lower_with_under()</span></code></td>
</tr>
<tr class="row-odd"><td>全局常量/类常量</td>
<td><code class="docutils literal notranslate"><span class="pre">CAPS_WITH_UNDER</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">_CAPS_WITH_UNDER</span></code></td>
</tr>
<tr class="row-even"><td>全局变量/类变量</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">_lower_with_under</span></code></td>
</tr>
<tr class="row-odd"><td>实例变量</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">_lower_with_under</span></code></td>
</tr>
<tr class="row-even"><td>方法名</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under()</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">_lower_with_under()</span></code></td>
</tr>
<tr class="row-odd"><td>函数参数/方法参数</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under</span></code></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>局部变量</td>
<td><code class="docutils literal notranslate"><span class="pre">lower_with_under</span></code></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p><strong>数学符号</strong></p>
<p>对于涉及大量数学内容的代码, 如果相关论文或算法中有对应的符号, 则可以忽略以上命名规范并使用较短的变量名. 若要采用这种方法, 应该在注释或者文档字符串中注明你所使用的命名规范的来源. 如果原文无法访问, 则应该在文档中清楚地记录命名规范. 建议公开的 API 使用符合 PEP8 的、描述性的名称, 因为使用 API 的代码很可能缺少相关的上下文信息.</p>
</div>
<div class="section" id="section-10">
<h4>主程序</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 Python 时, 提供给 <code class="docutils literal notranslate"><span class="pre">pydoc</span></code> 和单元测试的模块必须是可导入的. 如果一个文件是可执行文件, 该文件的主要功能应该位于 <code class="docutils literal notranslate"><span class="pre">main()</span></code> 函数中. 你的代码必须在执行主程序前检查 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">__name__</span> <span class="pre">==</span> <span class="pre">'__main__'</span></code> , 这样导入模块时不会执行主程序.</p>
</div>
<p>使用 <a class="reference external" href="https://github.com/abseil/abseil-py">absl</a> 时, 请调用 <code class="docutils literal notranslate"><span class="pre">app.run</span></code> :</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">absl</span> <span class="kn">import</span> <span class="n">app</span>
<span class="o">...</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">argv</span><span class="p">):</span>
    <span class="c1"># 处理非标志 (non-flag) 参数</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">app</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</pre></div>
</div>
<p>否则, 使用:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="o">...</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<p>导入模块时会执行该模块的所有顶级代码. 注意顶级代码中不能有 <code class="docutils literal notranslate"><span class="pre">pydoc</span></code> 不该执行的操作, 比如调用函数, 创建对象等.</p>
</div>
<div class="section" id="section-11">
<h4>函数长度</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">函数应该小巧且专一.</p>
</div>
<p>我们承认有时长函数也是合理的, 所以不硬性限制函数长度. 若一个函数超过 40 行, 应该考虑在不破坏程序结构的前提下拆分这个函数.</p>
<p>即使一个长函数现在没有问题, 几个月后可能会有别人添加新的效果. 此时容易出现隐蔽的错误. 保持函数简练, 这样便于别人阅读并修改你的代码.</p>
<p>当你使用某些代码时, 可能发现一些冗长且复杂的函数. 要勇于修改现有的代码: 如果该函数难以使用或者存在难以调试的错误, 亦或是你想在不同场景下使用该函数的片段, 不妨考虑把函数拆分成更小、更容易管理的片段.</p>
</div>
<div class="section" id="type-annotation">
<h4>类型注解 (type annotation)</h4>
<p><strong>通用规则</strong></p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">熟读 <a class="reference external" href="https://www.python.org/dev/peps/pep-0484/">PEP-484</a> .</p>
</li>
<li><p class="first">仅在有额外类型信息时才需要注解方法中 <code class="docutils literal notranslate"><span class="pre">self</span></code> 或 <code class="docutils literal notranslate"><span class="pre">cls</span></code> 的类型. 例如:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@classmethod</span>
<span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">_T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">类似地, 不需要注解 <code class="docutils literal notranslate"><span class="pre">__init__</span></code> 的返回值 (只能返回 <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p>
</li>
<li><p class="first">对于其他不需要限制变量类型或返回类型的情况, 应该使用 <code class="docutils literal notranslate"><span class="pre">Any</span></code>.</p>
</li>
<li><p class="first">无需注解模块中的所有函数.</p>
<blockquote>
<div><ol class="arabic simple">
<li>至少需要注解你的公开 API.</li>
<li>你可以自行权衡, 一方面要保证代码的安全性和清晰性, 另一方面要兼顾灵活性.</li>
<li>应该注解那些容易出现类型错误的代码 (比如曾经出现过错误或疑难杂症).</li>
<li>应该注解晦涩难懂的代码.</li>
<li>应该注解那些类型已经确定的代码. 多数情况下，即使注解了成熟的代码中所有的函数，也不会丧失太多灵活性.</li>
</ol>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p><strong>换行</strong></p>
<blockquote>
<div><p>尽量遵守前文所述的缩进规则.</p>
<p>添加类型注解后, 很多函数签名 (signature) 会变成每行一个参数的形式. 若要让返回值单独成行, 可以在最后一个参数尾部添加逗号.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">first_var</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">second_var</span><span class="p">:</span> <span class="n">Foo</span><span class="p">,</span>
    <span class="n">third_var</span><span class="p">:</span> <span class="n">Bar</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>尽量在变量之间换行, 避免在变量和类型注解之间换行. 当然, 若所有东西可以挤进一行, 也可以接受.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_var</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>若最后一个参数加上返回值的类型注解太长, 也可以换行并添加4格缩进. 添加换行符时, 建议每个参数和返回值都在单独的一行里, 并且右括号和 <code class="docutils literal notranslate"><span class="pre">def</span></code> 对齐.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">other_arg</span><span class="p">:</span> <span class="n">MyLongType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">MyLongType1</span><span class="p">,</span> <span class="n">MyLongType1</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>返回值类型和最后一个参数也可以放在同一行.</p>
<p>可以接受:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">first_var</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">second_var</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">OtherLongType</span><span class="p">,</span> <span class="n">MyLongType</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pylint</span></code> 也允许你把右括号放在新行上, 与左括号对齐, 但相较而言可读性更差.</p>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
              <span class="n">other_arg</span><span class="p">:</span> <span class="n">MyLongType</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
             <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="n">OtherLongType</span><span class="p">,</span> <span class="n">MyLongType</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>正如上面所有的例子, 尽量不要在类型注解中间换行. 但是有时注解过长以至于一行放不下. 此时尽量保持子类型中间不换行.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">first_var</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">MyLongType1</span><span class="p">],</span>
                     <span class="nb">list</span><span class="p">[</span><span class="n">MyLongType2</span><span class="p">]],</span>
    <span class="n">second_var</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span>
        <span class="n">MyLongType3</span><span class="p">,</span> <span class="n">MyLongType4</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>若某个名称和对应的类型注解过长, 可以考虑用 <a class="reference internal" href="#type-alias"><span class="std std-ref">别名 (alias)</span></a> 代表类型. 下策是在冒号后换行并添加4格缩进.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span>
    <span class="n">long_variable_name</span><span class="p">:</span>
        <span class="n">long_module_name</span><span class="o">.</span><span class="n">LongTypeName</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">my_function</span><span class="p">(</span>
    <span class="n">long_variable_name</span><span class="p">:</span> <span class="n">long_module_name</span><span class="o">.</span>
        <span class="n">LongTypeName</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>前向声明 (foward declaration)</strong></p>
<blockquote>
<div><p>若需要使用一个尚未定义的类名 (比如想在声明一个类时使用自身的类名), 可以使用 <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">__future__</span> <span class="pre">import</span> <span class="pre">annotations</span></code> 或者字符串来代表类名.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">MyClass</span><span class="p">],</span> <span class="n">item</span><span class="p">:</span> <span class="n">OtherClass</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

<span class="k">class</span> <span class="nc">OtherClass</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stack</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="s1">&#39;MyClass&#39;</span><span class="p">],</span> <span class="n">item</span><span class="p">:</span> <span class="s1">&#39;OtherClass&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>

<span class="k">class</span> <span class="nc">OtherClass</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>默认值</strong></p>
<blockquote>
<div><p>根据 <a class="reference external" href="https://www.python.org/dev/peps/pep-0008/#other-recommendations">PEP-008</a> , <strong>只有</strong> 对于同时拥有类型注解和默认值的参数, <code class="docutils literal notranslate"><span class="pre">=</span></code> 的周围应该加空格.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">:</span><span class="nb">int</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>NoneType</strong></p>
<blockquote>
<div><p>在 Python 的类型系统中, <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> 是 “一等” 类型. 在类型注解中, <code class="docutils literal notranslate"><span class="pre">None</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> 的别名. 如果一个变量可能为 <code class="docutils literal notranslate"><span class="pre">None</span></code>, 则必须声明这种情况! 你可以使用 <code class="docutils literal notranslate"><span class="pre">|</span></code> 这样的联合 (union) 类型表达式 (推荐在新的 Python 3.10+ 代码中使用) 或者老的 <code class="docutils literal notranslate"><span class="pre">Optional</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Union</span></code> 语法.</p>
<p>应该用显式的 <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">|</span> <span class="pre">None</span></code> 替代隐式声明. 早期的 PEP 484 允许将 <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">None</span></code> 解释为 <code class="docutils literal notranslate"><span class="pre">a:</span> <span class="pre">str</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></code>, 但这不再是推荐的行为.</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 现代的联合写法.</span>
<span class="k">def</span> <span class="nf">modern_or_union</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="c1"># 采用 Union / Optional.</span>
<span class="k">def</span> <span class="nf">union_optional</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">b</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 用 Union 代替 Optional.</span>
<span class="k">def</span> <span class="nf">nullable_union</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="c1"># 隐式 Optional.</span>
<span class="k">def</span> <span class="nf">implicit_optional</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p id="type-alias"><strong>类型别名 (alias)</strong></p>
<blockquote>
<div><p>你可以为复杂的类型声明一个别名. 别名的命名应该采用大驼峰 (例如 <code class="docutils literal notranslate"><span class="pre">CapWorded</span></code>). 若别名仅在当前模块使用, 应在名称前加 <code class="docutils literal notranslate"><span class="pre">_</span></code> 代表私有 (例如 <code class="docutils literal notranslate"><span class="pre">_Private</span></code>).</p>
<p>注意下面的 <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">TypeAlias</span></code> 类型注解只能在 3.10 以后的版本使用.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeAlias</span>

<span class="n">_LossAndGradient</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
<span class="n">ComplexTFMap</span><span class="p">:</span> <span class="n">TypeAlias</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">_LossAndGradient</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>忽略类型</strong></p>
<blockquote>
<div><p>你可以使用特殊的注释 <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span> <span class="pre">ignore</span></code> 禁用某一行的类型检查.</p>
<p><code class="docutils literal notranslate"><span class="pre">pytype</span></code> 有针对特定错误的禁用选项 (类似格式检查器):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pytype: disable=attribute-error</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>标注变量的类型</strong></p>
<blockquote>
<div><p><strong>带类型注解的赋值</strong></p>
<p>如果难以自动推理某个内部变量的类型, 可以用带类型注解的赋值操作来指定类型: 在变量名和值的中间添加冒号和类型, 类似于有默认值的函数参数.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">:</span> <span class="n">Foo</span> <span class="o">=</span> <span class="n">SomeUndecoratedFunction</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>类型注释</strong></p>
<p>你可能在代码仓库中看到这种残留的注释 (在 Python 3.6 之前必须这样写注释), 但是不要再添加 <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">type:</span> <span class="pre">&lt;类型&gt;</span></code> 这样的行尾注释了:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">SomeUndecoratedFunction</span><span class="p">()</span>  <span class="c1"># type: Foo</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<p><strong>元组还是列表</strong></p>
<blockquote>
<div><p>有类型的列表中只能有一种类型的元素. 有类型的元组可以有相同类型的元素或者若干个不同类型的元素. 后面这种情况多用于注解返回值的类型.</p>
<p>(译者注: 注意这里是指的类型注解中的写法,实际python中,list和tuple都是可以在一个序列中包含不同类型元素的,当然,本质其实list和tuple中放的是元素的引用)</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">b</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">c</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>类型变量 (type variable)</strong></p>
<blockquote>
<div><p>Python 的类型系统支持 <a class="reference external" href="https://peps.python.org/pep-0484/#generics">泛型 (generics)</a> . 使用泛型的常见方式是利用类型变量, 例如 <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ParamSpec</span></code>.</p>
<p>例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">TypeVar</span>
<span class="n">_P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;_P&quot;</span><span class="p">)</span>
<span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_T&quot;</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">_T</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">print_when_called</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="n">_P</span><span class="p">,</span> <span class="n">_T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="n">_P</span><span class="p">,</span> <span class="n">_T</span><span class="p">]:</span>
    <span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">P</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">R</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;函数被调用&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="k">return</span> <span class="n">inner</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> 可以有约束条件.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">AddableType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;AddableType&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">AddableType</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">AddableType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AddableType</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AnyStr</span></code> 是 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块中常用的预定义类型变量. 可以用它注解那些接受 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 或 <code class="docutils literal notranslate"><span class="pre">str</span></code> 但是必须保持一致的类型.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">AnyStr</span>
<span class="k">def</span> <span class="nf">check_length</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">42</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">()</span>
</pre></div>
</div>
<p>(译者注: 这个例子中, x 和返回值必须同时是 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 或者同时是 <code class="docutils literal notranslate"><span class="pre">str</span></code>.)</p>
<p>类型变量必须有描述性的名称, 除非满足以下所有标准:</p>
<ol class="arabic simple">
<li>外部不可见</li>
<li>没有约束条件</li>
</ol>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_T&quot;</span><span class="p">)</span>
<span class="n">_P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;_P&quot;</span><span class="p">)</span>
<span class="n">AddableType</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;AddableType&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="n">AnyFunction</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;AnyFunction&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Callable</span><span class="p">)</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">ParamSpec</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">)</span>
<span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_T&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
<span class="n">_F</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_F&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Callable</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>字符串类型</strong></p>
<blockquote>
<div><p>不要在新代码中使用 <code class="docutils literal notranslate"><span class="pre">typing.Text</span></code>. 这种写法只能用于处理 Python 2/3 的兼容问题.</p>
<p>用 <code class="docutils literal notranslate"><span class="pre">str</span></code> 表示字符串/文本数据. 用 <code class="docutils literal notranslate"><span class="pre">bytes</span></code> 处理二进制数据.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 处理文本数据</span>
<span class="k">def</span> <span class="nf">deals_with_text_data</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="o">...</span>
<span class="c1"># 处理二进制数据</span>
<span class="k">def</span> <span class="nf">deals_with_binary_data</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>若一个函数中的字串类型始终一致, 比如上述代码中返回值类型和参数类型相同, 应该使用 <a class="reference external" href="https://google.github.io/styleguide/pyguide.html#typing-type-var">AnyStr</a>.</p>
</div></blockquote>
<p id="typing-imports"><strong>导入类型</strong></p>
<blockquote>
<div><p>为了静态分析和类型检查而导入 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 和 <code class="docutils literal notranslate"><span class="pre">collections.abc</span></code> 模块中的符号时, 一定要导入符号本身. 这样常用的类型注解更简洁, 也符合全世界的习惯. 特别地, 你可以在一行内从 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 和 <code class="docutils literal notranslate"><span class="pre">collections.abc</span></code> 模块中导入多个特定的类, 例如:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Generic</span>
</pre></div>
</div>
<p>采用这种方法时, 导入的类会进入本地命名空间, 因此所有 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 和 <code class="docutils literal notranslate"><span class="pre">collections.abc</span></code> 模块中的名称都应该和关键词 (keyword) 同等对待. 你不能在自己的代码中定义相同的名字, 无论你是否采用类型注解. 若类型名和某模块中已有的名称出现冲突, 可以用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">x</span> <span class="pre">as</span> <span class="pre">y</span></code> 的导入形式:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span> <span class="k">as</span> <span class="n">AnyType</span>
</pre></div>
</div>
<p>只要可行, 就使用内置类型. 利用 Python 3.9 引入的 <a class="reference external" href="https://peps.python.org/pep-0585/">PEP-585</a>, 可以在类型注解中使用参数化的容器类型.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_foo_scores</span><span class="p">(</span><span class="n">foo</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>注意: <a class="reference external" href="https://github.com/apache/beam/issues/23366">Apache Beam</a> 的用户应该继续导入 <code class="docutils literal notranslate"><span class="pre">typing</span></code> 模块提供的参数化容器类型.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Set</span><span class="p">,</span> <span class="n">List</span>

<span class="c1"># 只有在你使用了 Apache Beam 这样没有为 PEP 585 更新的代码, 或者你的</span>
<span class="c1"># 代码需要在 Python 3.9 以下版本中运行时, 才能使用这种旧风格.</span>
<span class="k">def</span> <span class="nf">generate_foo_scores</span><span class="p">(</span><span class="n">foo</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>有条件的导入</strong></p>
<blockquote>
<div><p>仅在一些特殊情况下, 比如必须在运行时避免导入类型检查所需的模块时, 才能有条件地导入. 不推荐这种写法. 替代方案是重构代码, 使类型检查所需的模块可以在顶层导入.</p>
<p>可以把仅用于类型注解的导入放在 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">TYPE_CHECKING:</span></code> 语句块内.</p>
<ol class="arabic simple">
<li>在类型注解中, 有条件地导入的类型必须用字符串表示, 这样才能和 Python 3.6 之前的代码兼容. 因为 Python 3.6 之前真的会对类型注解求值.</li>
<li>只有那些仅仅用于类型注解的实例才能有条件地导入, 别名也是如此. 否则会引发运行时错误, 因为运行时不会导入这些模块.</li>
<li>有条件的导入语句应紧随所有常规导入语句之后.</li>
<li>有条件的导入语句之间不能有空行.</li>
<li>和常规导入一样, 请对有条件的导入语句排序.</li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">typing</span>
<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">sketch</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="s2">&quot;sketch.Sketch&quot;</span><span class="p">):</span> <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>循环依赖</strong></p>
<blockquote>
<div><p>若类型注解引发了循环依赖, 说明代码可能存在问题. 这样的代码适合重构. 虽然技术上我们可以支持循环依赖, 但是很多构建系统 (build system) 不支持.</p>
<p>可以用 <code class="docutils literal notranslate"><span class="pre">Any</span></code> 替换引起循环依赖的模块. 起一个有意义的别名, 然后使用模块中的真实类型名 (Any 的任何属性依然是 Any). 定义别名的语句应该和最后一行导入语句之间间隔一行.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>

<span class="n">some_mod</span> <span class="o">=</span> <span class="n">Any</span>  <span class="c1"># 因为 some_mod.py 导入了我们的模块.</span>
<span class="o">...</span>

<span class="k">def</span> <span class="nf">my_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;some_mod.SomeType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>泛型 (generics)</strong></p>
<blockquote>
<div><p>在注解类型时, 尽量为泛型类型填入类型参数. 否则, <a class="reference external" href="https://www.python.org/dev/peps/pep-0484/#the-any-type">泛型参数默认为 Any</a> .</p>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_names</span><span class="p">(</span><span class="n">employee_ids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># 这表示 get_names(employee_ids: Sequence[Any]) -&gt; Mapping[Any, Any]</span>
<span class="k">def</span> <span class="nf">get_names</span><span class="p">(</span><span class="n">employee_ids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>如果泛型类型的参数的确应该是 <code class="docutils literal notranslate"><span class="pre">Any</span></code>, 请显式地标注, 不过注意 <code class="docutils literal notranslate"><span class="pre">TypeVar</span></code> 很可能更合适.</p>
<p>错误:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_names</span><span class="p">(</span><span class="n">employee_ids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;返回员工ID到员工名的映射.&quot;&quot;&quot;</span>
</pre></div>
</div>
<p>正确:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;_T&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_names</span><span class="p">(</span><span class="n">employee_ids</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">_T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">_T</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;返回员工ID到员工名的映射.&quot;&quot;&quot;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<span id="document-google-python-styleguide/parting_words"></span><div class="section" id="section-1">
<h3>临别赠言</h3>
<p><strong>务必保持一致性.</strong></p>
<p>编辑代码时, 请花几分钟观察一下周边代码的风格. 如果这些代码在所有运算符的周围加上了空格, 那么你也应该这样做. 如果这些代码的注释都用井号形成的框包围起来, 那么你的注释也要用井号形成的框包起来.</p>
<p>制定风格指南是为了像字典一样让代码有章可循. 这样人们可以专注于”写什么”, 而不是纠结”怎么写”. 我们在这里列出的全局规范就像字典, 但是局部的规范同样重要. 如果你添加的代码和周围原有的代码大相径庭, 就会打乱读者的阅读节奏. 不要这样.</p>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/contents"></span><div class="section" id="shell">
<span id="shell-contents"></span><h2>Shell 风格指南 - 内容目录</h2>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#shell" id="toc-entry-1">Shell 风格指南 - 内容目录</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
<span id="document-google-shell-styleguide/index"></span><div class="section" id="section-1">
<h3>扉页</h3>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">版本:</th><td class="field-body"><p class="first">1.26</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">原作者:</th><td class="field-body"><div class="first line-block">
<div class="line">Paul Armstrong</div>
<div class="line">等等</div>
</div>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">翻译:</th><td class="field-body"><div class="first line-block">
<div class="line"><a class="reference external" href="http://87boy.me/">Bean Zhang</a> v1.26</div>
</div>
</td>
</tr>
<tr class="field-even field"><th class="field-name">项目主页:</th><td class="field-body"><ul class="first last simple">
<li><a class="reference external" href="https://github.com/google/styleguide">Google Style Guide</a></li>
<li><a class="reference external" href="http://github.com/zh-google-styleguide/zh-google-styleguide">Google 开源项目风格指南 - 中文版</a></li>
</ul>
</td>
</tr>
</tbody>
</table>
</div>
<span id="document-google-shell-styleguide/background"></span><div class="section" id="section-1">
<h3>背景</h3>
<div class="section" id="shell">
<h4>使用哪一种Shell</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Bash是唯一被允许执行的shell脚本语言。</p>
</div>
<p>可执行文件必须以 <code class="docutils literal notranslate"><span class="pre">#!/bin/bash</span></code> 和最小数量的标志开始。请使用 <code class="docutils literal notranslate"><span class="pre">set</span></code> 来设置shell的选项，使得用 <code class="docutils literal notranslate"><span class="pre">bash</span> <span class="pre">&lt;script_name&gt;</span></code> 调用你的脚本时不会破坏其功能。</p>
<p>限制所有的可执行shell脚本为bash使得我们安装在所有计算机中的shell语言保持一致性。</p>
<p>无论你是为什么而编码，对此唯一例外的是当你被迫时可以不这么做的。其中一个例子是Solaris SVR4包，编写任何脚本都需要用纯Bourne shell。</p>
</div>
<div class="section" id="shell-1">
<h4>什么时候使用Shell</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Shell应该仅仅被用于小功能或者简单的包装脚本。</p>
</div>
<p>尽管Shell脚本不是一种开发语言，但在整个谷歌它被用于编写多种实用工具的脚本。这个风格指南更多的是认同它的使用，而不是一个建议，即它可被用于广泛部署。</p>
<p>以下是一些准则：</p>
<ul class="simple">
<li>如果你主要是在调用其他的工具并且做一些相对很小数据量的操作，那么使用shell来完成任务是一种可接受的选择。</li>
<li>如果你在乎性能，那么请选择其他工具，而不是使用shell。</li>
<li>如果你发现你需要使用数据而不是变量赋值（如 <code class="docutils literal notranslate"><span class="pre">${PHPESTATUS}</span></code> ），那么你应该使用Python脚本。</li>
<li>如果你将要编写的脚本会超过100行，那么你可能应该使用Python来编写，而不是Shell。请记住，当脚本行数增加，尽早使用另外一种语言重写你的脚本，以避免之后花更多的时间来重写。</li>
</ul>
</div>
</div>
<span id="document-google-shell-styleguide/shell_files_and_interpreter_invocation"></span><div class="section" id="shell">
<h3>Shell文件和解释器调用</h3>
<div class="section" id="section-1">
<h4>文件扩展名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可执行文件应该没有扩展名（强烈建议）或者使用.sh扩展名。库文件必须使用.sh作为扩展名，而且应该是不可执行的。</p>
</div>
<p>当执行一个程序时，并不需要知道它是用什么语言编写的。而且shell脚本也不要求有扩展名。所以我们更喜欢可执行文件没有扩展名。</p>
<p>然而，对于库文件，知道其用什么语言编写的是很重要的，有时候会需要使用不同语言编写的相似的库文件。使用.sh这样特定语言后缀作为扩展名，就使得用不同语言编写的具有相同功能的库文件可以采用一样的名称。</p>
</div>
<div class="section" id="suid-sgid">
<h4>SUID / SGID</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">SUID(Set User ID)和SGID(Set Group ID)在shell脚本中是被禁止的。</p>
</div>
<p>shell存在太多的安全问题，以致于如果允许SUID/SGID会使得shell几乎不可能足够安全。虽然bash使得运行SUID非常困难，但在某些平台上仍然有可能运行，这就是为什么我们明确提出要禁止它。</p>
<p>如果你需要较高权限的访问请使用 <code class="docutils literal notranslate"><span class="pre">sudo</span></code> 。</p>
</div>
</div>
<span id="document-google-shell-styleguide/environment"></span><div class="section" id="section-1">
<h3>环境</h3>
<div class="section" id="stdout-vs-stderr">
<h4>STDOUT vs STDERR</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">所有的错误信息都应该被导向STDERR。</p>
</div>
<p>这使得从实际问题中分离出正常状态变得更容易。</p>
<p>推荐使用类似如下函数，将错误信息和其他状态信息一起打印出来。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>err<span class="o">()</span> <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">&quot;[</span><span class="k">$(</span>date +<span class="s1">&#39;%Y-%m-%dT%H:%M:%S%z&#39;</span><span class="k">)</span><span class="s2">]: </span><span class="nv">$@</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
<span class="o">}</span>

<span class="k">if</span> ! do_something<span class="p">;</span> <span class="k">then</span>
    err <span class="s2">&quot;Unable to do_something&quot;</span>
    <span class="nb">exit</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">E_DID_NOTHING</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/comments"></span><div class="section" id="section-1">
<h3>注释</h3>
<div class="section" id="section-2">
<h4>文件头</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">每个文件的开头是其文件内容的描述。</p>
</div>
<p>每个文件必须包含一个顶层注释，对其内容进行简要概述。版权声明和作者信息是可选的。</p>
<p>例如：</p>
<blockquote>
<div><div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># Perform hot backups of Oracle databases.</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="section-3">
<h4>功能注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">任何不是既明显又短的函数都必须被注释。任何库函数无论其长短和复杂性都必须被注释。</p>
</div>
<p>其他人通过阅读注释（和帮助信息，如果有的话）就能够学会如何使用你的程序或库函数，而不需要阅读代码。</p>
<p>所有的函数注释应该包含：</p>
<ul class="simple">
<li>函数的描述</li>
<li>全局变量的使用和修改</li>
<li>使用的参数说明</li>
<li>返回值，而不是上一条命令运行后默认的退出状态</li>
</ul>
<p>例如：</p>
<blockquote>
<div><div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>
<span class="c1">#</span>
<span class="c1"># Perform hot backups of Oracle databases.</span>

<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="s1">&#39;/usr/xpg4/bin:/usr/bin:/opt/csw/bin:/opt/goog/bin&#39;</span>

<span class="c1">#######################################</span>
<span class="c1"># Cleanup files from the backup dir</span>
<span class="c1"># Globals:</span>
<span class="c1">#   BACKUP_DIR</span>
<span class="c1">#   ORACLE_SID</span>
<span class="c1"># Arguments:</span>
<span class="c1">#   None</span>
<span class="c1"># Returns:</span>
<span class="c1">#   None</span>
<span class="c1">#######################################</span>
cleanup<span class="o">()</span> <span class="o">{</span>
  ...
<span class="o">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="section-4">
<h4>实现部分的注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">注释你代码中含有技巧、不明显、有趣的或者重要的部分。</p>
</div>
<p>这部分遵循谷歌代码注释的通用做法。不要注释所有代码。如果有一个复杂的算法或者你正在做一些与众不同的，放一个简单的注释。</p>
</div>
<div class="section" id="todo">
<h4>TODO注释</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用TODO注释临时的、短期解决方案的、或者足够好但不够完美的代码。</p>
</div>
<p>这与C++指南中的约定相一致。</p>
<p>TODOs应该包含全部大写的字符串TODO，接着是括号中你的用户名。冒号是可选的。最好在TODO条目之后加上 bug或者ticket 的序号。</p>
<p>例如：</p>
<blockquote>
<div><div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># TODO(mrmonkey): Handle the unlikely edge cases (bug ####)</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<span id="document-google-shell-styleguide/formatting"></span><div class="section" id="section-1">
<h3>格式</h3>
<div class="section" id="section-2">
<h4>缩进</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">缩进两个空格，没有制表符。</p>
</div>
<p>在代码块之间请使用空行以提升可读性。缩进为两个空格。无论你做什么，请不要使用制表符。对于已有文件，保持已有的缩进格式。</p>
</div>
<div class="section" id="section-3">
<h4>行的长度和长字符串</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">行的最大长度为80个字符。</p>
</div>
<p>如果你必须写长度超过80个字符的字符串，如果可能的话，尽量使用here document或者嵌入的换行符。长度超过80个字符的文字串且不能被合理地分割，这是正常的。但强烈建议找到一个方法使其变短。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># DO use &#39;here document&#39;s</span>
cat <span class="s">&lt;&lt;END;</span>
<span class="s">I am an exceptionally long</span>
<span class="s">string.</span>
<span class="s">END</span>

<span class="c1"># Embedded newlines are ok too</span>
<span class="nv">long_string</span><span class="o">=</span><span class="s2">&quot;I am an exceptionally</span>
<span class="s2">  long string.&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>管道</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如果一行容不下整个管道操作，那么请将整个管道操作分割成每行一个管段。</p>
</div>
<p>如果一行容得下整个管道操作，那么请将整个管道操作写在同一行。</p>
<p>否则，应该将整个管道操作分割成每行一个管段，管道操作的下一部分应该将管道符放在新行并且缩进2个空格。这适用于使用管道符’|’的合并命令链以及使用’||’和’&amp;&amp;’的逻辑运算链。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># All fits on one line</span>
command1 <span class="p">|</span> command2

<span class="c1"># Long commands</span>
command1 <span class="se">\</span>
  <span class="p">|</span> command2 <span class="se">\</span>
  <span class="p">|</span> command3 <span class="se">\</span>
  <span class="p">|</span> command4
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>循环</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">请将 <code class="docutils literal notranslate"><span class="pre">;</span> <span class="pre">do</span></code> , <code class="docutils literal notranslate"><span class="pre">;</span> <span class="pre">then</span></code> 和 <code class="docutils literal notranslate"><span class="pre">while</span></code> , <code class="docutils literal notranslate"><span class="pre">for</span></code> , <code class="docutils literal notranslate"><span class="pre">if</span></code> 放在同一行。</p>
</div>
<p>shell中的循环略有不同，但是我们遵循跟声明函数时的大括号相同的原则。也就是说， <code class="docutils literal notranslate"><span class="pre">;</span> <span class="pre">do</span></code> , <code class="docutils literal notranslate"><span class="pre">;</span> <span class="pre">then</span></code> 应该和 if/for/while 放在同一行。 <code class="docutils literal notranslate"><span class="pre">else</span></code> 应该单独一行，结束语句应该单独一行并且跟开始语句垂直对齐。</p>
<p>例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> dir in <span class="si">${</span><span class="nv">dirs_to_cleanup</span><span class="si">}</span><span class="p">;</span> <span class="k">do</span>
  <span class="k">if</span> <span class="o">[[</span> -d <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    log_date <span class="s2">&quot;Cleaning up old files in </span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">&quot;</span>
    rm <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">/&quot;</span>*
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
      error_message
    <span class="k">fi</span>
  <span class="k">else</span>
    mkdir -p <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">ORACLE_SID</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
      error_message
    <span class="k">fi</span>
  <span class="k">fi</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
<div class="section" id="case">
<h4>case语句</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<ul class="last simple">
<li>通过2个空格缩进可选项。</li>
<li>在同一行可选项的模式右圆括号之后和结束符 <code class="docutils literal notranslate"><span class="pre">;;</span></code> 之前各需要一个空格。</li>
<li>长可选项或者多命令可选项应该被拆分成多行，模式、操作和结束符 <code class="docutils literal notranslate"><span class="pre">;;</span></code> 在不同的行。</li>
</ul>
</div>
<p>匹配表达式比 <code class="docutils literal notranslate"><span class="pre">case</span></code> 和 <code class="docutils literal notranslate"><span class="pre">esac</span></code> 缩进一级。多行操作要再缩进一级。一般情况下，不需要引用匹配表达式。模式表达式前面不应该出现左括号。避免使用 <code class="docutils literal notranslate"><span class="pre">;&amp;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">;;&amp;</span></code> 符号。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">expression</span><span class="si">}</span><span class="s2">&quot;</span> in
  a<span class="o">)</span>
    <span class="nv">variable</span><span class="o">=</span><span class="s2">&quot;...&quot;</span>
    some_command <span class="s2">&quot;</span><span class="si">${</span><span class="nv">variable</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">other_expr</span><span class="si">}</span><span class="s2">&quot;</span> ...
    <span class="p">;;</span>
  absolute<span class="o">)</span>
    <span class="nv">actions</span><span class="o">=</span><span class="s2">&quot;relative&quot;</span>
    another_command <span class="s2">&quot;</span><span class="si">${</span><span class="nv">actions</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">other_expr</span><span class="si">}</span><span class="s2">&quot;</span> ...
    <span class="p">;;</span>
  *<span class="o">)</span>
    error <span class="s2">&quot;Unexpected expression &#39;</span><span class="si">${</span><span class="nv">expression</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
    <span class="p">;;</span>
<span class="k">esac</span>
</pre></div>
</div>
<p>只要整个表达式可读，简单的命令可以跟模式和 <code class="docutils literal notranslate"><span class="pre">;;</span></code> 写在同一行。这通常适用于单字母选项的处理。当单行容不下操作时，请将模式单独放一行，然后是操作，最后结束符 <code class="docutils literal notranslate"><span class="pre">;;</span></code> 也单独一行。当操作在同一行时，模式的右括号之后和结束符 <code class="docutils literal notranslate"><span class="pre">;;</span></code> 之前请使用一个空格分隔。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">verbose</span><span class="o">=</span><span class="s1">&#39;false&#39;</span>
<span class="nv">aflag</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="nv">bflag</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="nv">files</span><span class="o">=</span><span class="s1">&#39;&#39;</span>
<span class="k">while</span> <span class="nb">getopts</span> <span class="s1">&#39;abf:v&#39;</span> flag<span class="p">;</span> <span class="k">do</span>
  <span class="k">case</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span> in
    a<span class="o">)</span> <span class="nv">aflag</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
    b<span class="o">)</span> <span class="nv">bflag</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
    f<span class="o">)</span> <span class="nv">files</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">OPTARG</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;;</span>
    v<span class="o">)</span> <span class="nv">verbose</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
    *<span class="o">)</span> error <span class="s2">&quot;Unexpected option </span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">;;</span>
  <span class="k">esac</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h4>变量扩展</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">按优先级顺序：保持跟你所发现的一致；引用你的变量；推荐用 <code class="docutils literal notranslate"><span class="pre">${var}</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">$var</span></code> ，详细解释如下。</p>
</div>
<p>这些仅仅是指南，因为作为强制规定似乎饱受争议。</p>
<p>以下按照优先顺序列出。</p>
<ol class="arabic simple">
<li>与现存代码中你所发现的保持一致。</li>
<li>引用变量参阅下面一节，引用。</li>
<li>除非绝对必要或者为了避免深深的困惑，否则不要用大括号将单个字符的shell特殊变量或定位变量括起来。推荐将其他所有变量用大括号括起来。</li>
</ol>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Section of recommended cases.</span>

<span class="c1"># Preferred style for &#39;special&#39; variables:</span>
<span class="nb">echo</span> <span class="s2">&quot;Positional: </span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$5</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$3</span><span class="s2">&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;Specials: !=</span><span class="nv">$!</span><span class="s2">, -=</span><span class="nv">$-</span><span class="s2">, _=</span><span class="nv">$_</span><span class="s2">. ?=</span><span class="nv">$?</span><span class="s2">, #=</span><span class="nv">$#</span><span class="s2"> *=</span><span class="nv">$*</span><span class="s2"> @=</span><span class="nv">$@</span><span class="s2"> \$=</span><span class="nv">$$</span><span class="s2"> ...&quot;</span>

<span class="c1"># Braces necessary:</span>
<span class="nb">echo</span> <span class="s2">&quot;many parameters: </span><span class="si">${</span><span class="nv">10</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Braces avoiding confusion:</span>
<span class="c1"># Output is &quot;a0b0c0&quot;</span>
<span class="nb">set</span> -- a b c
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="si">}</span><span class="s2">0</span><span class="si">${</span><span class="nv">2</span><span class="si">}</span><span class="s2">0</span><span class="si">${</span><span class="nv">3</span><span class="si">}</span><span class="s2">0&quot;</span>

<span class="c1"># Preferred style for other variables:</span>
<span class="nb">echo</span> <span class="s2">&quot;PATH=</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}</span><span class="s2">, PWD=</span><span class="si">${</span><span class="nv">PWD</span><span class="si">}</span><span class="s2">, mine=</span><span class="si">${</span><span class="nv">some_var</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">while</span> <span class="nb">read</span> f<span class="p">;</span> <span class="k">do</span>
  <span class="nb">echo</span> <span class="s2">&quot;file=</span><span class="si">${</span><span class="nv">f</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span> &lt; &lt;<span class="o">(</span>ls -l /tmp<span class="o">)</span>

<span class="c1"># Section of discouraged cases</span>

<span class="c1"># Unquoted vars, unbraced vars, brace-quoted single letter</span>
<span class="c1"># shell specials.</span>
<span class="nb">echo</span> <span class="nv">a</span><span class="o">=</span><span class="nv">$avar</span> <span class="s2">&quot;b=</span><span class="nv">$bvar</span><span class="s2">&quot;</span> <span class="s2">&quot;PID=</span><span class="si">${</span>$<span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">1</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Confusing use: this is expanded as &quot;${1}0${2}0${3}0&quot;,</span>
<span class="c1"># not &quot;${10}${20}${30}</span>
<span class="nb">set</span> -- a b c
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$10$20$30</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<h4>引用</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<ul class="simple">
<li>除非需要小心不带引用的扩展，否则总是引用包含变量、命令替换符、空格或shell元字符的字符串。</li>
<li>推荐引用是单词的字符串（而不是命令选项或者路径名）。</li>
<li>千万不要引用整数。</li>
<li>注意 <code class="docutils literal notranslate"><span class="pre">[[</span></code> 中模式匹配的引用规则。</li>
<li>请使用 <code class="docutils literal notranslate"><span class="pre">$&#64;</span></code> 除非你有特殊原因需要使用 <code class="docutils literal notranslate"><span class="pre">$*</span></code> 。</li>
</ul>
<div class="last highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># &#39;Single&#39; quotes indicate that no substitution is desired.</span>
<span class="c1"># &quot;Double&quot; quotes indicate that substitution is required/tolerated.</span>

<span class="c1"># Simple examples</span>
<span class="c1"># &quot;quote command substitutions&quot;</span>
<span class="nv">flag</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>some_command and its args <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span> <span class="s1">&#39;quoted separately&#39;</span><span class="k">)</span><span class="s2">&quot;</span>

<span class="c1"># &quot;quote variables&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># &quot;never quote literal integers&quot;</span>
<span class="nv">value</span><span class="o">=</span><span class="m">32</span>
<span class="c1"># &quot;quote command substitutions&quot;, even when you expect integers</span>
<span class="nv">number</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>generate_number<span class="k">)</span><span class="s2">&quot;</span>

<span class="c1"># &quot;prefer quoting words&quot;, not compulsory</span>
<span class="nb">readonly</span> <span class="nv">USE_INTEGER</span><span class="o">=</span><span class="s1">&#39;true&#39;</span>

<span class="c1"># &quot;quote shell meta characters&quot;</span>
<span class="nb">echo</span> <span class="s1">&#39;Hello stranger, and well met. Earn lots of $$$&#39;</span>
<span class="nb">echo</span> <span class="s2">&quot;Process </span><span class="nv">$$</span><span class="s2">: Done making \$\$\$.&quot;</span>

<span class="c1"># &quot;command options or path names&quot;</span>
<span class="c1"># ($1 is assumed to contain a value here)</span>
grep -li Hugo /dev/null <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

<span class="c1"># Less simple examples</span>
<span class="c1"># &quot;quote variables, unless proven false&quot;: ccs might be empty</span>
git send-email --to <span class="s2">&quot;</span><span class="si">${</span><span class="nv">reviewers</span><span class="si">}</span><span class="s2">&quot;</span> <span class="si">${</span><span class="nv">ccs</span><span class="p">:+</span><span class="s2">&quot;--cc&quot;</span><span class="p"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">ccs</span><span class="si">}</span><span class="s2">&quot;</span><span class="si">}</span>

<span class="c1"># Positional parameter precautions: $1 might be unset</span>
<span class="c1"># Single quotes leave regex as-is.</span>
grep -cP <span class="s1">&#39;([Ss]pecial|\|?characters*)$&#39;</span> <span class="si">${</span><span class="nv">1</span><span class="p">:+</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span><span class="si">}</span>

<span class="c1"># For passing on arguments,</span>
<span class="c1"># &quot;$@&quot; is right almost everytime, and</span>
<span class="c1"># $* is wrong almost everytime:</span>
<span class="c1">#</span>
<span class="c1"># * $* and $@ will split on spaces, clobbering up arguments</span>
<span class="c1">#   that contain spaces and dropping empty strings;</span>
<span class="c1"># * &quot;$@&quot; will retain arguments as-is, so no args</span>
<span class="c1">#   provided will result in no args being passed on;</span>
<span class="c1">#   This is in most cases what you want to use for passing</span>
<span class="c1">#   on arguments.</span>
<span class="c1"># * &quot;$*&quot; expands to one argument, with all args joined</span>
<span class="c1">#   by (usually) spaces,</span>
<span class="c1">#   so no args provided will result in one empty string</span>
<span class="c1">#   being passed on.</span>
<span class="c1"># (Consult &#39;man bash&#39; for the nit-grits ;-)</span>

<span class="nb">set</span> -- <span class="m">1</span> <span class="s2">&quot;2 two&quot;</span> <span class="s2">&quot;3 three tres&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="nv">$#</span> <span class="p">;</span> <span class="nb">set</span> -- <span class="s2">&quot;</span><span class="nv">$*</span><span class="s2">&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$#</span><span class="s2">, </span><span class="nv">$@</span><span class="s2">&quot;</span><span class="o">)</span>
<span class="nb">set</span> -- <span class="m">1</span> <span class="s2">&quot;2 two&quot;</span> <span class="s2">&quot;3 three tres&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="nv">$#</span> <span class="p">;</span> <span class="nb">set</span> -- <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span><span class="p">;</span> <span class="nb">echo</span> <span class="s2">&quot;</span><span class="nv">$#</span><span class="s2">, </span><span class="nv">$@</span><span class="s2">&quot;</span><span class="o">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/features_and_bugs"></span><div class="section" id="section-1">
<h3>特性及错误</h3>
<div class="section" id="section-2">
<h4>命令替换</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal notranslate"><span class="pre">$(command)</span></code> 而不是反引号。</p>
</div>
<p>嵌套的反引号要求用反斜杠转义内部的反引号。而 <code class="docutils literal notranslate"><span class="pre">$(command)</span></code> 形式嵌套时不需要改变，而且更易于阅读。</p>
<p>例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># This is preferred:</span>
<span class="nv">var</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span><span class="nb">command</span> <span class="s2">&quot;</span><span class="k">$(</span>command1<span class="k">)</span><span class="s2">&quot;</span><span class="k">)</span><span class="s2">&quot;</span>

<span class="c1"># This is not:</span>
<span class="nv">var</span><span class="o">=</span><span class="s2">&quot;`command \`command1\``&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="test">
<h4>test，[和[[</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">推荐使用 <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">...</span> <span class="pre">]]</span></code> ，而不是 <code class="docutils literal notranslate"><span class="pre">[</span></code> , <code class="docutils literal notranslate"><span class="pre">test</span></code> , 和 <code class="docutils literal notranslate"><span class="pre">/usr/bin/[</span></code> 。</p>
</div>
<p>因为在 <code class="docutils literal notranslate"><span class="pre">[[</span></code> 和 <code class="docutils literal notranslate"><span class="pre">]]</span></code> 之间不会有路径名称扩展或单词分割发生，所以使用 <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">...</span> <span class="pre">]]</span></code> 能够减少错误。而且 <code class="docutils literal notranslate"><span class="pre">[[</span> <span class="pre">...</span> <span class="pre">]]</span></code> 允许正则表达式匹配，而 <code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">...</span> <span class="pre">]</span></code> 不允许。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># This ensures the string on the left is made up of characters in the</span>
<span class="c1"># alnum character class followed by the string name.</span>
<span class="c1"># Note that the RHS should not be quoted here.</span>
<span class="c1"># For the gory details, see</span>
<span class="c1"># E14 at http://tiswww.case.edu/php/chet/bash/FAQ</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;filename&quot;</span> <span class="o">=</span>~ ^<span class="o">[[</span>:alnum:<span class="o">]]</span>+name <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Match&quot;</span>
<span class="k">fi</span>

<span class="c1"># This matches the exact pattern &quot;f*&quot; (Does not match in this case)</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;filename&quot;</span> <span class="o">==</span> <span class="s2">&quot;f*&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Match&quot;</span>
<span class="k">fi</span>

<span class="c1"># This gives a &quot;too many arguments&quot; error as f* is expanded to the</span>
<span class="c1"># contents of the current directory</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;filename&quot;</span> <span class="o">==</span> f* <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Match&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h4>测试字符串</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">尽可能使用引用，而不是过滤字符串。</p>
</div>
<p>Bash足以在测试中处理空字符串。所以，请使用空（非空）字符串测试，而不是填充字符，使得代码更易于阅读。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Do this:</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;some_string&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># -z (string length is zero) and -n (string length is not zero) are</span>
<span class="c1"># preferred over testing for an empty string</span>
<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># This is OK (ensure quotes on the empty side), but not preferred:</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># Not this:</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">X&quot;</span> <span class="o">=</span> <span class="s2">&quot;some_stringX&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>
</pre></div>
</div>
<p>为了避免对你测试的目的产生困惑，请明确使用`-z`或者`-n`</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use this</span>
<span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>

<span class="c1"># Instead of this as errors can occur if ${my_var} expands to a test</span>
<span class="c1"># flag</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">my_var</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>文件名的通配符扩展</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">当进行文件名的通配符扩展时，请使用明确的路径。</p>
</div>
<p>因为文件名可能以 <code class="docutils literal notranslate"><span class="pre">-</span></code> 开头，所以使用扩展通配符 <code class="docutils literal notranslate"><span class="pre">./*</span></code> 比 <code class="docutils literal notranslate"><span class="pre">*</span></code> 来得安全得多。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Here&#39;s the contents of the directory:</span>
<span class="c1"># -f  -r  somedir  somefile</span>

<span class="c1"># This deletes almost everything in the directory by force</span>
psa@bilby$ rm -v *
removed directory: <span class="sb">`</span>somedir<span class="s1">&#39;</span>
<span class="s1">removed `somefile&#39;</span>

<span class="c1"># As opposed to:</span>
psa@bilby$ rm -v ./*
removed <span class="sb">`</span>./-f<span class="s1">&#39;</span>
<span class="s1">removed `./-r&#39;</span>
rm: cannot remove <span class="sb">`</span>./somedir<span class="s1">&#39;: Is a directory</span>
<span class="s1">removed `./somefile&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="eval">
<h4>Eval</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">应该避免使用eval。</p>
</div>
<p>当用于给变量赋值时，Eval解析输入，并且能够设置变量，但无法检查这些变量是什么。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># What does this set?</span>
<span class="c1"># Did it succeed? In part or whole?</span>
<span class="nb">eval</span> <span class="k">$(</span>set_my_variables<span class="k">)</span>

<span class="c1"># What happens if one of the returned values has a space in it?</span>
<span class="nv">variable</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span><span class="nb">eval</span> some_function<span class="k">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="while">
<h4>管道导向while循环</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">请使用过程替换或者for循环，而不是管道导向while循环。在while循环中被修改的变量是不能传递给父shell的，因为循环命令是在一个子shell中运行的。</p>
</div>
<p>管道导向while循环中的隐式子shell使得追踪bug变得很困难。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">last_line</span><span class="o">=</span><span class="s1">&#39;NULL&#39;</span>
your_command <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> line<span class="p">;</span> <span class="k">do</span>
  <span class="nv">last_line</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">line</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span>

<span class="c1"># This will output &#39;NULL&#39;</span>
<span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">last_line</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>如果你确定输入中不包含空格或者特殊符号（通常意味着不是用户输入的），那么可以使用一个for循环。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">total</span><span class="o">=</span><span class="m">0</span>
<span class="c1"># Only do this if there are no spaces in return values.</span>
<span class="k">for</span> value in <span class="k">$(</span><span class="nb">command</span><span class="k">)</span><span class="p">;</span> <span class="k">do</span>
  <span class="nv">total</span><span class="o">+=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">value</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span>
</pre></div>
</div>
<p>使用过程替换允许重定向输出，但是请将命令放入一个显式的子shell中，而不是bash为while循环创建的隐式子shell。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">total</span><span class="o">=</span><span class="m">0</span>
<span class="nv">last_file</span><span class="o">=</span>
<span class="k">while</span> <span class="nb">read</span> count filename<span class="p">;</span> <span class="k">do</span>
  <span class="nv">total</span><span class="o">+=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">count</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="nv">last_file</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">filename</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span> &lt; &lt;<span class="o">(</span>your_command <span class="p">|</span> uniq -c<span class="o">)</span>

<span class="c1"># This will output the second field of the last line of output from</span>
<span class="c1"># the command.</span>
<span class="nb">echo</span> <span class="s2">&quot;Total = </span><span class="si">${</span><span class="nv">total</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="nb">echo</span> <span class="s2">&quot;Last one = </span><span class="si">${</span><span class="nv">last_file</span><span class="si">}</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>当不需要传递复杂的结果给父shell时可以使用while循环。这通常需要一些更复杂的“解析”。请注意简单的例子使用如awk这类工具可能更容易完成。当你特别不希望改变父shell的范围变量时这可能也是有用的。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Trivial implementation of awk expression:</span>
<span class="c1">#   awk &#39;$3 == &quot;nfs&quot; { print $2 &quot; maps to &quot; $1 }&#39; /proc/mounts</span>
cat /proc/mounts <span class="p">|</span> <span class="k">while</span> <span class="nb">read</span> src dest <span class="nb">type</span> opts rest<span class="p">;</span> <span class="k">do</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="si">${</span><span class="nv">type</span><span class="si">}</span> <span class="o">==</span> <span class="s2">&quot;nfs&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
    <span class="nb">echo</span> <span class="s2">&quot;NFS </span><span class="si">${</span><span class="nv">dest</span><span class="si">}</span><span class="s2"> maps to </span><span class="si">${</span><span class="nv">src</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="k">fi</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/naming_conventions"></span><div class="section" id="section-1">
<h3>命名约定</h3>
<div class="section" id="section-2">
<h4>函数名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用小写字母，并用下划线分隔单词。使用双冒号 <code class="docutils literal notranslate"><span class="pre">::</span></code> 分隔库。函数名之后必须有圆括号。关键词 <code class="docutils literal notranslate"><span class="pre">function</span></code> 是可选的，但必须在一个项目中保持一致。</p>
</div>
<p>如果你正在写单个函数，请用小写字母来命名，并用下划线分隔单词。如果你正在写一个包，使用双冒号 <code class="docutils literal notranslate"><span class="pre">::</span></code> 来分隔包名。大括号必须和函数名位于同一行（就像在Google的其他语言一样），并且函数名和圆括号之间没有空格。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Single function</span>
my_func<span class="o">()</span> <span class="o">{</span>
  ...
<span class="o">}</span>

<span class="c1"># Part of a package</span>
mypackage::my_func<span class="o">()</span> <span class="o">{</span>
  ...
<span class="o">}</span>
</pre></div>
</div>
<p>当函数名后存在 <code class="docutils literal notranslate"><span class="pre">()</span></code> 时，关键词 <code class="docutils literal notranslate"><span class="pre">function</span></code> 是多余的。但是其促进了函数的快速辨识。</p>
</div>
<div class="section" id="section-3">
<h4>变量名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">如函数名。</p>
</div>
<p>循环的变量名应该和循环的任何变量同样命名。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> zone in <span class="si">${</span><span class="nv">zones</span><span class="si">}</span><span class="p">;</span> <span class="k">do</span>
  something_with <span class="s2">&quot;</span><span class="si">${</span><span class="nv">zone</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">done</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>常量和环境变量名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">全部大写，用下划线分隔，声明在文件的顶部。</p>
</div>
<p>常量和任何导出到环境中的都应该大写。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Constant</span>
<span class="nb">readonly</span> <span class="nv">PATH_TO_FILES</span><span class="o">=</span><span class="s1">&#39;/some/path&#39;</span>

<span class="c1"># Both constant and environment</span>
<span class="nb">declare</span> -xr <span class="nv">ORACLE_SID</span><span class="o">=</span><span class="s1">&#39;PROD&#39;</span>
</pre></div>
</div>
<p>第一次设置时有一些就变成了常量（例如，通过getopts）。因此，可以在getopts中或基于条件来设定常量，但之后应该立即设置其为只读。值得注意的是，在函数中 <code class="docutils literal notranslate"><span class="pre">declare</span></code> 不会对全局变量进行操作。所以推荐使用 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> 和 <code class="docutils literal notranslate"><span class="pre">export</span></code> 来代替。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">VERBOSE</span><span class="o">=</span><span class="s1">&#39;false&#39;</span>
<span class="k">while</span> <span class="nb">getopts</span> <span class="s1">&#39;v&#39;</span> flag<span class="p">;</span> <span class="k">do</span>
  <span class="k">case</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">flag</span><span class="si">}</span><span class="s2">&quot;</span> in
    v<span class="o">)</span> <span class="nv">VERBOSE</span><span class="o">=</span><span class="s1">&#39;true&#39;</span> <span class="p">;;</span>
  <span class="k">esac</span>
<span class="k">done</span>
<span class="nb">readonly</span> VERBOSE
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>源文件名</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">小写，如果需要的话使用下划线分隔单词。</p>
</div>
<p>这是为了和在Google中的其他代码风格保持一致： <code class="docutils literal notranslate"><span class="pre">maketemplate</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">make_template</span></code> ，而不是 <code class="docutils literal notranslate"><span class="pre">make-template</span></code> 。</p>
</div>
<div class="section" id="section-6">
<h4>只读变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">declare</span> <span class="pre">-r</span></code> 来确保变量只读。</p>
</div>
<p>因为全局变量在shell中广泛使用，所以在使用它们的过程中捕获错误是很重要的。当你声明了一个变量，希望其只读，那么请明确指出。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="nv">zip_version</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>dpkg --status zip <span class="p">|</span> grep Version: <span class="p">|</span> cut -d <span class="s1">&#39; &#39;</span> -f <span class="m">2</span><span class="k">)</span><span class="s2">&quot;</span>
<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;</span><span class="si">${</span><span class="nv">zip_version</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  error_message
<span class="k">else</span>
  <span class="nb">readonly</span> zip_version
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<h4>使用本地变量</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">使用 <code class="docutils literal notranslate"><span class="pre">local</span></code> 声明特定功能的变量。声明和赋值应该在不同行。</p>
</div>
<p>使用 <code class="docutils literal notranslate"><span class="pre">local</span></code> 来声明局部变量以确保其只在函数内部和子函数中可见。这避免了污染全局命名空间和不经意间设置可能具有函数之外重要性的变量。</p>
<p>当赋值的值由命令替换提供时，声明和赋值必须分开。因为内建的 <code class="docutils literal notranslate"><span class="pre">local</span></code> 不会从命令替换中传递退出码。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>my_func2<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local</span> <span class="nv">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span>

  <span class="c1"># Separate lines for declaration and assignment:</span>
  <span class="nb">local</span> my_var
  <span class="nv">my_var</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>my_func<span class="k">)</span><span class="s2">&quot;</span> <span class="o">||</span> <span class="k">return</span>

  <span class="c1"># DO NOT do this: $? contains the exit code of &#39;local&#39;, not my_func</span>
  <span class="nb">local</span> <span class="nv">my_var</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>my_func<span class="k">)</span><span class="s2">&quot;</span>
  <span class="o">[[</span> <span class="nv">$?</span> -eq <span class="m">0</span> <span class="o">]]</span> <span class="o">||</span> <span class="k">return</span>

  ...
<span class="o">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-8">
<h4>函数位置</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">将文件中所有的函数一起放在常量下面。不要在函数之间隐藏可执行代码。</p>
</div>
<p>如果你有函数，请将他们一起放在文件头部。只有includes， <code class="docutils literal notranslate"><span class="pre">set</span></code> 声明和常量设置可能在函数声明之前完成。不要在函数之间隐藏可执行代码。如果那样做，会使得代码在调试时难以跟踪并出现意想不到的讨厌结果。</p>
</div>
<div class="section" id="main">
<h4>主函数main</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">对于包含至少一个其他函数的足够长的脚本，需要称为 <code class="docutils literal notranslate"><span class="pre">main</span></code> 的函数。</p>
</div>
<p>为了方便查找程序的开始，将主程序放入一个称为 <code class="docutils literal notranslate"><span class="pre">main</span></code> 的函数，作为最下面的函数。这使其和代码库的其余部分保持一致性，同时允许你定义更多变量为局部变量（如果主代码不是一个函数就不能这么做）。文件中最后的非注释行应该是对 <code class="docutils literal notranslate"><span class="pre">main</span></code> 函数的调用。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>main <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</pre></div>
</div>
<p>显然，对于仅仅是线性流的短脚本， <code class="docutils literal notranslate"><span class="pre">main</span></code> 是矫枉过正，因此是不需要的。</p>
</div>
</div>
<span id="document-google-shell-styleguide/calling_commands"></span><div class="section" id="section-1">
<h3>调用命令</h3>
<div class="section" id="section-2">
<h4>检查返回值</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">总是检查返回值，并给出信息返回值。</p>
</div>
<p>对于非管道命令，使用 <code class="docutils literal notranslate"><span class="pre">$?</span></code> 或直接通过一个 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句来检查以保持其简洁。</p>
<p>例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> ! mv <span class="s2">&quot;</span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">/&quot;</span> <span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Unable to move </span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2"> to </span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">E_BAD_MOVE</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="c1"># Or</span>
mv <span class="s2">&quot;</span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">/&quot;</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="nv">$?</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Unable to move </span><span class="si">${</span><span class="nv">file_list</span><span class="si">}</span><span class="s2"> to </span><span class="si">${</span><span class="nv">dest_dir</span><span class="si">}</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
  <span class="nb">exit</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">E_BAD_MOVE</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>Bash也有 <code class="docutils literal notranslate"><span class="pre">PIPESTATUS</span></code> 变量，允许检查从管道所有部分返回的代码。如果仅仅需要检查整个管道是成功还是失败，以下的方法是可以接受的：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>tar -cf - ./* <span class="p">|</span> <span class="o">(</span> <span class="nb">cd</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">&amp;&amp;</span> tar -xf - <span class="o">)</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">PIPESTATUS</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">||</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">PIPESTATUS</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  <span class="nb">echo</span> <span class="s2">&quot;Unable to tar files to </span><span class="si">${</span><span class="nv">dir</span><span class="si">}</span><span class="s2">&quot;</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
<span class="k">fi</span>
</pre></div>
</div>
<p>可是，只要你运行任何其他命令， <code class="docutils literal notranslate"><span class="pre">PIPESTATUS</span></code> 将会被覆盖。如果你需要基于管道中发生的错误执行不同的操作，那么你需要在运行命令后立即将 <code class="docutils literal notranslate"><span class="pre">PIPESTATUS</span></code> 赋值给另一个变量（别忘了 <code class="docutils literal notranslate"><span class="pre">[</span></code> 是一个会将 <code class="docutils literal notranslate"><span class="pre">PIPESTATUS</span></code> 擦除的命令）。</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>tar -cf - ./* <span class="p">|</span> <span class="o">(</span> <span class="nb">cd</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">DIR</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">&amp;&amp;</span> tar -xf - <span class="o">)</span>
<span class="nv">return_codes</span><span class="o">=(</span><span class="si">${</span><span class="nv">PIPESTATUS</span><span class="p">[*]</span><span class="si">}</span><span class="o">)</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">return_codes</span><span class="p">[0]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something
<span class="k">fi</span>
<span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">return_codes</span><span class="p">[1]</span><span class="si">}</span><span class="s2">&quot;</span> -ne <span class="m">0</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
  do_something_else
<span class="k">fi</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h4>内建命令和外部命令</h4>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">可以在调用shell内建命令和调用另外的程序之间选择，请选择内建命令。</p>
</div>
<p>我们更喜欢使用内建命令，如在 <code class="docutils literal notranslate"><span class="pre">bash(1)</span></code> 中参数扩展函数。因为它更强健和便携（尤其是跟像 <code class="docutils literal notranslate"><span class="pre">sed</span></code> 这样的命令比较）</p>
<p>例如：</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Prefer this:</span>
<span class="nv">addition</span><span class="o">=</span><span class="k">$((</span><span class="si">${</span><span class="nv">X</span><span class="si">}</span> <span class="o">+</span> <span class="si">${</span><span class="nv">Y</span><span class="si">}</span><span class="k">))</span>
<span class="nv">substitution</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">string</span><span class="p">/#foo/bar</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Instead of this:</span>
<span class="nv">addition</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span>expr <span class="si">${</span><span class="nv">X</span><span class="si">}</span> + <span class="si">${</span><span class="nv">Y</span><span class="si">}</span><span class="k">)</span><span class="s2">&quot;</span>
<span class="nv">substitution</span><span class="o">=</span><span class="s2">&quot;</span><span class="k">$(</span><span class="nb">echo</span> <span class="s2">&quot;</span><span class="si">${</span><span class="nv">string</span><span class="si">}</span><span class="s2">&quot;</span> <span class="p">|</span> sed -e <span class="s1">&#39;s/^foo/bar/&#39;</span><span class="k">)</span><span class="s2">&quot;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-shell-styleguide/conclusion"></span><div class="section" id="section-1">
<h3>结论</h3>
<p>使用常识并保持一致。</p>
<p>请花几分钟阅读在C++风格指南底部的赠别部分。</p>
</div>
</div>
</div>
<span id="document-google-javascript-styleguide/contents"></span><div class="section" id="javascript">
<span id="javascript-contents"></span><h2>Javascript 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-javascript-styleguide/background"></span><div class="section" id="section-1">
<h3>背景</h3>
<p>在Google的开源项目中，JavaScript是最主要的客户端脚本语言。本指南是使用JavaScript时建议和不建议做法的清单。</p>
</div>
<span id="document-google-javascript-styleguide/javascript_language_rules"></span><div class="section" id="javascript">
<h3>Javascript语言规范</h3>
<div class="section" id="var">
<h4>var关键字</h4>
<p>总是用 <code class="docutils literal notranslate"><span class="pre">var</span></code> 关键字定义变量。</p>
<div class="section" id="section-1">
<h5>描述</h5>
<p>如果不显式使用 <code class="docutils literal notranslate"><span class="pre">var</span></code> 关键字定义变量，变量会进入到全局上下文中，可能会和已有的变量发生冲突。另外，如果不使用var声明，很难说变量存在的作用域是哪个（可能在局部作用域里，也可能在document或者window上）。所以，要一直使用 <code class="docutils literal notranslate"><span class="pre">var</span></code> 关键字定义变量。</p>
</div>
</div>
<div class="section" id="section-2">
<h4>常量</h4>
<ul class="simple">
<li>使用字母全部大写（如 <code class="docutils literal notranslate"><span class="pre">NAMES_LIKE_THIS</span></code> ）的方式命名</li>
<li>可以使用 <code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> 来标记一个常量 <em>指针</em> （指向变量或属性，自身不可变）</li>
<li>由于IE的兼容问题，不要使用 <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FStatements%2Fconst">const关键字</a></li>
</ul>
<div class="section" id="section-3">
<h5>描述</h5>
<div class="section" id="section-4">
<h6>常量值</h6>
<p>如果一个值是恒定的，它命名中的字母要全部大写（如 <code class="docutils literal notranslate"><span class="pre">CONSTANT_VALUE_CASE</span></code> ）。字母全部大写意味着这个值不可以被改写。</p>
<p>原始类型（ <code class="docutils literal notranslate"><span class="pre">number</span></code> 、 <code class="docutils literal notranslate"><span class="pre">string</span></code> 、 <code class="docutils literal notranslate"><span class="pre">boolean</span></code> ）是常量值。</p>
<p>对象的表现会更主观一些，当它们没有暴露出变化的时候，应该认为它们是常量。但是这个不是由编译器决定的。</p>
</div>
<div class="section" id="section-5">
<h6>常量指针（变量和属性）</h6>
<p>用 <code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> 注释的变量和属性意味着它是不能更改的。使用const关键字可以保证在编译的时候保持一致。使用 <a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FStatements%2Fconst">const</a> 效果相同，但是由于IE的兼容问题，我们不使用const关键字。</p>
<p>另外，不应该修改用 <code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> 注释的方法。</p>
</div>
<div class="section" id="section-6">
<h6>例子</h6>
<p>注意， <code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> 不一定是常量值，但命名类似 <code class="docutils literal notranslate"><span class="pre">CONSTANT_VALUE_CASE</span></code> 的 <em>一定</em> 是常量指针。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">以毫秒为单位的超时时长</span>
<span class="o">*</span> <span class="nd">@type</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">TIMEOUT_IN_MILLISECONDS</span> <span class="o">=</span> <span class="mi">60</span><span class="p">;</span>
</pre></div>
</div>
<p>1分钟60秒永远也不会改变，这是个常量。全部大写的命名意味其为常量值，所以它不能被重写。
开源的编译器允许这个符号被重写，这是因为 <em>没有</em> <code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> 标记。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Map</span> <span class="n">of</span> <span class="n">URL</span> <span class="n">to</span> <span class="n">response</span> <span class="n">string</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@const</span>
<span class="o">*/</span>
<span class="n">MyClass</span><span class="o">.</span><span class="n">fetchedUrlCache_</span> <span class="o">=</span> <span class="n">new</span> <span class="n">goog</span><span class="o">.</span><span class="n">structs</span><span class="o">.</span><span class="n">Map</span><span class="p">();</span>
</pre></div>
</div>
<p>在这个例子中，指针没有变过，但是值却是可以变化的，所以这里用了驼峰式的命名，而不是全部大写的命名。</p>
</div>
</div>
</div>
<div class="section" id="section-7">
<h4>分号</h4>
<p>一定要使用分号。</p>
<p>依靠语句间隐式的分割，可能会造成细微的调试的问题，千万不要这样做。</p>
<p>很多时候不写分号是很危险的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// 1.
MyClass.prototype.myMethod = function() {
    return 42;
}  // 这里没有分号.

(function() {
    // 一些局部作用域中的初始化代码
})();

var x = {
    &#39;i&#39;: 1,
    &#39;j&#39;: 2
}  //没有分号.

// 2.  试着在IE和firefox下做一样的事情.
//没人会这样写代码，别管他.
[normalVersion, ffVersion][isIE]();

var THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  //这里没有分号

// 3. 条件语句
-1 == resultOfOperation() || die();
</pre></div>
</div>
<div class="section" id="section-8">
<h5>发生了什么？</h5>
<ol class="arabic simple">
<li>js错误。返回42的函数运行了，因为后面有一对括号，而且传入的参数是一个方法，然后返回的42被调用，导致出错了。</li>
<li>你可能会得到一个“no sush property in undefined”的错误，因为在执行的时候，解释器将会尝试执行 <code class="docutils literal notranslate"><span class="pre">x[normalVersion,</span> <span class="pre">ffVersion][isIE]()</span></code> 这个方法。</li>
<li><code class="docutils literal notranslate"><span class="pre">die</span></code> 这个方法只有在 <code class="docutils literal notranslate"><span class="pre">resultOfOperation()</span></code> 是 <code class="docutils literal notranslate"><span class="pre">NaN</span></code> 的时候执行，并且 <code class="docutils literal notranslate"><span class="pre">THINGS_TO_EAT</span></code> 将会被赋值为 <code class="docutils literal notranslate"><span class="pre">die()</span></code> 的结果。</li>
</ol>
</div>
<div class="section" id="section-9">
<h5>为什么？</h5>
<p>js语句要求以分号结尾，除非能够正确地推断分号的位置。在这个例子当中，函数声明、对象和数组字面量被写在了一个语句当中。右括号（”)”、”}”、”]”）不足以证明这条语句已经结束了，如果下一个字符是运算符或者”(”、”{”、”[”，js将不会结束语句。</p>
<p>这个错误让人震惊，所以一定要确保用分号结束语句。</p>
</div>
<div class="section" id="section-10">
<h5>澄清：分号和函数</h5>
<p>函数表达式后面要分号结束，但是函数声明就不需要。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">};</span>  <span class="o">//</span> <span class="n">这里要分号</span>

<span class="n">function</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">true</span><span class="p">;</span>
<span class="p">}</span>  <span class="o">//</span> <span class="n">这里不用分号</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-11">
<h4>嵌套函数</h4>
<p>可以使用。</p>
<p>嵌套函数非常有用，比如在创建持续任务或者隐藏工具方法的时候。可以放心的使用。</p>
</div>
<div class="section" id="section-12">
<h4>块内函数声明</h4>
<p>不要使用块内函数声明。</p>
<p>不要这样做：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">function</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>虽然大多数脚本引擎支持功能区块内声明，但ECMAScript并未认可（见 <a class="reference external" href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMA-262</a> ，第13条和第14）。若与他人的及EcmaScript所建议的不一致，即可视为不好的实现方式。ECMAScript只允许函数声明语句列表, 在根语句列表脚本或者函数。相反，使用一个变量初始化函数表达式在块内定义一个函数块：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-13">
<h4>异常</h4>
<p>可以抛出异常。</p>
<p>如果你做一些比较复杂的项目你基本上无法避免异常，比如使用一个应用程序开发框架。可以大胆试一试。</p>
</div>
<div class="section" id="section-14">
<h4>自定义异常</h4>
<p>可以自定义异常。</p>
<p>如果没有自定义异常，返回的错误信息来自一个有返回值的函数是难处理的，是不雅的。坏的解决方案包括传递引用的类型来保存错误信息或总是返回有一个潜在的错误成员的对象。这些基本上为原始的异常处理hack。在适当的时候使用自定义的异常。</p>
</div>
<div class="section" id="section-15">
<h4>标准功能</h4>
<p>总是优先于非标准功能。</p>
<p>为了最大的可移植性和兼容性，总是使用标准功能而不是非标准功能（例如，采用 <cite>string.charAt(3)</cite> 而非 <cite>string[3]</cite> ，用DOM的功能访问元素而不是使用特定于一个具体应用的简写）。</p>
</div>
<div class="section" id="section-16">
<h4>原始类型的包装对象</h4>
<p>没有理由使用原始类型的包装对象，更何况他们是危险的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var x = new Boolean(false);
if (x) {
    alert(&#39;hi&#39;);  //显示“hi”。
}
</pre></div>
</div>
<p>不要这样做！</p>
<p>然而类型转换是可以的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var x = Boolean(0);
if (x) {
    alert(&#39;hi&#39;);  //永远都不显示。
}
typeof Boolean(0) == &#39;boolean&#39;;
typeof new Boolean(0) == &#39;object&#39;;
</pre></div>
</div>
<p>这是非常有用的进行数字、字符串和布尔值转换的方式。</p>
</div>
<div class="section" id="section-17">
<h4>多重的原型继承</h4>
<p>不可取。</p>
<p>多重原型继承是Javascript实现继承的方式。如果你有一个以用户定义的class B作为原型的用户自定义class D，则得到多重原型继承。这样的继承出现容易但难以正确创造！</p>
<p>出于这个原因，最好是使用 <a class="reference external" href="https://developers.google.com/closure/library/?csw=1">Closure库</a> 中的 <code class="docutils literal notranslate"><span class="pre">goog.inherits()</span></code> 或类似的东西。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">D</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">goog</span><span class="o">.</span><span class="n">base</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">goog</span><span class="o">.</span><span class="n">inherits</span><span class="p">(</span> <span class="n">D</span><span class="p">,</span> <span class="n">B</span> <span class="p">);</span>

<span class="n">D</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span><span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-18">
<h4>方法和属性定义</h4>
<p><code class="docutils literal notranslate"><span class="pre">/**构造函数*/</span> <span class="pre">function</span> <span class="pre">SomeConstructor()</span> <span class="pre">{</span> <span class="pre">this.someProperty</span> <span class="pre">=</span> <span class="pre">1;</span> <span class="pre">}</span> <span class="pre">Foo.prototype.someMethod</span> <span class="pre">=</span> <span class="pre">function()</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">};</span></code></p>
<p>虽然有多种使用“new”关键词来创建对象方法和属性的途径，首选的创建方法的途径是：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="o">...</span> <span class="o">*/</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其他特性的首选创建方式是在构造函数中初始化字段：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@constructor</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">Foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">bar</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="section-19">
<h5>为什么？</h5>
<p>当前的JavaScript引擎优化基于一个对象的“形状”， <a class="reference external" href="https://developers.google.com/v8/design#prop_access">给对象添加一个属性（包括覆盖原型设置的值）改变了形式，会降低性能</a> 。</p>
</div>
</div>
<div class="section" id="section-20">
<h4>删除</h4>
<p>请使用 <code class="docutils literal notranslate"><span class="pre">this.foo</span> <span class="pre">=</span> <span class="pre">null</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">o</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">dispose</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">property_</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>而不是：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">dispose</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">delete</span> <span class="n">his</span><span class="o">.</span><span class="n">property_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在现代的JavaScript引擎中，改变一个对象属性的数量比重新分配值慢得多。应该避免删除关键字，除非有必要从一个对象的迭代的关键字列表删除一个属性，或改变 <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(key</span> <span class="pre">in</span> <span class="pre">obj)</span></code> 结果。</p>
</div>
<div class="section" id="section-21">
<h4>闭包</h4>
<p>可以使用，但是要小心。</p>
<p>创建闭包可能是JS最有用的和经常被忽视的功能。在 <a class="reference external" href="http://jibbering.com/faq/notes/closures/">这里</a> 很好地描述说明了闭包的工作。</p>
<p>要记住的一件事情，一个闭包的指针指向包含它的范围。因此，附加一个闭包的DOM元素，可以创建一个循环引用，所以，内存会泄漏。例如，下面的代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">element</span><span class="o">.</span><span class="n">onclick</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="o">/*</span> <span class="n">使用</span> <span class="n">a</span> <span class="n">和</span> <span class="n">b</span> <span class="o">*/</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>闭包能保持元素a和b的引用即使它从未使用。因为元素还保持对闭包的一个引用，我们有一个循环引用，不会被垃圾收集清理。在这些情况下，代码的结构可以如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">element</span><span class="o">.</span><span class="n">onclick</span> <span class="o">=</span> <span class="n">bar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">function</span> <span class="n">bar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="o">/*</span> <span class="n">使用</span> <span class="n">a</span> <span class="n">和</span> <span class="n">b</span> <span class="o">*/</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="eval">
<h4>eval()函数</h4>
<p>只用于反序列化（如评估RPC响应）。</p>
<p>若用于 <code class="docutils literal notranslate"><span class="pre">eval()</span></code> 的字符串含有用户输入，则 <code class="docutils literal notranslate"><span class="pre">eval()</span></code> 会造成混乱的语义，使用它有风险。通常有一个更好
更清晰、更安全的方式来编写你的代码，所以一般是不会允许其使用的。然而，eval相对比非eval使反序列化更容易，因此它的使用是可以接受的（例如评估RPC响应）。</p>
<p>反序列化是将一系列字节存到内存中的数据结构转化过程。例如，你可能会写的对象是：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">users</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;Eric&#39;</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">:</span> <span class="mi">37824</span><span class="p">,</span>
        <span class="n">email</span><span class="p">:</span> <span class="s1">&#39;jellyvore@myway.com&#39;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="s1">&#39;xtof&#39;</span><span class="p">,</span>
        <span class="nb">id</span><span class="p">:</span> <span class="mi">31337</span><span class="p">,</span>
        <span class="n">email</span><span class="p">:</span> <span class="s1">&#39;b4d455h4x0r@google.com&#39;</span>
    <span class="p">},</span>
    <span class="o">...</span>
<span class="p">];</span>
</pre></div>
</div>
<p>将这些数据读入内存跟得出文件的字符串表示形式一样容易。</p>
<p>同样， <code class="docutils literal notranslate"><span class="pre">eval()</span></code> 函数可以简化解码RPC的返回值。例如，您可以使用 <code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code> 生成RPC，在响应时服务器返回JavaScript：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var userOnline = false;
var user = &#39;nusrat&#39;;
var xmlhttp = new XMLHttpRequest();
xmlhttp.open(&#39;GET&#39;, &#39;http://chat.google.com/isUserOnline?user=&#39; + user, false);
xmlhttp.send(&#39;&#39;);
// 服务器返回：
// userOnline = true;
if (xmlhttp.status == 200) {
      eval(xmlhttp.responseText);
}
// userOnline 现在为 true
</pre></div>
</div>
</div>
<div class="section" id="with">
<h4>with() {}</h4>
<p>不建议使用。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">with</span></code> 会影响程序的语义。因为 <code class="docutils literal notranslate"><span class="pre">with</span></code> 的目标对象可能会含有和局部变量冲突的属性，使你程序的语义发生很大的变化。例如，这是做什么用？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>答案：什么都有可能。局部变量 <code class="docutils literal notranslate"><span class="pre">x</span></code> 可能会被 <code class="docutils literal notranslate"><span class="pre">foo</span></code> 的一个属性覆盖，它甚至可能有setter方法，在此情况下将其赋值为3可能会执行很多其他代码。不要使用 <code class="docutils literal notranslate"><span class="pre">with</span></code> 。</p>
</div>
<div class="section" id="this">
<h4>this</h4>
<p>只在构造函数对象、方法，和创建闭包的时候使用。</p>
<p><code class="docutils literal notranslate"><span class="pre">this</span></code> 的语义可能会非常诡异。有时它指向全局对象（很多时候）、调用者的作用域链（在 <code class="docutils literal notranslate"><span class="pre">eval</span></code> 里）、DOM树的一个节点（当使用HTML属性来做为事件句柄时）、新创建的对象（在一个构造函数中）、或者其他的对象（如果函数被 <code class="docutils literal notranslate"><span class="pre">call()</span></code> 或 <code class="docutils literal notranslate"><span class="pre">apply()</span></code> 方式调用）。</p>
<p>正因为 <code class="docutils literal notranslate"><span class="pre">this</span></code> 很容易被弄错，故将其使用限制在以下必须的地方：</p>
<ul class="simple">
<li>在构造函数中</li>
<li>在对象的方法中（包括闭包的创建）</li>
</ul>
</div>
<div class="section" id="for-in">
<h4>for-in 循环</h4>
<p>只使用在对象、映射、哈希的键值迭代中。</p>
<p><code class="docutils literal notranslate"><span class="pre">for-in</span></code> 循环经常被不正确的用在元素数组的循环中。由于并不是从 <code class="docutils literal notranslate"><span class="pre">0</span></code> 到 <code class="docutils literal notranslate"><span class="pre">length-1</span></code> 进行循环，而是遍历对象中和它原型链上的所有的键，所以很容易出错。这里有一些失败的例子：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">printArray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">printArray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>  <span class="o">//</span><span class="n">这样可以</span>

<span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span><span class="n">这样不行</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">);</span>
<span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span><span class="n">这样不行</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="n">a</span><span class="o">.</span><span class="n">buhu</span> <span class="o">=</span> <span class="s1">&#39;wine&#39;</span><span class="p">;</span>
<span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span><span class="n">这样不行</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">;</span>
<span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">printArray</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="o">//</span><span class="n">这样不行</span>
</pre></div>
</div>
<p>在数组循环时常用的一般方式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">printArray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">var</span> <span class="n">l</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">length</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-22">
<h4>关联数组</h4>
<p>不要将映射，哈希，关联数组当作一般数组来使用。</p>
<p>不允许使用关联数组……确切的说在数组，你不可以使用非数字的索引。如果你需要一个映射或者哈希，在这种情况下你应该使用对象来代替数组，因为在功能上你真正需要的是对象的特性而不是数组的。</p>
<p>数组仅仅是用来拓展对象的（像在JS中你曾经使用过的 <code class="docutils literal notranslate"><span class="pre">Date</span></code> 、 <code class="docutils literal notranslate"><span class="pre">RegExp</span></code> 和 <code class="docutils literal notranslate"><span class="pre">String</span></code> 对象一样的）。</p>
</div>
<div class="section" id="section-23">
<h4>多行的字符串字面量</h4>
<p>不要使用。</p>
<p>不要这样做：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">myString</span> <span class="o">=</span> <span class="s1">&#39;A rather long string of English text, an error message </span><span class="se">\</span>
<span class="s1">              actually that just keeps going and going -- an error </span><span class="se">\</span>
<span class="s1">              message to make the Energizer bunny blush (right through </span><span class="se">\</span>
<span class="s1">              those Schwarzenegger shades)! Where was I? Oh yes, </span><span class="se">\</span>
<span class="s1">              you</span><span class="se">\&#39;</span><span class="s1">ve got an error and all the extraneous whitespace is </span><span class="se">\</span>
<span class="s1">              just gravy.  Have a nice day.&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>在编译时每一行头部的空白符不会被安全地去除掉；斜线后的空格也会导致棘手的问题；虽然大部分脚本引擎都会支持，但是它不是ECMAScript规范的一部分。</p>
<p>使用字符串连接来代替：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">myString</span> <span class="o">=</span> <span class="s1">&#39;A rather long string of English text, an error message &#39;</span> <span class="o">+</span>
   <span class="s1">&#39;actually that just keeps going and going -- an error &#39;</span> <span class="o">+</span>
   <span class="s1">&#39;message to make the Energizer bunny blush (right through &#39;</span> <span class="o">+</span>
   <span class="s1">&#39;those Schwarzenegger shades)! Where was I? Oh yes, &#39;</span> <span class="o">+</span>
   <span class="s1">&#39;you</span><span class="se">\&#39;</span><span class="s1">ve got an error and all the extraneous whitespace is &#39;</span> <span class="o">+</span>
   <span class="s1">&#39;just gravy.  Have a nice day.&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-24">
<h4>数组和对象字面量</h4>
<p>建议使用。</p>
<p>使用数组和对象字面量来代替数组和对象构造函数。</p>
<p>数组构造函数容易在参数上出错。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">长度为3</span>
<span class="n">var</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">);</span>

<span class="o">//</span> <span class="n">长度为</span> <span class="mi">2</span>
<span class="n">var</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">);</span>

<span class="o">//</span> <span class="n">If</span> <span class="n">x1</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">number</span> <span class="ow">and</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">natural</span> <span class="n">number</span> <span class="n">the</span> <span class="n">length</span> <span class="n">will</span> <span class="n">be</span> <span class="n">x1</span><span class="o">.</span>
<span class="o">//</span> <span class="n">If</span> <span class="n">x1</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">number</span> <span class="n">but</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">natural</span> <span class="n">number</span> <span class="n">this</span> <span class="n">will</span> <span class="n">throw</span> <span class="n">an</span> <span class="n">exception</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Otherwise</span> <span class="n">the</span> <span class="n">array</span> <span class="n">will</span> <span class="n">have</span> <span class="n">one</span> <span class="n">element</span> <span class="k">with</span> <span class="n">x1</span> <span class="k">as</span> <span class="n">its</span> <span class="n">value</span><span class="o">.</span>
<span class="n">var</span> <span class="n">a3</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span>

<span class="o">//</span> <span class="n">长度为0</span>
<span class="n">var</span> <span class="n">a4</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Array</span><span class="p">();</span>
</pre></div>
</div>
<p>由此，如果有人将代码从2个参数变成了一个参数，那么这个数组就会有一个错误的长度。</p>
<p>为了避免这种怪异的情况，永远使用可读性更好的数组字面量。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">];</span>
<span class="n">var</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">];</span>
<span class="n">var</span> <span class="n">a3</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">];</span>
<span class="n">var</span> <span class="n">a4</span> <span class="o">=</span> <span class="p">[];</span>
</pre></div>
</div>
<p>对象构造函数虽然没有相同的问题，但是对于可读性和一致性，还是应该使用对象字面量。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">o</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">();</span>

<span class="n">var</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">();</span>
<span class="n">o2</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">o2</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">o2</span><span class="o">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">o2</span><span class="p">[</span><span class="s1">&#39;strange key&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>应该写成：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">o</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">var</span> <span class="n">o2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">c</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
    <span class="s1">&#39;strange key&#39;</span><span class="p">:</span> <span class="mi">3</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-25">
<h4>修改内置对象原型</h4>
<p>不建议。</p>
<p>强烈禁止修改如 <code class="docutils literal notranslate"><span class="pre">Object.prototype</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Array.prototype</span></code> 等对象的原型。修改其他内置原型如 <code class="docutils literal notranslate"><span class="pre">Function.prototype</span></code> 危险性较小，但在生产环境中还是会引发一些难以调试的问题，也应当避免。</p>
</div>
<div class="section" id="internet-explorer">
<h4>Internet Explorer中的条件注释</h4>
<p>不要使用。</p>
<p>不要这样做：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">f</span> <span class="o">=</span> <span class="n">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="o">/*</span><span class="nd">@cc_on</span> <span class="k">if</span> <span class="p">(</span><span class="nd">@_jscript</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">2</span><span class="o">*</span> <span class="o">@*/</span>  <span class="mi">3</span><span class="p">;</span> <span class="o">/*@</span> <span class="p">}</span> <span class="o">@*/</span>
<span class="p">};</span>
</pre></div>
</div>
<p>条件注释会在运行时改变JavaScript语法树，阻碍自动化工具。</p>
</div>
</div>
<span id="document-google-javascript-styleguide/javascript_style_rules"></span><div class="section" id="javascript">
<h3>Javascript风格规范</h3>
<div class="section" id="section-1">
<h4>命名</h4>
<p>通常来说，使用 <code class="docutils literal notranslate"><span class="pre">functionNamesLikeThis</span></code> ， <code class="docutils literal notranslate"><span class="pre">variableNamesLikeThis</span></code> ， <code class="docutils literal notranslate"><span class="pre">ClassNamesLikeThis</span></code> ， <code class="docutils literal notranslate"><span class="pre">EnumNamesLikeThis</span></code> ， <code class="docutils literal notranslate"><span class="pre">methodNamesLikeThis</span></code> ， <code class="docutils literal notranslate"><span class="pre">CONSTANT_VALUES_LIKE_THIS</span></code> ， <code class="docutils literal notranslate"><span class="pre">foo.namespaceNamesLikeThis.bar</span></code> 和 <code class="docutils literal notranslate"><span class="pre">filenameslikethis.js</span></code> 这种格式的命名方式。</p>
<div class="section" id="section-2">
<h5>属性和方法</h5>
<ul class="simple">
<li><em>私有</em> 属性和方法应该以下划线开头命名。</li>
<li><em>保护</em> 属性和方法应该以无下划线开头命名（像公共属性和方法一样）。</li>
</ul>
<p>了解更多关于私有成员和保护成员的信息，请阅读 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Visibility__private_and_protected_fields_">可见性</a> 部分。</p>
</div>
<div class="section" id="section-3">
<h5>方法和函数参数</h5>
<p>可选函数参数以 <code class="docutils literal notranslate"><span class="pre">opt_</span></code> 开头。</p>
<p>参数数目可变的函数应该具有以 <code class="docutils literal notranslate"><span class="pre">var_args</span></code> 命名的最后一个参数。你可能不会在代码里引用 <code class="docutils literal notranslate"><span class="pre">var_args</span></code> ；使用 <code class="docutils literal notranslate"><span class="pre">arguments</span></code> 对象。</p>
<p>可选参数和数目可变的参数也可以在注释 <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 中指定。尽管这两种惯例都被编译器接受，但更加推荐两者一起使用。</p>
</div>
<div class="section" id="gettersetter">
<h5>getter和setter</h5>
<p>EcmaScript 5 不鼓励使用属性的getter和setter。然而，如果使用它们，那么getter就不要改变属性的可见状态。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span><span class="n">错误</span><span class="o">--</span><span class="n">不要这样做</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">{</span> <span class="n">get</span> <span class="nb">next</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">nextId</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h5>存取函数</h5>
<p>属性的getter和setter方法不是必需的。然而，如果使用它们，那么读取方法必须以 <code class="docutils literal notranslate"><span class="pre">getFoo()</span></code> 命名，并且写入方法必须以 <code class="docutils literal notranslate"><span class="pre">setFoo(value)</span></code> 命名。（对于布尔型的读取方法，也可以使用 <code class="docutils literal notranslate"><span class="pre">isFoo()</span></code> ，并且这样往往听起来更自然。）</p>
</div>
<div class="section" id="section-5">
<h5>命名空间</h5>
<p>JavaScript没有原生的对封装和命名空间的支持。</p>
<p>全局命名冲突难以调试，并且当两个项目尝试整合的时候可能引起棘手的问题。为了能共享共用的JavaScript代码，我们采用一些约定来避免冲突。</p>
<div class="section" id="section-6">
<h6>为全局代码使用命名空间</h6>
<p>在全局范围内 <em>总是</em> 使用唯一的项目或库相关的伪命名空间进行前缀标识。如果你正在进行“Project Sloth”项目，一个合理的伪命名空间为 <code class="docutils literal notranslate"><span class="pre">sloth.*</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">sloth</span> <span class="o">=</span> <span class="p">{};</span>

<span class="n">sloth</span><span class="o">.</span><span class="n">sleep</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>很多JavaScript库，包括 <a class="reference external" href="https://developers.google.com/closure/library/?csw=1">the Closure Library</a> 和 <a class="reference external" href="http://dojotoolkit.org/">Dojo toolkit</a> 给你高级功能来声明命名空间。保持你的命名空间声明一致。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;sloth&#39;</span><span class="p">);</span>

<span class="n">sloth</span><span class="o">.</span><span class="n">sleep</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<h6>尊重命名空间所有权</h6>
<p>当选择一个子命名空间的时候，确保父命名空间知道你在做什么。如果你开始了一个为sloths创建hats的项目，确保Sloth这一组命名空间知道你在使用 <code class="docutils literal notranslate"><span class="pre">sloth.hats</span></code> 。</p>
</div>
<div class="section" id="section-8">
<h6>外部代码和内部代码使用不同的命名空间</h6>
<p>“外部代码”指的是来自你的代码库外并独立编译的代码。内部名称和外部名称应该严格区分开。如果你正在使用一个能调用 <code class="docutils literal notranslate"><span class="pre">foo.hats.*</span></code> 中的东西的外部库，你的内部代码不应该定义 <code class="docutils literal notranslate"><span class="pre">foo.hats.*</span></code> 中的所有符号，因为如果其他团队定义新符号就会把它打破。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>foo.require(&#39;foo.hats&#39;);
/**
*错误--不要这样做。
* @constructor
* @extends {foo.hats.RoundHat}
*/
foo.hats.BowlerHat = function() {
};
</pre></div>
</div>
<p>如果你在外部命名空间中需要定义新的API，那么你应该明确地导出且仅导出公共的API函数。为了一致性和编译器更好的优化你的内部代码，你的内部代码应该使用内部API的内部名称调用它们。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;googleyhats.BowlerHat&#39;</span><span class="p">);</span>

<span class="n">foo</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="s1">&#39;foo.hats&#39;</span><span class="p">);</span>
<span class="o">/**</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*</span> <span class="nd">@extends</span> <span class="p">{</span><span class="n">foo</span><span class="o">.</span><span class="n">hats</span><span class="o">.</span><span class="n">RoundHat</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">googleyhats</span><span class="o">.</span><span class="n">BowlerHat</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">};</span>
<span class="n">goog</span><span class="o">.</span><span class="n">exportSymbol</span><span class="p">(</span><span class="s1">&#39;foo.hats.BowlerHat&#39;</span><span class="p">,</span> <span class="n">googleyhats</span><span class="o">.</span><span class="n">BowlerHat</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-9">
<h6>为长类型的名称提供别名提高可读性</h6>
<p>如果对完全合格的类型使用本地别名可以提高可读性，那么就这样做。本地别名的名称应该符合类型的最后一部分。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*/</span>
<span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
<span class="p">};</span>

<span class="o">/**</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span><span class="p">}</span> <span class="n">a</span>
<span class="o">*/</span>
<span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span><span class="o">.</span><span class="n">staticHelper</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">};</span>

<span class="n">myapp</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">MyClass</span> <span class="o">=</span> <span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span><span class="p">;</span>
  <span class="n">var</span> <span class="n">staticHelper</span> <span class="o">=</span> <span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span><span class="o">.</span><span class="n">staticHelper</span><span class="p">;</span>
  <span class="n">staticHelper</span><span class="p">(</span><span class="n">new</span> <span class="n">MyClass</span><span class="p">());</span>
<span class="p">};</span>
</pre></div>
</div>
<p>不要为命名空间起本地别名。命名空间应该只能使用 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#goog-scope">goog.scope</a> 命名别名。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myapp</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">namespace</span> <span class="o">=</span> <span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="p">;</span>
  <span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span><span class="o">.</span><span class="n">staticHelper</span><span class="p">(</span><span class="n">new</span> <span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span><span class="p">());</span>
<span class="p">};</span>
</pre></div>
</div>
<p>避免访问一个别名类型的属性，除非它是一个枚举。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@enum</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span> <span class="o">*/</span>
<span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">Fruit</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">APPLE</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span>
  <span class="n">BANANA</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span>
<span class="p">};</span>

<span class="n">myapp</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">Fruit</span> <span class="o">=</span> <span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">Fruit</span><span class="p">;</span>
  <span class="n">switch</span> <span class="p">(</span><span class="n">fruit</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">case</span> <span class="n">Fruit</span><span class="o">.</span><span class="n">APPLE</span><span class="p">:</span>
      <span class="o">...</span>
    <span class="n">case</span> <span class="n">Fruit</span><span class="o">.</span><span class="n">BANANA</span><span class="p">:</span>
      <span class="o">...</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myapp</span><span class="o">.</span><span class="n">main</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">MyClass</span> <span class="o">=</span> <span class="n">some</span><span class="o">.</span><span class="n">long</span><span class="o">.</span><span class="n">namespace</span><span class="o">.</span><span class="n">MyClass</span><span class="p">;</span>
  <span class="n">MyClass</span><span class="o">.</span><span class="n">staticHelper</span><span class="p">(</span><span class="n">null</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>永远不要在全局环境中创建别名。只在函数体内使用它们。</p>
</div>
</div>
<div class="section" id="section-10">
<h5>文件名</h5>
<p>为了避免在大小写敏感的平台上引起混淆，文件名应该小写。文件名应该以 <code class="docutils literal notranslate"><span class="pre">.js</span></code> 结尾，并且应该不包含除了 <code class="docutils literal notranslate"><span class="pre">-</span></code> 或 <code class="docutils literal notranslate"><span class="pre">_</span></code> （相比较 <code class="docutils literal notranslate"><span class="pre">_</span></code> 更推荐 <code class="docutils literal notranslate"><span class="pre">-</span></code> ）以外的其它标点。</p>
</div>
</div>
<div class="section" id="tostring">
<h4>自定义 toString() 方法</h4>
<p>必须确保无误，并且无其他副作用。</p>
<p>你可以通过自定义 <code class="docutils literal notranslate"><span class="pre">toString()</span></code> 方法来控制对象如何字符串化他们自己。这没问题，但是你必须确保你的方法执行无误，并且无其他副作用。如果你的方法没有达到这个要求，就会很容易产生严重的问题。比如，如果 <code class="docutils literal notranslate"><span class="pre">toString()</span></code> 方法调用一个方法产生一个断言，断言可能要输出对象的名称，就又需要调用 <code class="docutils literal notranslate"><span class="pre">toString()</span></code> 方法。</p>
</div>
<div class="section" id="section-11">
<h4>延时初始化</h4>
<p>可以使用。</p>
<p>并不总在变量声明的地方就进行变量初始化，所以延时初始化是可行的。</p>
</div>
<div class="section" id="section-12">
<h4>明确作用域</h4>
<p>时常。</p>
<p>经常使用明确的作用域加强可移植性和清晰度。例如，在作用域链中不要依赖 <code class="docutils literal notranslate"><span class="pre">window</span></code> 。你可能想在其他应用中使用你的函数，这时此 <code class="docutils literal notranslate"><span class="pre">window</span></code> 就非彼 <code class="docutils literal notranslate"><span class="pre">window</span></code> 了。</p>
</div>
<div class="section" id="section-13">
<h4>代码格式</h4>
<p>我们原则上遵循 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Formatting">C++格式规范</a> ，并且进行以下额外的说明。</p>
<div class="section" id="section-14">
<h5>大括号</h5>
<p>由于隐含分号的插入，无论大括号括起来的是什么，总是在同一行上开始你的大括号。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>if (something) {
  // ...
} else {
  // …
}
</pre></div>
</div>
</div>
<div class="section" id="section-15">
<h5>数组和对象初始化表达式</h5>
<p>当单行数组和对象初始化表达式可以在一行写开时，写成单行是允许的。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>  <span class="o">//</span><span class="n">之后无空格</span><span class="p">[</span><span class="n">或之前</span><span class="p">]</span>
<span class="n">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">};</span>  <span class="o">//</span><span class="n">之后无空格</span><span class="p">[</span><span class="n">或之前</span><span class="p">]</span>
</pre></div>
</div>
<p>多行数组和对象初始化表达式缩进两个空格，括号的处理就像块一样单独成行。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">对象初始化表达式</span>
<span class="n">var</span> <span class="n">inset</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">top</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="n">right</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
  <span class="n">bottom</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
  <span class="n">left</span><span class="p">:</span> <span class="mi">12</span>
<span class="p">};</span>

<span class="o">//</span><span class="n">数组初始化表达式</span>
<span class="n">this</span><span class="o">.</span><span class="n">rows_</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s1">&#39;&quot;Slartibartfast&quot; &lt;fjordmaster@magrathea.com&gt;&#39;</span><span class="p">,</span>
  <span class="s1">&#39;&quot;Zaphod Beeblebrox&quot; &lt;theprez@universe.gov&gt;&#39;</span><span class="p">,</span>
  <span class="s1">&#39;&quot;Ford Prefect&quot; &lt;ford@theguide.com&gt;&#39;</span><span class="p">,</span>
  <span class="s1">&#39;&quot;Arthur Dent&quot; &lt;has.no.tea@gmail.com&gt;&#39;</span><span class="p">,</span>
  <span class="s1">&#39;&quot;Marvin the Paranoid Android&quot; &lt;marv@googlemail.com&gt;&#39;</span><span class="p">,</span>
  <span class="s1">&#39;the.mice@magrathea.com&#39;</span>
<span class="p">];</span>

<span class="o">//</span><span class="n">在方法调用中使用</span>
<span class="n">goog</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">createDom</span><span class="p">(</span><span class="n">goog</span><span class="o">.</span><span class="n">dom</span><span class="o">.</span><span class="n">TagName</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span> <span class="p">{</span>
  <span class="nb">id</span><span class="p">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
  <span class="n">className</span><span class="p">:</span> <span class="s1">&#39;some-css-class&#39;</span><span class="p">,</span>
  <span class="n">style</span><span class="p">:</span> <span class="s1">&#39;display:none&#39;</span>
<span class="p">},</span> <span class="s1">&#39;Hello, world!&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>长标识符或值在对齐的初始化列表中存在问题，所以初始化值不必对齐。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">CORRECT_Object</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">b</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">lengthyName</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
</pre></div>
</div>
<p>不要像这样：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">WRONG_Object</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">a</span>          <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">b</span>          <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">lengthyName</span><span class="p">:</span> <span class="mi">2</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-16">
<h5>函数参数</h5>
<p>如果可能，应该在同一行上列出所有函数参数。如果这样做将超出每行80个字符的限制，参数必须以一种可读性较好的方式进行换行。为了节省空间，在每一行你可以尽可能的接近80个字符，或者把每一个参数单独放在一行以提高可读性。缩进可能是四个空格，或者和括号对齐。下面是最常见的参数换行形式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// 四个空格，每行包括80个字符。适用于非常长的函数名，
// 重命名不需要重新缩进，占用空间小。
goog.foo.bar.doThingThatIsVeryDifficultToExplain = function(
    veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
    // ...
};

//四个空格，每行一个参数。适用于长函数名，
// 允许重命名，并且强调每一个参数。
goog.foo.bar.doThingThatIsVeryDifficultToExplain = function(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator) {
    // ...
};

// 缩进和括号对齐，每行80字符。 看上去是分组的参数，
// 占用空间小。
function foo(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
            tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator) {
    // ...
}

// 和括号对齐，每行一个参数。看上去是分组的并且
// 强调每个单独的参数。
function bar(veryDescriptiveArgumentNumberOne,
            veryDescriptiveArgumentTwo,
            tableModelEventHandlerProxy,
            artichokeDescriptorAdapterIterator) {
    // ...
}
</pre></div>
</div>
<p>当函数调用本身缩进，你可以自由地开始相对于原始声明的开头或者相对于当前函数调用的开头，进行4个空格的缩进。以下都是可接受的缩进风格。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">veryLongFunctionNameA</span><span class="p">(</span>
        <span class="n">veryLongArgumentName</span><span class="p">)</span> <span class="o">||</span>
    <span class="n">veryLongFunctionNameB</span><span class="p">(</span>
    <span class="n">veryLongArgumentName</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">veryLongFunctionNameC</span><span class="p">(</span><span class="n">veryLongFunctionNameD</span><span class="p">(</span>
      <span class="n">veryLongFunctioNameE</span><span class="p">(</span>
          <span class="n">veryLongFunctionNameF</span><span class="p">)));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-17">
<h5>匿名函数传递</h5>
<p>当在一个函数的参数列表中声明一个匿名函数时，函数体应该与声明的左边缘缩进两个空格，或者与function关键字的左边缘缩进两个空格。这是为了匿名函数体更加可读（即不被挤在屏幕的右侧）。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prefix</span><span class="o">.</span><span class="n">something</span><span class="o">.</span><span class="n">reallyLongFunctionName</span><span class="p">(</span><span class="s1">&#39;whatever&#39;</span><span class="p">,</span> <span class="n">function</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">a2</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">someOtherLongFunctionName</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">andNowForSomethingCompletelyDifferent</span><span class="p">(</span><span class="n">a2</span><span class="o">.</span><span class="n">parrot</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="n">var</span> <span class="n">names</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="n">something</span><span class="o">.</span><span class="n">myExcellentMapFunction</span><span class="p">(</span>
    <span class="n">verboselyNamedCollectionOfItems</span><span class="p">,</span>
    <span class="n">function</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="p">;</span>
    <span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="goog-scope-1">
<h5>使用goog.scope命名别名</h5>
<p><a class="reference external" href="https://docs.google.com/document/d/1ETFAuh2kaXMVL-vafUYhaWlhl6b5D9TOvboVg7Zl68Y/pub">goog.scope</a> 可用于在使用 <a class="reference external" href="https://developers.google.com/closure/library/?csw=1">the Closure Library</a> 的工程中缩短命名空间的符号引用。</p>
<p>每个文件只能添加一个 <code class="docutils literal notranslate"><span class="pre">goog.scope</span></code> 调用。始终将它放在全局范围内。</p>
<p>开放的 <code class="docutils literal notranslate"><span class="pre">goog.scope(function()</span> <span class="pre">{</span></code> 调用必须在之前有一个空行，并且紧跟 <code class="docutils literal notranslate"><span class="pre">goog.provide</span></code> 声明、 <code class="docutils literal notranslate"><span class="pre">goog.require</span></code> 声明或者顶层的注释。调用必须在文件的最后一行闭合。在scope声明闭合处追加 <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">goog.scope</span></code> 。注释与分号间隔两个空格。</p>
<p>和C++命名空间相似，不要在 <code class="docutils literal notranslate"><span class="pre">goog.scope</span></code> 声明下面缩进。相反，从第0列开始。</p>
<p>只取不会重新分配给另一个对象（例如大多数的构造函数、枚举和命名空间）的别名。不要这样做：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="n">function</span><span class="p">()</span> <span class="p">{</span>
<span class="n">var</span> <span class="n">Button</span> <span class="o">=</span> <span class="n">goog</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">Button</span><span class="p">;</span>

<span class="n">Button</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>
<span class="o">...</span>
</pre></div>
</div>
<p>别名必须和全局中的命名的最后一个属性相同。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;my.module&#39;</span><span class="p">);</span>

<span class="n">goog</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="s1">&#39;goog.dom&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="s1">&#39;goog.ui.Button&#39;</span><span class="p">);</span>

<span class="n">goog</span><span class="o">.</span><span class="n">scope</span><span class="p">(</span><span class="n">function</span><span class="p">()</span> <span class="p">{</span>
<span class="n">var</span> <span class="n">Button</span> <span class="o">=</span> <span class="n">goog</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">Button</span><span class="p">;</span>
<span class="n">var</span> <span class="n">dom</span> <span class="o">=</span> <span class="n">goog</span><span class="o">.</span><span class="n">dom</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Alias</span> <span class="n">new</span> <span class="n">types</span> <span class="n">after</span> <span class="n">the</span> <span class="n">constructor</span> <span class="n">declaration</span><span class="o">.</span>
<span class="n">my</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">SomeType</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="o">...</span> <span class="p">};</span>
<span class="n">var</span> <span class="n">SomeType</span> <span class="o">=</span> <span class="n">my</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">SomeType</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Declare</span> <span class="n">methods</span> <span class="n">on</span> <span class="n">the</span> <span class="n">prototype</span> <span class="k">as</span> <span class="n">usual</span><span class="p">:</span>
<span class="n">SomeType</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">findButton</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Button</span> <span class="k">as</span> <span class="n">aliased</span> <span class="n">above</span><span class="o">.</span>
  <span class="n">this</span><span class="o">.</span><span class="n">button</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Button</span><span class="p">(</span><span class="n">dom</span><span class="o">.</span><span class="n">getElement</span><span class="p">(</span><span class="s1">&#39;my-button&#39;</span><span class="p">));</span>
<span class="p">};</span>
<span class="o">...</span>
<span class="p">});</span>  <span class="o">//</span> <span class="n">goog</span><span class="o">.</span><span class="n">scope</span>
</pre></div>
</div>
</div>
<div class="section" id="section-18">
<h5>更多的缩进</h5>
<p>事实上，除了 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Array_and_Object_literals">初始化数组和对象</a> 和传递匿名函数外，所有被拆开的多行文本应与之前的表达式左对齐，或者以4个（而不是2个）空格作为一缩进层次。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>someWonderfulHtml = &#39;&#39; +
                    getEvenMoreHtml(someReallyInterestingValues, moreValues,
                                    evenMoreParams, &#39;a duck&#39;, true, 72,
                                    slightlyMoreMonkeys(0xfff)) +
                    &#39;&#39;;

thisIsAVeryLongVariableName =
    hereIsAnEvenLongerOtherFunctionNameThatWillNotFitOnPrevLine();

thisIsAVeryLongVariableName = &#39;expressionPartOne&#39; + someMethodThatIsLong() +
    thisIsAnEvenLongerOtherFunctionNameThatCannotBeIndentedMore();

someValue = this.foo(
    shortArg,
    &#39;Some really long string arg - this is a pretty common case, actually.&#39;,
    shorty2,
    this.bar());

if (searchableCollection(allYourStuff).contains(theStuffYouWant) &amp;&amp;
    !ambientNotification.isActive() &amp;&amp; (client.isAmbientSupported() ||
                                        client.alwaysTryAmbientAnyways())) {
  ambientNotification.activate();
}
</pre></div>
</div>
</div>
<div class="section" id="section-19">
<h5>空行</h5>
<p>使用新的空行来划分一组逻辑上相关联的代码片段。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">doSomethingTo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">doSomethingElseTo</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="n">andThen</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="n">nowDoSomethingWith</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="n">andNowWith</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-20">
<h5>二元和三元操作符</h5>
<p>操作符始终跟随着前行, 这样你就不用顾虑分号的隐式插入问题。否则换行符和缩进还是遵循其他谷歌规范指南。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var x = a ? b : c;  // All on one line if it will fit.

// Indentation +4 is OK.
var y = a ?
    longButSimpleOperandB : longButSimpleOperandC;

// Indenting to the line position of the first operand is also OK.
var z = a ?
        moreComplicatedB :
        moreComplicatedC;
</pre></div>
</div>
<p>点号也应如此处理。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">x</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">bar</span><span class="p">()</span><span class="o">.</span>
    <span class="n">doSomething</span><span class="p">()</span><span class="o">.</span>
    <span class="n">doSomethingElse</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-21">
<h4>括号</h4>
<p>只用在有需要的地方。</p>
<p>通常只在语法或者语义需要的地方有节制地使用。</p>
<p>绝对不要对一元运算符如 <code class="docutils literal notranslate"><span class="pre">delete</span></code> 、 <code class="docutils literal notranslate"><span class="pre">typeof</span></code> 和 <code class="docutils literal notranslate"><span class="pre">void</span></code> 使用括号或者在关键词如 <code class="docutils literal notranslate"><span class="pre">return</span></code> 、 <code class="docutils literal notranslate"><span class="pre">throw</span></code> 和其他的（ <code class="docutils literal notranslate"><span class="pre">case</span></code> 、 <code class="docutils literal notranslate"><span class="pre">in</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">new</span></code> ）之后使用括号。</p>
</div>
<div class="section" id="section-22">
<h4>字符串</h4>
<p>使用 <code class="docutils literal notranslate"><span class="pre">'</span></code> 代替 <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> 。</p>
<p>使用单引号（ <code class="docutils literal notranslate"><span class="pre">'</span></code> ）代替双引号（ <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> ）来保证一致性。当我们创建包含有HTML的字符串时这样做很有帮助。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;This is some HTML&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-23">
<h4>可见性（私有和保护类型字段）</h4>
<p>鼓励使用 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;protected</span></code> JSDoc注释。</p>
<p>我们建议使用JSDoc注释 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;protected</span></code> 来标识出类、函数和属性的可见程度。</p>
<p>设置 <code class="docutils literal notranslate"><span class="pre">--jscomp_warning=visibility</span></code> 可令编译器对可见性的违规进行编译器警告。可见 <a class="reference external" href="https://code.google.com/p/closure-compiler/wiki/Warnings">封闭的编译器警告</a> 。</p>
<p>加了 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 标记的全局变量和函数只能被同一文件中的代码所访问。</p>
<p>被标记为 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 的构造函数只能被同一文件中的代码或者它们的静态和实例成员实例化。 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 标记的构造函数可以被相同文件内它们的公共静态属性和 <code class="docutils literal notranslate"><span class="pre">instanceof</span></code> 运算符访问。</p>
<p>全局变量、函数和构造函数不能注释 <code class="docutils literal notranslate"><span class="pre">&#64;protected</span></code> 。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">文件1</span>
<span class="o">//</span> <span class="n">AA_PrivateClass_</span> <span class="n">和</span> <span class="n">AA_init_</span> <span class="n">是全局的并且在同一个文件中所以能被访问</span>

<span class="o">/**</span>
<span class="o">*</span> <span class="nd">@private</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*/</span>
<span class="n">AA_PrivateClass_</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
<span class="p">};</span>

<span class="o">/**</span> <span class="nd">@private</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">AA_init_</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">new</span> <span class="n">AA_PrivateClass_</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">AA_init_</span><span class="p">();</span>
</pre></div>
</div>
<p>标记 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 的属性可以被同一文件中的所有的代码访问，如果属性属于一个类，那么所有自身含有属性的类的静态方法和实例方法也可访问。它们不能被不同文件下的子类访问或者重写。</p>
<p>标记 <code class="docutils literal notranslate"><span class="pre">&#64;protected</span></code> 的属性可以被同一文件中的所有的代码访问，任何含有属性的子类的静态方法和实例方法也可访问。</p>
<p>注意这些语义和C++、JAVA中private 和 protected的不同，其许可同一文件中的所有代码访问的权限，而不是仅仅局限于同一类或者同一类层次。此外，不像C++中，子类不可重写私有属性。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">File</span> <span class="mf">1.</span>

<span class="o">/**</span> <span class="nd">@constructor</span> <span class="o">*/</span>
<span class="n">AA_PublicClass</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">/**</span> <span class="nd">@private</span> <span class="o">*/</span>
  <span class="n">this</span><span class="o">.</span><span class="n">privateProp_</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="o">/**</span> <span class="nd">@protected</span> <span class="o">*/</span>
  <span class="n">this</span><span class="o">.</span><span class="n">protectedProp</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">/**</span> <span class="nd">@private</span> <span class="o">*/</span>
<span class="n">AA_PublicClass</span><span class="o">.</span><span class="n">staticPrivateProp_</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="o">/**</span> <span class="nd">@protected</span> <span class="o">*/</span>
<span class="n">AA_PublicClass</span><span class="o">.</span><span class="n">staticProtectedProp</span> <span class="o">=</span> <span class="mi">31</span><span class="p">;</span>

<span class="o">/**</span> <span class="nd">@private</span> <span class="o">*/</span>
<span class="n">AA_PublicClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">privateMethod_</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{};</span>

<span class="o">/**</span> <span class="nd">@protected</span> <span class="o">*/</span>
<span class="n">AA_PublicClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">protectedMethod</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{};</span>

<span class="o">//</span> <span class="n">File</span> <span class="mf">2.</span>

<span class="o">/**</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span> <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">ducks</span> <span class="n">we</span><span class="s1">&#39;ve arranged in a row.</span>
<span class="o">*/</span>
<span class="n">AA_PublicClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Legal</span> <span class="n">accesses</span> <span class="n">of</span> <span class="n">these</span> <span class="n">two</span> <span class="n">properties</span><span class="o">.</span>
  <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">privateProp_</span> <span class="o">+</span> <span class="n">AA_PublicClass</span><span class="o">.</span><span class="n">staticPrivateProp_</span><span class="p">;</span>
<span class="p">};</span>

<span class="o">//</span> <span class="n">File</span> <span class="mf">3.</span>

<span class="o">/**</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*</span> <span class="nd">@extends</span> <span class="p">{</span><span class="n">AA_PublicClass</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">AA_SubClass</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Legal</span> <span class="n">access</span> <span class="n">of</span> <span class="n">a</span> <span class="n">protected</span> <span class="n">static</span> <span class="nb">property</span><span class="o">.</span>
  <span class="n">AA_PublicClass</span><span class="o">.</span><span class="n">staticProtectedProp</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">method</span><span class="p">();</span>
<span class="p">};</span>
<span class="n">goog</span><span class="o">.</span><span class="n">inherits</span><span class="p">(</span><span class="n">AA_SubClass</span><span class="p">,</span> <span class="n">AA_PublicClass</span><span class="p">);</span>

<span class="o">/**</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span> <span class="n">The</span> <span class="n">number</span> <span class="n">of</span> <span class="n">ducks</span> <span class="n">we</span><span class="s1">&#39;ve arranged in a row.</span>
<span class="o">*/</span>
<span class="n">AA_SubClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">Legal</span> <span class="n">access</span> <span class="n">of</span> <span class="n">a</span> <span class="n">protected</span> <span class="n">instance</span> <span class="nb">property</span><span class="o">.</span>
  <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">protectedProp</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>注意在Javascript中，一个类（如 <code class="docutils literal notranslate"><span class="pre">AA_PrivateClass_</span></code> ）和其构造函数类型是没有区别的。没办法确定一种类型是public而它的构造函数是private。（因为构造函数很容易重命名从而躲避隐私检查）。</p>
</div>
<div class="section" id="javascript-1">
<h4>JavaScript类型</h4>
<p>鼓励和强制执行的编译器。</p>
<p>JSDoc记录类型时，要尽可能具体和准确。我们支持的类型是基于 <a class="reference external" href="http://wiki.ecmascript.org/doku.php?id=spec:spec">EcmaScript 4规范</a> 。</p>
<div class="section" id="javascript-2">
<h5>JavaScript类型语言</h5>
<p>ES4提案包含指定JavaScript类型的语言。我们使用JsDoc这种语言表达函数参数和返回值的类型。</p>
<p>随着ES4提议的发展，这种语言已经改变了。编译器仍然支持旧的语法类型，但这些语法已经被弃用了。</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="31%" />
<col width="52%" />
<col width="8%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">语法名称</th>
<th class="head">语法</th>
<th class="head">描述</th>
<th class="head">弃用语法</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>原始类型</td>
<td>在JavaScript中有5种原始类型： <code class="docutils literal notranslate"><span class="pre">{null}</span></code> ， <code class="docutils literal notranslate"><span class="pre">{undefined}</span></code> ， <code class="docutils literal notranslate"><span class="pre">{boolean}</span></code> ， <code class="docutils literal notranslate"><span class="pre">{number}</span></code> ，和 <code class="docutils literal notranslate"><span class="pre">{string}</span></code></td>
<td>类型的名称。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>实例类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{Object}</span></code>
实例对象或空。</p>
<p><code class="docutils literal notranslate"><span class="pre">{Function}</span></code>
一个实例函数或空。</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">{EventTarget}</span></code>
构造函数实现的EventTarget接口，或者为null的一个实例。</p>
</td>
<td><p class="first">一个实例构造函数或接口函数。构造函数是 <code class="docutils literal notranslate"><span class="pre">&#64;constructor</span></code> JSDoc标记定义的函数 。接口函数是 <code class="docutils literal notranslate"><span class="pre">&#64;interface</span></code> JSDoc标记定义的函数。</p>
<p class="last">默认情况下，实例类型将接受空。这是唯一的类型语法，使得类型为空。此表中的其他类型的语法不会接受空。</p>
</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>枚举类型</td>
<td><code class="docutils literal notranslate"><span class="pre">{goog.events.EventType}</span></code> 字面量初始化对象的属性之一 <code class="docutils literal notranslate"><span class="pre">goog.events.EventType</span></code> 。</td>
<td><p class="first">一个枚举必须被初始化为一个字面量对象，或作为另一个枚举的别名,加注 <code class="docutils literal notranslate"><span class="pre">&#64;enum</span></code> JSDoc标记。这个属性是枚举实例。 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#enums">下面</a> 是枚举语法的定义。</p>
<p class="last">请注意，这是我们的类型系统中为数不多的ES4规范以外的事情之一。</p>
</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>应用类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{Array.&lt;string&gt;}</span></code> 字符串数组。</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">{Object.&lt;string,</span> <span class="pre">number&gt;}</span></code> 一个对象，其中键是字符串，值是数字。</p>
</td>
<td>参数化类型，该类型应用一组参数类型。这个想法是类似于Java泛型。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>联合类型</td>
<td><code class="docutils literal notranslate"><span class="pre">{(number|boolean)}</span></code> 一个数字或布尔值。</td>
<td><p class="first">表明一个值可能有A型或B型。</p>
<p>括号在顶层表达式可以省略，但在子表达式不能省略，以避免歧义。</p>
<p><code class="docutils literal notranslate"><span class="pre">{number|boolean}</span></code></p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">{function():</span> <span class="pre">(number|boolean)}</span></code></p>
</td>
<td><code class="docutils literal notranslate"><span class="pre">{(number,boolean)}</span></code> ，
<code class="docutils literal notranslate"><span class="pre">{(number||boolean)}</span></code></td>
</tr>
<tr class="row-odd"><td>可为空的类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{?number}</span></code></p>
<p class="last">一个数字或空。</p>
</td>
<td>空类型与任意其他类型组合的简称。这仅仅是语法糖（syntactic sugar）。</td>
<td><code class="docutils literal notranslate"><span class="pre">{number?}</span></code></td>
</tr>
<tr class="row-even"><td>非空类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{!Object}</span></code></p>
<p class="last">一个对象，值非空。</p>
</td>
<td>从非空类型中过滤掉null。最常用于实例类型，默认可为空。</td>
<td><code class="docutils literal notranslate"><span class="pre">{Object!}</span></code></td>
</tr>
<tr class="row-odd"><td>记录类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{{myNum:</span> <span class="pre">number,</span> <span class="pre">myObject}}</span></code></p>
<p class="last">给定成员类型的匿名类型。</p>
</td>
<td><p class="first">表示该值有指定的类型的成员。在这种情况下， <code class="docutils literal notranslate"><span class="pre">myNum</span></code> 是 <code class="docutils literal notranslate"><span class="pre">number</span></code> 类型而 <code class="docutils literal notranslate"><span class="pre">myObject</span></code> 可为任何类型。</p>
<p class="last">注意花括号是语法类型的一部分。例如，表示一个数组对象有一个 <code class="docutils literal notranslate"><span class="pre">length</span></code> 属性，你可以写 <code class="docutils literal notranslate"><span class="pre">Array.&lt;{length}&gt;</span></code> 。</p>
</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>函数类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{function(string,</span> <span class="pre">boolean)}</span></code></p>
<p class="last">一个函数接受两个参数（一个字符串和一个布尔值），并拥有一个未知的返回值。</p>
</td>
<td>指定一个函数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>函数返回类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{function():</span> <span class="pre">number}</span></code></p>
<p class="last">一个函数没有参数并返回一个数字。</p>
</td>
<td>指定函数的返回类型。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>函数 <code class="docutils literal notranslate"><span class="pre">this</span></code> 类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{function(this:goog.ui.Menu,</span> <span class="pre">string)}</span></code></p>
<p class="last">一个需要一个参数（字符串）的函数，执行上下文是 <code class="docutils literal notranslate"><span class="pre">goog.ui.Menu</span></code></p>
</td>
<td>指定函数类型的上下文类型。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>函数 <code class="docutils literal notranslate"><span class="pre">new</span></code> 类型</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{function(new:goog.ui.Menu,</span> <span class="pre">string)}</span></code></p>
<p class="last">一个构造函数接受一个参数（一个字符串），并在使用“new”关键字时创建一个 <code class="docutils literal notranslate"><span class="pre">goog.ui.Menu</span></code> 新实例。</p>
</td>
<td>指定构造函数所构造的类型。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>可变参数</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{function(string,</span> <span class="pre">...[number]):</span> <span class="pre">number}</span></code></p>
<p class="last">一个函数，它接受一个参数（一个字符串），然后一个可变数目的参数，必须是数字。</p>
</td>
<td>指定函数的变量参数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>可变参数（ <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 注释）</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">&#64;param</span> <span class="pre">{...number}</span> <span class="pre">var_args</span></code></p>
<p class="last">带注释函数的可变数目参数。</p>
</td>
<td>指定带注释函数接受一个可变数目的参数。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>函数 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#optional">可选参数</a></td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">{function(?string=,</span> <span class="pre">number=)}</span></code></p>
<p class="last">一个函数，它接受一个可选的、可以为空的字符串和一个可选的数字作为参数。“=”只用于函数类型声明。</p>
</td>
<td>指定函数的可选参数。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>函数 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#optional">可选参数</a> （ <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 注释）</td>
<td><p class="first"><code class="docutils literal notranslate"><span class="pre">&#64;param</span> <span class="pre">{number=}</span> <span class="pre">opt_argument</span></code></p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">number</span></code> 类型的可选参数。</p>
</td>
<td>指定带注释函数接受一个可选的参数。</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>所有类型</td>
<td><code class="docutils literal notranslate"><span class="pre">{*}</span></code></td>
<td>表明该变量可以接受任何类型。</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>未知类型</td>
<td><code class="docutils literal notranslate"><span class="pre">{?}</span></code></td>
<td>表明该变量可以接受任何类型，编译器不应该检查其类型。</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="javascript-3">
<h5>JavaScript中的类型</h5>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="30%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型举例</th>
<th class="head">取值举例</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>number</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>
<span class="mf">1.0</span>
<span class="o">-</span><span class="mi">5</span>
<span class="mf">1e5</span>
<span class="n">Math</span><span class="o">.</span><span class="n">PI</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Number</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new</span> <span class="n">Number</span><span class="p">(</span><span class="n">true</span><span class="p">)</span>
</pre></div>
</div>
</td>
<td><a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Wrapper_objects_for_primitive_types">Number对象</a></td>
</tr>
<tr class="row-even"><td>string</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s1">&#39;Hello&#39;</span>
<span class="s2">&quot;World&quot;</span>
<span class="n">String</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</td>
<td>字符串</td>
</tr>
<tr class="row-odd"><td>String</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new</span> <span class="n">String</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>
<span class="n">new</span> <span class="n">String</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
</pre></div>
</div>
</td>
<td><a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Wrapper_objects_for_primitive_types">String对象</a></td>
</tr>
<tr class="row-even"><td>boolean</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">true</span>
<span class="n">false</span>
<span class="n">Boolean</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</td>
<td>Boolean值</td>
</tr>
<tr class="row-odd"><td>Boolean</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new</span> <span class="n">Boolean</span><span class="p">(</span><span class="n">true</span><span class="p">)</span>
</pre></div>
</div>
</td>
<td><a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Wrapper_objects_for_primitive_types">Boolean对象</a></td>
</tr>
<tr class="row-even"><td>RegExp</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new</span> <span class="n">RegExp</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="o">/</span><span class="n">world</span><span class="o">/</span><span class="n">g</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Date</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">new</span> <span class="n">Date</span>
<span class="n">new</span> <span class="n">Date</span><span class="p">()</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>null</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">null</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>undefined</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">undefined</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>void</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td>没有返回值</td>
</tr>
<tr class="row-odd"><td>Array</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">null</span><span class="p">]</span>
<span class="p">[]</span>
</pre></div>
</div>
</td>
<td>无类型数组</td>
</tr>
<tr class="row-even"><td>Array.&lt;number&gt;</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">11</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">33</span><span class="p">]</span>
</pre></div>
</div>
</td>
<td>数字数组</td>
</tr>
<tr class="row-odd"><td>Array.&lt;Array.&lt;string&gt;&gt;</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="s1">&#39;one&#39;</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">,</span> <span class="s1">&#39;three&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">]]</span>
</pre></div>
</div>
</td>
<td>以字符串为元素的数组，作为另一个数组的元素</td>
</tr>
<tr class="row-even"><td>Object</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{}</span>
<span class="p">{</span><span class="n">foo</span><span class="p">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="n">bar</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="n">baz</span><span class="p">:</span> <span class="n">null</span><span class="p">}</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>Object.&lt;string&gt;</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">}</span>
</pre></div>
</div>
</td>
<td>值为字符串的对象</td>
</tr>
<tr class="row-even"><td>Object.&lt;number, string&gt;</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
</pre></div>
</div>
</td>
<td>键为整数，值为字符串的对象。
注意，js当中键总是会隐式转换为字符串。所以 <code class="docutils literal notranslate"><span class="pre">obj['1']</span> <span class="pre">==</span> <span class="pre">obj[1]</span></code> 。键在for…in…循环中，总是字符串类型。但在对象中索引时编译器会验证键的类型。</td>
</tr>
<tr class="row-odd"><td>Function</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td><a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Wrapper_objects_for_primitive_types">Function对象</a></td>
</tr>
<tr class="row-even"><td>function(number, number): number</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td>函数值</td>
</tr>
<tr class="row-odd"><td>类</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@constructor</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">SomeClass</span><span class="p">()</span> <span class="p">{}</span>

<span class="n">new</span> <span class="n">SomeClass</span><span class="p">();</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>接口</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@interface</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">SomeInterface</span><span class="p">()</span> <span class="p">{}</span>

<span class="n">SomeInterface</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">draw</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{};</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>project.MyClass</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@constructor</span> <span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">function</span> <span class="p">()</span> <span class="p">{}</span>

<span class="n">new</span> <span class="n">project</span><span class="o">.</span><span class="n">MyClass</span><span class="p">()</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>project.MyEnum</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@enum</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span> <span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">MyEnum</span> <span class="o">=</span> <span class="p">{</span>
  <span class="o">/**</span> <span class="n">The</span> <span class="n">color</span> <span class="n">blue</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">BLUE</span><span class="p">:</span> <span class="s1">&#39;#0000dd&#39;</span><span class="p">,</span>
  <span class="o">/**</span> <span class="n">The</span> <span class="n">color</span> <span class="n">red</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">RED</span><span class="p">:</span> <span class="s1">&#39;#dd0000&#39;</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td><p class="first">枚举</p>
<p class="last">JSDoc中枚举的值都是可选的.</p>
</td>
</tr>
<tr class="row-odd"><td>Element</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">document</span><span class="o">.</span><span class="n">createElement</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>
</pre></div>
</div>
</td>
<td>DOM元素</td>
</tr>
<tr class="row-even"><td>Node</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">document</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">firstChild</span>
</pre></div>
</div>
</td>
<td>DOM节点</td>
</tr>
<tr class="row-odd"><td>HTMLInputElement</td>
<td><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">htmlDocument</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</td>
<td>指明类型的DOM元素</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="section-24">
<h5>类型转换</h5>
<p>在类型检测不准确的情况下，有可能需要添加类型的注释，并且把类型转换的表达式写在括号里，括号是必须的。如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@type</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span> <span class="o">*/</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="section-25">
<h5>可为空与可选的参数和属性</h5>
<p>因为Javascript是一个弱类型的语言，明白函数参数、类属性的可选、可为空和未定义之间的细微差别是非常重要的。</p>
<p>对象类型和引用类型默认可为空。如以下表达式：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">传入值初始化的类</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">Object</span><span class="p">}</span> <span class="n">value某个值</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">MyClass</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">/**</span>
   <span class="o">*</span> <span class="n">Some</span> <span class="n">value</span><span class="o">.</span>
   <span class="o">*</span> <span class="nd">@type</span> <span class="p">{</span><span class="n">Object</span><span class="p">}</span>
   <span class="o">*</span> <span class="nd">@private</span>
   <span class="o">*/</span>
  <span class="n">this</span><span class="o">.</span><span class="n">myValue_</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>告诉编译器 <code class="docutils literal notranslate"><span class="pre">myValue_</span></code> 属性为一对象或null。如果 <code class="docutils literal notranslate"><span class="pre">myValue_</span></code> 永远都不会为null, 就应该如下声明:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/**
* 传入非null值初始化的类
* @param {!Object} value某个值
* @constructor
*/
function MyClass(value) {
  /**
   * Some value.
   * @type {!Object}
   * @private
   */
  this.myValue_ = value;
}
</pre></div>
</div>
<p>这样，如果编译器可以识别出 <code class="docutils literal notranslate"><span class="pre">MyClass</span></code> 初始化传入值为null，就会发出一个警告。</p>
<p>函数的可选参数在运行时可能会是undefined，所以如果他们是类的属性，那么必须声明：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/**
* 传入可选值初始化的类
* @param {Object=} opt_value某个值（可选）
* @constructor
*/
function MyClass(opt_value) {
  /**
   * Some value.
   * @type {Object|undefined}
   * @private
   */
  this.myValue_ = opt_value;
}
</pre></div>
</div>
<p>这告诉编译器 <code class="docutils literal notranslate"><span class="pre">myValue_</span></code> 可能是一个对象，或 <code class="docutils literal notranslate"><span class="pre">null</span></code> ，或 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 。</p>
<p>注意: 可选参数 <code class="docutils literal notranslate"><span class="pre">opt_value</span></code> 被声明成 <code class="docutils literal notranslate"><span class="pre">{Object=}</span></code> ，而不是 <code class="docutils literal notranslate"><span class="pre">{Object|undefined}</span></code> 。这是因为可选参数可能是undefined。虽然直接写undefined也并无害处，但鉴于可阅读性还是写成上述的样子。</p>
<p>最后，属性的可为空和可选并不矛盾，下面的四种声明各不相同：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/**
* 接受四个参数，两个可为空，两个可选
* @param {!Object} nonNull 必不为null
* @param {Object} mayBeNull 可为null
* @param {!Object=} opt_nonNull 可选但必不为null
* @param {Object=} opt_mayBeNull 可选可为null
*/
function strangeButTrue(nonNull, mayBeNull, opt_nonNull, opt_mayBeNull) {
  // ...
};
</pre></div>
</div>
</div>
<div class="section" id="section-26">
<h5>类型定义</h5>
<p>有时类型可以变得复杂。一个函数，它接受一个元素的内容可能看起来像：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/**
* @param {string} tagName
* @param {(string|Element|Text|Array.&lt;Element&gt;|Array.&lt;Text&gt;)} contents
* @return {!Element}
*/
goog.createElement = function(tagName, contents) {
  ...
};
</pre></div>
</div>
<p>你可以定义带 <code class="docutils literal notranslate"><span class="pre">&#64;typedef</span></code> 标记的常用类型表达式。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/** @typedef {(string|Element|Text|Array.&lt;Element&gt;|Array.&lt;Text&gt;)} */
goog.ElementContent;

/**
* @param {string} tagName
* @param {goog.ElementContent} contents
* @return {!Element}
*/
goog.createElement = function(tagName, contents) {
...
};
</pre></div>
</div>
</div>
<div class="section" id="section-27">
<h5>模板类型</h5>
<p>编译器对模板类型提供有限支持。它只能从字面上通过 <code class="docutils literal notranslate"><span class="pre">this</span></code> 参数的类型和 <code class="docutils literal notranslate"><span class="pre">this</span></code> 参数是否丢失推断匿名函数的 <code class="docutils literal notranslate"><span class="pre">this</span></code> 类型。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">function</span><span class="p">(</span><span class="n">this</span><span class="p">:</span><span class="n">T</span><span class="p">,</span> <span class="o">...</span><span class="p">)}</span> <span class="n">fn</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">T</span><span class="p">}</span> <span class="n">thisObj</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="o">...*</span><span class="p">}</span> <span class="n">var_args</span>
<span class="o">*</span> <span class="nd">@template</span> <span class="n">T</span>
<span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">thisObj</span><span class="p">,</span> <span class="n">var_args</span><span class="p">)</span> <span class="p">{</span>
<span class="o">...</span>
<span class="p">};</span>
<span class="o">//</span><span class="n">可能出现属性丢失警告</span>
<span class="n">goog</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="n">this</span><span class="o">.</span><span class="n">someProperty</span><span class="p">;</span> <span class="p">},</span> <span class="n">new</span> <span class="n">SomeClass</span><span class="p">());</span>
<span class="o">//</span><span class="n">出现this未定义警告</span>
<span class="n">goog</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="n">this</span><span class="o">.</span><span class="n">someProperty</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-28">
<span id="js-comments"></span><h4>注释</h4>
<p>使用JSDoc。</p>
<p>我们使用 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Comments">c++的注释风格</a> 。
所有的文件、类、方法和属性都应该用合适的 <a class="reference external" href="https://code.google.com/p/jsdoc-toolkit/">JSDoc</a> 的 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#JSDoc_Tag_Reference">标签</a> 和 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#JsTypes">类型</a> 注释。除了直观的方法名称和参数名称外，方法的描述、方法的参数以及方法的返回值也要包含进去。</p>
<p>行内注释应该使用 <code class="docutils literal notranslate"><span class="pre">//</span></code> 的形式。</p>
<p>为了避免出现语句片段，要使用正确的大写单词开头，并使用正确的标点符号作为结束。</p>
<div class="section" id="section-29">
<h5>注释语法</h5>
<p>JSDoc的语法基于 <a class="reference external" href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html">JavaDoc</a> ，许多编译工具从JSDoc注释中获取信息从而进行代码验证和优化，所以这些注释必须符合语法规则。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">A</span> <span class="n">JSDoc</span> <span class="n">comment</span> <span class="n">should</span> <span class="n">begin</span> <span class="k">with</span> <span class="n">a</span> <span class="n">slash</span> <span class="ow">and</span> <span class="mi">2</span> <span class="n">asterisks</span><span class="o">.</span>
<span class="o">*</span> <span class="n">Inline</span> <span class="n">tags</span> <span class="n">should</span> <span class="n">be</span> <span class="n">enclosed</span> <span class="ow">in</span> <span class="n">braces</span> <span class="n">like</span> <span class="p">{</span><span class="nd">@code</span> <span class="n">this</span><span class="p">}</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@desc</span> <span class="n">Block</span> <span class="n">tags</span> <span class="n">should</span> <span class="n">always</span> <span class="n">start</span> <span class="n">on</span> <span class="n">their</span> <span class="n">own</span> <span class="n">line</span><span class="o">.</span>
<span class="o">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="jsdoc-1">
<h5>JSDoc 缩进</h5>
<p>如果你不得不进行换行，那么你应该像在代码里那样，使用四个空格进行缩进。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Illustrates</span> <span class="n">line</span> <span class="n">wrapping</span> <span class="k">for</span> <span class="n">long</span> <span class="n">param</span><span class="o">/</span><span class="k">return</span> <span class="n">descriptions</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span> <span class="n">foo</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">param</span> <span class="k">with</span> <span class="n">a</span> <span class="n">description</span> <span class="n">too</span> <span class="n">long</span> <span class="n">to</span> <span class="n">fit</span> <span class="ow">in</span>
<span class="o">*</span>     <span class="n">one</span> <span class="n">line</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span> <span class="n">This</span> <span class="n">returns</span> <span class="n">something</span> <span class="n">that</span> <span class="n">has</span> <span class="n">a</span> <span class="n">description</span> <span class="n">too</span> <span class="n">long</span> <span class="n">to</span>
<span class="o">*</span>     <span class="n">fit</span> <span class="ow">in</span> <span class="n">one</span> <span class="n">line</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">MyClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>不必在 <code class="docutils literal notranslate"><span class="pre">&#64;fileoverview</span></code> 标记中使用缩进。</p>
<p>虽然不建议，但依然可以对描述文字进行排版。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">NOT</span> <span class="n">the</span> <span class="n">preferred</span> <span class="n">indentation</span> <span class="n">method</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span> <span class="n">foo</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">param</span> <span class="k">with</span> <span class="n">a</span> <span class="n">description</span> <span class="n">too</span> <span class="n">long</span> <span class="n">to</span> <span class="n">fit</span> <span class="ow">in</span>
<span class="o">*</span>                     <span class="n">one</span> <span class="n">line</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span> <span class="n">This</span> <span class="n">returns</span> <span class="n">something</span> <span class="n">that</span> <span class="n">has</span> <span class="n">a</span> <span class="n">description</span> <span class="n">too</span> <span class="n">long</span> <span class="n">to</span>
<span class="o">*</span>                  <span class="n">fit</span> <span class="ow">in</span> <span class="n">one</span> <span class="n">line</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">MyClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="jsdochtml">
<h5>JSDoc中的HTML</h5>
<p>像JavaDoc一样, JSDoc 支持很多的HTML标签，像 <code class="docutils literal notranslate"><span class="pre">&lt;code&gt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&lt;pre&gt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&lt;tt&gt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&lt;strong&gt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&lt;ul&gt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&lt;ol&gt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&lt;li&gt;</span></code> ， <code class="docutils literal notranslate"><span class="pre">&lt;a&gt;</span></code> 等。</p>
<p>这就意味着不建议采用纯文本的格式。所以，不要在JSDoc里使用空白符进行格式化。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Computes</span> <span class="n">weight</span> <span class="n">based</span> <span class="n">on</span> <span class="n">three</span> <span class="n">factors</span><span class="p">:</span>
<span class="o">*</span>  <span class="n">items</span> <span class="n">sent</span>
<span class="o">*</span>  <span class="n">items</span> <span class="n">received</span>
<span class="o">*</span>  <span class="n">last</span> <span class="n">timestamp</span>
<span class="o">*/</span>
</pre></div>
</div>
<p>上面的注释会变成这样：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Computes</span> <span class="n">weight</span> <span class="n">based</span> <span class="n">on</span> <span class="n">three</span> <span class="n">factors</span><span class="p">:</span> <span class="n">items</span> <span class="n">sent</span> <span class="n">items</span> <span class="n">received</span> <span class="n">items</span> <span class="n">received</span> <span class="n">last</span> <span class="n">timestamp</span>
</pre></div>
</div>
<p>所以，用下面的方式代替：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Computes</span> <span class="n">weight</span> <span class="n">based</span> <span class="n">on</span> <span class="n">three</span> <span class="n">factors</span><span class="p">:</span>
<span class="o">*</span> <span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="o">*</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="n">items</span> <span class="n">sent</span>
<span class="o">*</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="n">items</span> <span class="n">received</span>
<span class="o">*</span> <span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="n">last</span> <span class="n">timestamp</span>
<span class="o">*</span> <span class="o">&lt;/</span><span class="n">ul</span><span class="o">&gt;</span>
<span class="o">*/</span>
</pre></div>
</div>
<p><a class="reference external" href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html">JavaDoc</a> 风格指南对于如何编写良好的doc注释是非常有帮助的。</p>
</div>
<div class="section" id="section-30">
<h5>顶层/文件层注释</h5>
<p><a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/copyright.html">版权声明</a> 和作者信息是可选的。顶层注释的目的是为了让不熟悉代码的读者了解文件中有什么。它需要描述文件内容，依赖关系以及兼容性的信息。例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@fileoverview</span> <span class="n">Description</span> <span class="n">of</span> <span class="n">file</span><span class="p">,</span> <span class="n">its</span> <span class="n">uses</span> <span class="ow">and</span> <span class="n">information</span>
<span class="o">*</span> <span class="n">about</span> <span class="n">its</span> <span class="n">dependencies</span><span class="o">.</span>
<span class="o">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="class">
<h5>Class评论</h5>
<p>类必须记录说明与描述和 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#constructor-tag">一个类型的标签</a> ，标识的构造函数。类必须加以描述，若是构造函数则需标注出。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Class</span> <span class="n">making</span> <span class="n">something</span> <span class="n">fun</span> <span class="ow">and</span> <span class="n">easy</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span> <span class="n">arg1</span> <span class="n">An</span> <span class="n">argument</span> <span class="n">that</span> <span class="n">makes</span> <span class="n">this</span> <span class="n">more</span> <span class="n">interesting</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">Array</span><span class="o">.&lt;</span><span class="n">number</span><span class="o">&gt;</span><span class="p">}</span> <span class="n">arg2</span> <span class="n">List</span> <span class="n">of</span> <span class="n">numbers</span> <span class="n">to</span> <span class="n">be</span> <span class="n">processed</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*</span> <span class="nd">@extends</span> <span class="p">{</span><span class="n">goog</span><span class="o">.</span><span class="n">Disposable</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
<span class="n">goog</span><span class="o">.</span><span class="n">inherits</span><span class="p">(</span><span class="n">project</span><span class="o">.</span><span class="n">MyClass</span><span class="p">,</span> <span class="n">goog</span><span class="o">.</span><span class="n">Disposable</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-31">
<h5>方法和功能注释</h5>
<p>参数和返回类型应该被记录下来。如果方法描述从参数或返回类型的描述中明确可知则可以省略。方法描述应该由一个第三人称表达的句子开始。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Operates</span> <span class="n">on</span> <span class="n">an</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">MyClass</span> <span class="ow">and</span> <span class="n">returns</span> <span class="n">something</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">project</span><span class="o">.</span><span class="n">MyClass</span><span class="p">}</span> <span class="n">obj</span> <span class="n">Instance</span> <span class="n">of</span> <span class="n">MyClass</span> <span class="n">which</span> <span class="n">leads</span> <span class="n">to</span> <span class="n">a</span> <span class="n">long</span>
<span class="o">*</span>    <span class="n">comment</span> <span class="n">that</span> <span class="n">needs</span> <span class="n">to</span> <span class="n">be</span> <span class="n">wrapped</span> <span class="n">to</span> <span class="n">two</span> <span class="n">lines</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">boolean</span><span class="p">}</span> <span class="n">Whether</span> <span class="n">something</span> <span class="n">occured</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">PR_someMethod</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-32">
<h5>属性评论</h5>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@constructor</span> <span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">MyClass</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
<span class="o">/**</span>
  <span class="o">*</span> <span class="n">Maximum</span> <span class="n">number</span> <span class="n">of</span> <span class="n">things</span> <span class="n">per</span> <span class="n">pane</span><span class="o">.</span>
  <span class="o">*</span> <span class="nd">@type</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span>
  <span class="o">*/</span>
  <span class="n">this</span><span class="o">.</span><span class="n">someProperty</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="jsdoc-2">
<h5>JSDoc标签参考</h5>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="30%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">标签</th>
<th class="head">模板及实例</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#64;author</td>
<td><p class="first">&#64;author <a class="reference external" href="mailto:username&#37;&#52;&#48;google&#46;com">username<span>&#64;</span>google<span>&#46;</span>com</a> (first last)</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@fileoverview</span> <span class="n">Utilities</span> <span class="k">for</span> <span class="n">handling</span> <span class="n">textareas</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@author</span> <span class="n">kuth</span><span class="nd">@google</span><span class="o">.</span><span class="n">com</span> <span class="p">(</span><span class="n">Uthur</span> <span class="n">Pendragon</span><span class="p">)</span>
<span class="o">*/</span>
</pre></div>
</div>
</td>
<td>说明文件的作者是谁，一般只会在 <code class="docutils literal notranslate"><span class="pre">&#64;fileoverview</span></code> 里用到。</td>
</tr>
<tr class="row-odd"><td>&#64;code</td>
<td><p class="first"><a class="reference external" href="mailto:{&#37;&#52;&#48;code">{<span>&#64;</span>code</a> …}</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
</pre></div>
</div>
<blockquote class="last">
<div><ul class="simple">
<li>Moves to the next position in the selection.</li>
<li>Throws <a class="reference external" href="mailto:{&#37;&#52;&#48;code">{<span>&#64;</span>code</a> goog.iter.StopIteration} when it</li>
<li>passes the end of the range.</li>
<li>&#64;return {Node} The node at the next position.</li>
</ul>
<p><a href="#system-message-1"><span class="problematic" id="problematic-1">*</span></a>/
goog.dom.RangeIterator.prototype.next = function() {</p>
<blockquote>
<div>// …</div></blockquote>
<p>};</p>
</div></blockquote>
</td>
<td>表示这是一段代码，他能在文档中正确的格式化。</td>
</tr>
<tr class="row-even"><td>&#64;const</td>
<td><p class="first">&#64;const
&#64;const {type}</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@const</span> \<span class="o">*/</span> <span class="n">var</span> <span class="n">MY_BEER</span> <span class="o">=</span> <span class="s1">&#39;stout&#39;</span><span class="p">;</span>
<span class="o">/**</span>
<span class="o">*</span> <span class="n">My</span> <span class="n">namespace</span><span class="s1">&#39;s favorite kind of beer.</span>
<span class="o">*</span> <span class="nd">@const</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">mynamespace</span><span class="o">.</span><span class="n">MY_BEER</span> <span class="o">=</span> <span class="s1">&#39;stout&#39;</span><span class="p">;</span>

<span class="o">/**</span> <span class="nd">@const</span> \<span class="o">*/</span> <span class="n">MyClass</span><span class="o">.</span><span class="n">MY_BEER</span> <span class="o">=</span> <span class="s1">&#39;stout&#39;</span><span class="p">;</span>

<span class="o">/**</span>
<span class="o">*</span> <span class="n">Initializes</span> <span class="n">the</span> <span class="n">request</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@const</span>
<span class="o">*/</span>
<span class="n">mynamespace</span><span class="o">.</span><span class="n">Request</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">initialize</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">This</span> <span class="n">method</span> <span class="n">cannot</span> <span class="n">be</span> <span class="n">overriden</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">subclass</span><span class="o">.</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td><p class="first">说明变量或者属性是只读的，适合内联。</p>
<p>标记为 <code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> 的变量是不可变的。如果变量或属性试图覆盖他的值，那么js编译器会给出警告。</p>
<p>如果某一个值可以清楚地分辨出是不是常量，可以省略类型声明。变量附加的注释是可选的。</p>
<p>当一个方法被标记为 <code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> ，意味着这个方法不仅不可以被覆盖，而且也不能在子类中重写。</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">&#64;const</span></code> 的更多信息，请看 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Constants">常量</a> 部分</p>
</td>
</tr>
<tr class="row-odd"><td>&#64;constructor</td>
<td><p class="first">&#64;constructor</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">A</span> <span class="n">rectangle</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">GM_Rect</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td>在一个类的文档中表示构造函数。</td>
</tr>
<tr class="row-even"><td>&#64;define</td>
<td><p class="first">&#64;define {Type} description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@define</span> <span class="p">{</span><span class="n">boolean</span><span class="p">}</span> <span class="o">*/</span>
<span class="n">var</span> <span class="n">TR_FLAGS_ENABLE_DEBUG</span> <span class="o">=</span> <span class="n">true</span><span class="p">;</span>

<span class="o">/**</span> <span class="nd">@define</span> <span class="p">{</span><span class="n">boolean</span><span class="p">}</span> <span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">userAgent</span><span class="o">.</span><span class="n">ASSUME_IE</span> <span class="o">=</span> <span class="n">false</span><span class="p">;</span>
</pre></div>
</div>
</td>
<td><p class="first">指明一个在编译时可以被覆盖的常量。</p>
<p class="last">在这个例子中，编译器标志 <code class="docutils literal notranslate"><span class="pre">--define='goog.userAgent.ASSUME_IE=true'</span></code> 表明在构建文件的时侯变量 <code class="docutils literal notranslate"><span class="pre">goog.userAgent.ASSUME_IE</span></code> 可以被赋值为 <code class="docutils literal notranslate"><span class="pre">true</span></code> 。</p>
</td>
</tr>
<tr class="row-odd"><td>&#64;deprecated</td>
<td><p class="first">&#64;deprecated Description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Determines</span> <span class="n">whether</span> <span class="n">a</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">field</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">boolean</span><span class="p">}</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">the</span> <span class="n">contents</span> <span class="n">of</span>
<span class="o">*</span>    <span class="n">the</span> <span class="n">element</span> <span class="n">are</span> <span class="n">editable</span><span class="p">,</span> <span class="n">but</span> <span class="n">the</span> <span class="n">element</span>
<span class="o">*</span>    <span class="n">itself</span> <span class="ow">is</span> <span class="ow">not</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@deprecated</span> <span class="n">Use</span> <span class="n">isField</span><span class="p">()</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">BN_EditUtil</span><span class="o">.</span><span class="n">isTopEditableField</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td>说明函数、方法或者属性已经不可用，常说明替代方法或者属性。</td>
</tr>
<tr class="row-even"><td>&#64;dict</td>
<td><p class="first">&#64;dict Description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*</span> <span class="nd">@dict</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">this</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
<span class="n">var</span> <span class="n">num</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">x</span><span class="p">;</span>  <span class="o">//</span> <span class="n">warning</span>
<span class="p">(</span><span class="o">/**</span> <span class="nd">@dict</span> \<span class="o">*/</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="p">})</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>  <span class="o">//</span> <span class="n">warning</span>
</pre></div>
</div>
</td>
<td>当构造函数 (例子里的Foo)被标记为 <code class="docutils literal notranslate"><span class="pre">&#64;dict</span></code> ，你只能使用括号表示法访问 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 的属性。这个注释也可以直接使用对象表达式。</td>
</tr>
<tr class="row-odd"><td>&#64;enum</td>
<td><p class="first">&#64;enum {Type}</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Enum</span> <span class="k">for</span> <span class="n">tri</span><span class="o">-</span><span class="n">state</span> <span class="n">values</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@enum</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">TriState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">TRUE</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">FALSE</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
  <span class="n">MAYBE</span><span class="p">:</span> <span class="mi">0</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>&#64;export</td>
<td><p class="first">&#64;export</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@export</span> <span class="o">*/</span>
<span class="n">foo</span><span class="o">.</span><span class="n">MyPublicClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">myPublicMethod</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td><p class="first">对于例子中的代码，当编译到 <code class="docutils literal notranslate"><span class="pre">--generate_exports</span></code> 标记时，将会产生以下代码：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">exportSymbol</span><span class="p">(</span><span class="s1">&#39;foo.MyPublicClass.prototype.myPublicMethod&#39;</span><span class="p">,</span>
    <span class="n">foo</span><span class="o">.</span><span class="n">MyPublicClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">myPublicMethod</span><span class="p">);</span>
</pre></div>
</div>
<p>也就是输出了没有编译的代码。使用&#64;export标签时，应该：</p>
<ol class="last arabic simple">
<li>包含 <code class="docutils literal notranslate"><span class="pre">//javascript/closure/base.js</span></code> , 或者</li>
<li>同时定义 <code class="docutils literal notranslate"><span class="pre">goog.exportSymbol</span></code> 和 <code class="docutils literal notranslate"><span class="pre">goog.exportProperty</span></code> 并且要使用相同的调用方法。</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>&#64;expose</td>
<td><p class="first">&#64;expose</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@expose</span> <span class="o">*/</span>
</pre></div>
</div>
<p class="last">MyClass.prototype.exposedProperty = 3;</p>
</td>
<td><p class="first">声明一个公开的属性，表示这个属性不可以被删除、重命名或者由编译器进行优化。相同名称的属性也不能由编译器通过任何方式进行优化。</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">&#64;expose</span></code> 不可以出现在代码库里，因为他会阻止这个属性被删除。</p>
</td>
</tr>
<tr class="row-even"><td>&#64;extends</td>
<td><p class="first">&#64;extends Type
&#64;extends {Type}</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li>Immutable empty node list.</li>
<li>&#64;constructor</li>
<li>&#64;extends goog.ds.BasicNodeList</li>
</ul>
<p><a href="#system-message-2"><span class="problematic" id="problematic-2">*</span></a>/</p>
</div></blockquote>
<dl class="docutils">
<dt>goog.ds.EmptyNodeList = function() {</dt>
<dd>…</dd>
</dl>
<p class="last">};</p>
</td>
<td>和 <code class="docutils literal notranslate"><span class="pre">&#64;constructor</span></code> 一起使用，表示从哪里继承过来的。类型外的大括号是可选的。</td>
</tr>
<tr class="row-odd"><td>&#64;externs</td>
<td><p class="first">&#64;externs</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li>&#64;fileoverview This is an externs file.</li>
<li>&#64;externs</li>
</ul>
<p><a href="#system-message-3"><span class="problematic" id="problematic-3">*</span></a>/</p>
</div></blockquote>
<p class="last">var document;</p>
</td>
<td>声明一个外部文件。</td>
</tr>
<tr class="row-even"><td>&#64;fileoverview</td>
<td><p class="first">&#64;fileoverview Description</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
</pre></div>
</div>
<blockquote class="last">
<div><ul class="simple">
<li>&#64;fileoverview Utilities for doing things that require this very long</li>
<li>but not indented comment.</li>
<li>&#64;author <a class="reference external" href="mailto:kuth&#37;&#52;&#48;google&#46;com">kuth<span>&#64;</span>google<span>&#46;</span>com</a> (Uthur Pendragon)</li>
</ul>
<p><a href="#system-message-4"><span class="problematic" id="problematic-4">*</span></a>/</p>
</div></blockquote>
</td>
<td>使注释提供文件级别的信息。</td>
</tr>
<tr class="row-odd"><td>&#64;implements</td>
<td><p class="first">&#64;implements Type
&#64;implements {Type}</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li>A shape.</li>
<li>&#64;interface</li>
</ul>
<p><a href="#system-message-5"><span class="problematic" id="problematic-5">*</span></a>/</p>
</div></blockquote>
<p>function Shape() {};
Shape.prototype.draw = function() {};</p>
<dl class="docutils">
<dt>/**</dt>
<dd><ul class="first simple">
<li>&#64;constructor</li>
<li>&#64;implements {Shape}</li>
</ul>
<p class="last"><a href="#system-message-6"><span class="problematic" id="problematic-6">*</span></a>/</p>
</dd>
</dl>
<p>function Square() {};
Square.prototype.draw = function() {</p>
<blockquote>
<div>…</div></blockquote>
<p class="last">};</p>
</td>
<td>使用 <code class="docutils literal notranslate"><span class="pre">&#64;constructor</span></code> 来表示一个类实现了某个接口。类型外的大括号是可选的。</td>
</tr>
<tr class="row-even"><td>&#64;inheritDoc</td>
<td><p class="first">&#64;inheritDoc</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@inheritDoc</span> <span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">SubClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td><p class="first"><strong>已废弃。使用&#64;override代替</strong></p>
<p class="last">表示一个子类中的方法或者属性覆盖父类的方法或者属性，并且拥有相同的文档。注意， <code class="docutils literal notranslate"><span class="pre">&#64;inheritDoc</span></code> 等同 <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code></p>
</td>
</tr>
<tr class="row-odd"><td>&#64;interface</td>
<td><p class="first">&#64;interface</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">A</span> <span class="n">shape</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@interface</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">Shape</span><span class="p">()</span> <span class="p">{};</span>
<span class="n">Shape</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">draw</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{};</span>

<span class="o">/**</span>
<span class="o">*</span> <span class="n">A</span> <span class="n">polygon</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@interface</span>
<span class="o">*</span> <span class="nd">@extends</span> <span class="p">{</span><span class="n">Shape</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">Polygon</span><span class="p">()</span> <span class="p">{};</span>
<span class="n">Polygon</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">getSides</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{};</span>
</pre></div>
</div>
</td>
<td>表示一个函数定义了一个接口。</td>
</tr>
<tr class="row-even"><td>&#64;lends</td>
<td><p class="first">&#64;lends objectName
&#64;lends {objectName}</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
    <span class="n">Button</span><span class="o">.</span><span class="n">prototype</span><span class="p">,</span>
    <span class="o">/**</span> <span class="nd">@lends</span> <span class="p">{</span><span class="n">Button</span><span class="o">.</span><span class="n">prototype</span><span class="p">}</span> <span class="o">*/</span> <span class="p">{</span>
    <span class="n">isButton</span><span class="p">:</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">true</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">});</span>
</pre></div>
</div>
</td>
<td><p class="first">表示对象的键是另外一个对象的属性。这个标记只能出现在对象字面量中。</p>
<p>注意，括号中的名称和其他标记中的类型名称不一样，它是一个对象名，表明是从哪个对象“借过来”的属性。例如， <code class="docutils literal notranslate"><span class="pre">&#64;type</span> <span class="pre">{Foo}</span></code> 意味着Foo的一个实例，但是 <code class="docutils literal notranslate"><span class="pre">&#64;lends</span> <span class="pre">{Foo}</span></code> 意味着“Foo构造函数”.</p>
<p class="last"><a class="reference external" href="https://code.google.com/p/jsdoc-toolkit/wiki/TagLends">JSDoc Toolkit docs</a> 中有关于更多此标记的信息。</p>
</td>
</tr>
<tr class="row-odd"><td>&#64;license or &#64;preserve</td>
<td><p class="first">&#64;license Description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@preserve</span> <span class="n">Copyright</span> <span class="mi">2009</span> <span class="n">SomeThirdParty</span><span class="o">.</span>
<span class="o">*</span> <span class="n">Here</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">full</span> <span class="n">license</span> <span class="n">text</span> <span class="ow">and</span> <span class="n">copyright</span>
<span class="o">*</span> <span class="n">notice</span> <span class="k">for</span> <span class="n">this</span> <span class="n">file</span><span class="o">.</span> <span class="n">Note</span> <span class="n">that</span> <span class="n">the</span> <span class="n">notice</span> <span class="n">can</span> <span class="n">span</span> <span class="n">several</span>
<span class="o">*</span> <span class="n">lines</span> <span class="ow">and</span> <span class="ow">is</span> <span class="n">only</span> <span class="n">terminated</span> <span class="n">by</span> <span class="n">the</span> <span class="n">closing</span> <span class="n">star</span> <span class="ow">and</span> <span class="n">slash</span><span class="p">:</span>
<span class="o">*/</span>
</pre></div>
</div>
</td>
<td><p class="first">由 <code class="docutils literal notranslate"><span class="pre">&#64;licenseor</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&#64;preserve</span></code> 标记的内容，会被编译器保留并放到文件的顶部。</p>
<p class="last">这个标记会让被标记的重要内容（例如法律许可或版权文本）原样输出，换行也是。</p>
</td>
</tr>
<tr class="row-even"><td>&#64;noalias</td>
<td><p class="first">&#64;noalias</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@noalias</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">Range</span><span class="p">()</span> <span class="p">{}</span>
</pre></div>
</div>
</td>
<td>用在外部文件当中，告诉编译器，这里的变量或者方法不可以重命名。</td>
</tr>
<tr class="row-odd"><td>&#64;nosideeffects</td>
<td><p class="first">&#64;nosideeffects</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@nosideeffects</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">noSideEffectsFn1</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
<span class="o">/**</span> <span class="nd">@nosideeffects</span> <span class="o">*/</span>
<span class="n">var</span> <span class="n">noSideEffectsFn2</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
<span class="o">/**</span> <span class="nd">@nosideeffects</span> <span class="o">*/</span>
<span class="n">a</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">noSideEffectsFn3</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td>用于函数和构造函数，说明调用这个函数没有副作用。如果返回值未被使用，此注释允许编译器移除对该函数的调用。</td>
</tr>
<tr class="row-even"><td>&#64;override</td>
<td><p class="first">&#64;override</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span> <span class="n">Human</span><span class="o">-</span><span class="n">readable</span> <span class="n">representation</span> <span class="n">of</span> <span class="n">project</span><span class="o">.</span><span class="n">SubClass</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@override</span>
<span class="o">*/</span>
<span class="n">project</span><span class="o">.</span><span class="n">SubClass</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td>表示子类的方法或者属性故意隐藏了父类的方法或属性。如果子类没有其他的文档，方法或属性也会从父类那里继承文档。</td>
</tr>
<tr class="row-odd"><td>&#64;param</td>
<td><p class="first">&#64;param {Type} varname Description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Queries</span> <span class="n">a</span> <span class="n">Baz</span> <span class="k">for</span> <span class="n">items</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">number</span><span class="p">}</span> <span class="n">groupNum</span> <span class="n">Subgroup</span> <span class="nb">id</span> <span class="n">to</span> <span class="n">query</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">string</span><span class="o">|</span><span class="n">number</span><span class="o">|</span><span class="n">null</span><span class="p">}</span> <span class="n">term</span> <span class="n">An</span> <span class="n">itemName</span><span class="p">,</span>
<span class="o">*</span>    <span class="ow">or</span> <span class="n">itemId</span><span class="p">,</span> <span class="ow">or</span> <span class="n">null</span> <span class="n">to</span> <span class="n">search</span> <span class="n">everything</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">Baz</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">query</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">groupNum</span><span class="p">,</span> <span class="n">term</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td><p class="first">给方法、函数、构造函数的参数添加文档说明。</p>
<p class="last"><a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#JsTypes">参数类型</a> 一定要写在大括号里。如果类型被省略，编译器将不做类型检测。</p>
</td>
</tr>
<tr class="row-even"><td>&#64;private</td>
<td><p class="first">&#64;private
&#64;private {type}</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span>/**
* Handlers that are listening to this logger.
* @private {!Array.&lt;Function&gt;}
*/
this.handlers\_ = [];
</pre></div>
</div>
</td>
<td>与方法或属性名结尾使用一个下划线来联合表明该成员是 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Visibility__private_and_protected_fields_">私有的</a> 。随着工具对 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 的认可，结尾的下划线可能最终被废弃。</td>
</tr>
<tr class="row-odd"><td>&#64;protected</td>
<td><p class="first">&#64;protected
&#64;protected {type}</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Sets</span> <span class="n">the</span> <span class="n">component</span><span class="s1">&#39;s root element to the given element.  Considered</span>
<span class="o">*</span> <span class="n">protected</span> <span class="ow">and</span> <span class="n">final</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">Element</span><span class="p">}</span> <span class="n">element</span> <span class="n">Root</span> <span class="n">element</span> <span class="k">for</span> <span class="n">the</span> <span class="n">component</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@protected</span>
<span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">Component</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">setElementInternal</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td>用来表明成员或属性是 <a href="#system-message-7"><span class="problematic" id="problematic-7">``</span></a>受保护的 &lt;<a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Visibility__private_and_protected_fields_">http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Visibility__private_and_protected_fields_</a>&gt;``_ 。成员或属性应使用没有跟随下划线的名称。</td>
</tr>
<tr class="row-even"><td>&#64;return</td>
<td><p class="first">&#64;return {Type} Description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">string</span><span class="p">}</span> <span class="n">The</span> <span class="nb">hex</span> <span class="n">ID</span> <span class="n">of</span> <span class="n">the</span> <span class="n">last</span> <span class="n">item</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">Baz</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">getLastId</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="o">...</span>
  <span class="k">return</span> <span class="nb">id</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td><p class="first">在方法或函数调用时使用，来说明返回类型。给布尔值写注释时，写成类似“这个组件是否可见”比“如果组件可见则为true，否则为false”要好。如果没有返回值，不使用 <code class="docutils literal notranslate"><span class="pre">&#64;return</span></code> 标签。</p>
<p class="last"><a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#JsTypes">类型</a> 名称必须包含在大括号内。如果省略类型，编译器将不会检查返回值的类型。</p>
</td>
</tr>
<tr class="row-odd"><td>&#64;see</td>
<td><p class="first">&#64;see Link</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="n">Adds</span> <span class="n">a</span> <span class="n">single</span> <span class="n">item</span><span class="p">,</span> <span class="n">recklessly</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@see</span> <span class="c1">#addSafely</span>
<span class="o">*</span> <span class="nd">@see</span> <span class="n">goog</span><span class="o">.</span><span class="n">Collect</span>
<span class="o">*</span> <span class="nd">@see</span> <span class="n">goog</span><span class="o">.</span><span class="n">RecklessAdder</span><span class="c1">#add</span>
<span class="o">...</span>
</pre></div>
</div>
</td>
<td>参考查找另一个类或方法。</td>
</tr>
<tr class="row-even"><td>&#64;struct</td>
<td><p class="first">&#64;struct Description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@constructor</span>
<span class="o">*</span> <span class="nd">@struct</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">Foo</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">this</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Foo</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
<span class="n">var</span> <span class="n">num</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">];</span>  <span class="o">//</span> <span class="n">warning</span>
<span class="n">obj</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="s2">&quot;asdf&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="n">warning</span>

<span class="n">Foo</span><span class="o">.</span><span class="n">prototype</span> <span class="o">=</span> <span class="o">/**</span> <span class="nd">@struct</span> <span class="o">*/</span> <span class="p">{</span>
  <span class="n">method1</span><span class="p">:</span> <span class="n">function</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="n">Foo</span><span class="o">.</span><span class="n">prototype</span><span class="o">.</span><span class="n">method2</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span> <span class="p">{};</span>  <span class="o">//</span> <span class="n">warning</span>
</pre></div>
</div>
</td>
<td>当一个构造函数（在本例中 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> ）注释为 <code class="docutils literal notranslate"><span class="pre">&#64;struct</span></code> ，你只能用点符号访问Foo对象的属性。此外，Foo对象创建后不能加新的属性。此注释也可以直接使用于对象字面量。</td>
</tr>
<tr class="row-odd"><td>&#64;supported</td>
<td><p class="first">&#64;supported Description</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@fileoverview</span> <span class="n">Event</span> <span class="n">Manager</span>
<span class="o">*</span> <span class="n">Provides</span> <span class="n">an</span> <span class="n">abstracted</span> <span class="n">interface</span> <span class="n">to</span> <span class="n">the</span>
<span class="o">*</span> <span class="n">browsers</span><span class="s1">&#39; event systems.</span>
<span class="o">*</span> <span class="nd">@supported</span> <span class="n">So</span> <span class="n">far</span> <span class="n">tested</span> <span class="ow">in</span> <span class="n">IE6</span> <span class="ow">and</span> <span class="n">FF1</span><span class="o">.</span><span class="mi">5</span>
<span class="o">*/</span>
</pre></div>
</div>
</td>
<td>用于在文件信息中说明该文档被哪些浏览器支持</td>
</tr>
<tr class="row-even"><td>&#64;suppress</td>
<td><p class="first">&#64;suppress {warning1|warning2}</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@suppress</span> <span class="p">{</span><span class="n">deprecated</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">function</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">deprecatedVersionOfF</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td>标明禁止工具发出的警告。警告类别用|分隔。</td>
</tr>
<tr class="row-odd"><td>&#64;template</td>
<td><p class="first">&#64;template</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">function</span><span class="p">(</span><span class="n">this</span><span class="p">:</span><span class="n">T</span><span class="p">,</span> <span class="o">...</span><span class="p">)}</span> <span class="n">fn</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">T</span><span class="p">}</span> <span class="n">thisObj</span>
<span class="o">*</span> <span class="nd">@param</span> <span class="p">{</span><span class="o">...*</span><span class="p">}</span> <span class="n">var_args</span>
<span class="o">*</span> <span class="nd">@template</span> <span class="n">T</span>
<span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">thisObj</span><span class="p">,</span> <span class="n">var_args</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
</td>
<td>这个注释可以用来声明一个 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Template_types">模板类型名</a> 。</td>
</tr>
<tr class="row-even"><td>&#64;this</td>
<td><p class="first">&#64;this Type
&#64;this {Type}</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pinto</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">RosterWidget</span><span class="o">.</span><span class="n">extern</span><span class="p">(</span><span class="s1">&#39;getRosterElement&#39;</span><span class="p">,</span>
<span class="o">/**</span>
<span class="o">*</span> <span class="n">Returns</span> <span class="n">the</span> <span class="n">roster</span> <span class="n">widget</span> <span class="n">element</span><span class="o">.</span>
<span class="o">*</span> <span class="nd">@this</span> <span class="n">pinto</span><span class="o">.</span><span class="n">chat</span><span class="o">.</span><span class="n">RosterWidget</span>
<span class="o">*</span> <span class="nd">@return</span> <span class="p">{</span><span class="n">Element</span><span class="p">}</span>
<span class="o">*/</span>
<span class="n">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">getWrappedComponent_</span><span class="p">()</span><span class="o">.</span><span class="n">getElement</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
</td>
<td>标明一个特定方法在其上下文中被调用的对象类型。用于 <code class="docutils literal notranslate"><span class="pre">this</span></code> 关键字是从一个非原型方法中使用时</td>
</tr>
<tr class="row-odd"><td>&#64;type</td>
<td><p class="first">&#64;type Type
&#64;type {Type}</p>
<p>例如：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span>
</pre></div>
</div>
<blockquote>
<div><ul class="simple">
<li>The message hex ID.</li>
<li>&#64;type {string}</li>
</ul>
<p><a href="#system-message-8"><span class="problematic" id="problematic-8">*</span></a>/</p>
</div></blockquote>
<p class="last">var hexId = hexId;</p>
</td>
<td>标识变量，属性或表达式的 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#JsTypes">类型</a> 。大多数类型不需要大括号，但有些项目为了保持一致性而要求所有类型都使用大括号。</td>
</tr>
<tr class="row-even"><td>&#64;typedef</td>
<td><p class="first">&#64;typedef</p>
<p>例如：</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@typedef</span> <span class="p">{(</span><span class="n">string</span><span class="o">|</span><span class="n">number</span><span class="p">)}</span> <span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">NumberLike</span><span class="p">;</span>
<span class="o">/**</span> <span class="nd">@param</span> <span class="p">{</span><span class="n">goog</span><span class="o">.</span><span class="n">NumberLike</span><span class="p">}</span> <span class="n">x</span> <span class="n">A</span> <span class="n">number</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">string</span><span class="o">.</span> <span class="o">*/</span>
<span class="n">goog</span><span class="o">.</span><span class="n">readNumber</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td>使用此注释来声明一个更 <a class="reference external" href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Typedefs">复杂的类型</a> 的别名。</td>
</tr>
</tbody>
</table>
<p>你也许在第三方代码中看到其他类型JSDoc注释，这些注释出现在 <a class="reference external" href="https://code.google.com/p/jsdoc-toolkit/wiki/TagReference">JSDoc Toolkit标签的参考</a> ，但目前在谷歌的代码中不鼓励使用。你应该将他们当作“保留”字，他们包括：</p>
<ul class="simple">
<li>&#64;augments</li>
<li>&#64;argument</li>
<li>&#64;borrows</li>
<li>&#64;class</li>
<li>&#64;constant</li>
<li>&#64;constructs</li>
<li>&#64;default</li>
<li>&#64;event</li>
<li>&#64;example</li>
<li>&#64;field</li>
<li>&#64;function</li>
<li>&#64;ignore</li>
<li>&#64;inner</li>
<li>&#64;link</li>
<li>&#64;memberOf</li>
<li>&#64;name</li>
<li>&#64;namespace</li>
<li>&#64;property</li>
<li>&#64;public</li>
<li>&#64;requires</li>
<li>&#64;returns</li>
<li>&#64;since</li>
<li>&#64;static</li>
<li>&#64;version</li>
</ul>
</div>
</div>
<div class="section" id="goog-provide">
<h4>为goog.provide提供依赖</h4>
<p>只提供顶级符号。</p>
<p>一个类上定义的所有成员应该放在一个文件中。所以，在一个在相同类中定义的包含多个成员的文件中只应该提供顶级的类（例如枚举、内部类等）。</p>
<p>要这样写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;namespace.MyClass&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>不要这样写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;namespace.MyClass&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;namespace.MyClass.Enum&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;namespace.MyClass.InnerClass&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;namespace.MyClass.TypeDef&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;namespace.MyClass.CONSTANT&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;namespace.MyClass.staticMethod&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>命名空间的成员也应该提供：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;foo.bar&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;foo.bar.method&#39;</span><span class="p">);</span>
<span class="n">goog</span><span class="o">.</span><span class="n">provide</span><span class="p">(</span><span class="s1">&#39;foo.bar.CONSTANT&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-33">
<h4>编译</h4>
<p>必需。</p>
<p>对于所有面向客户的代码来说，使用JS编辑器是必需的，如使用 <a class="reference external" href="https://developers.google.com/closure/compiler/?csw=1">Closure Compiler</a> 。</p>
</div>
<div class="section" id="section-34">
<h4>技巧和诀窍</h4>
<p>JavaScript帮助信息</p>
<div class="section" id="truefalse">
<h5>True和False布尔表达式</h5>
<p>下边的布尔表达式都返回false：</p>
<ul class="simple">
<li>null</li>
<li>undefined</li>
<li>‘’空字符串</li>
<li>数字0</li>
</ul>
<p>但是要小心，因为以下这些返回true：</p>
<ul class="simple">
<li>字符串”0”</li>
<li>[]空数组</li>
<li>{}空对象</li>
</ul>
<p>下面这样写不好：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>你可以写成这种更短的代码（只要你不期望x为0、空字符串或者false）：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>如果你想检查字符串是否为null或空，你可以这样写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">!=</span> <span class="n">null</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>但是以下这样会更简练更好：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<p>注意：还有很多不直观的关于布尔表达式的例子，这里是一些：</p>
<ul class="simple">
<li>Boolean(‘0’) == true
‘0’ != true</li>
<li>0 != null
0 == []
0 == false</li>
<li>Boolean(null) == false
null != true
null != false</li>
<li>Boolean(undefined) == false
undefined != true
undefined != false</li>
<li>Boolean([]) == true
[] != true
[] == false</li>
<li>Boolean({}) == true
{} != true
{} != false</li>
</ul>
</div>
<div class="section" id="section-35">
<h5>条件（三元）操作符（？：）</h5>
<p>以下这种写法可以三元操作符替换：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">bar</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>你可以这样写来代替：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>return val ? foo() : bar();
</pre></div>
</div>
<p>三元操作符在生成HTML代码时也是很有用的：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>var html = &#39;&lt;input type=&quot;checkbox&quot;&#39; +
    (isChecked ? &#39; checked&#39; : &#39;&#39;) +
    (isEnabled ? &#39;&#39; : &#39; disabled&#39;) +
    &#39; name=&quot;foo&quot;&gt;&#39;;
</pre></div>
</div>
</div>
<div class="section" id="section-36">
<h5>&amp;&amp; 和 ||</h5>
<p>二元布尔操作符是可短路的,，只有在必要时才会计算到最后一项。</p>
<p>“||” 被称作为 ‘default’ 操作符，因为可以这样：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@param</span> <span class="p">{</span><span class="o">*=</span><span class="p">}</span> <span class="n">opt_win</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">opt_win</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">win</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">opt_win</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">win</span> <span class="o">=</span> <span class="n">opt_win</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">win</span> <span class="o">=</span> <span class="n">window</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>你可以这样写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/**</span> <span class="nd">@param</span> <span class="p">{</span><span class="o">*=</span><span class="p">}</span> <span class="n">opt_win</span> <span class="o">*/</span>
<span class="n">function</span> <span class="n">foo</span><span class="p">(</span><span class="n">opt_win</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">var</span> <span class="n">win</span> <span class="o">=</span> <span class="n">opt_win</span> <span class="o">||</span> <span class="n">window</span><span class="p">;</span>
  <span class="o">//</span> <span class="o">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>“&amp;&amp;” 也可以用来缩减代码。例如，以下这种写法可以被缩减：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">foo</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>你可以这样写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>或者这样写：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">kid</span> <span class="o">=</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">kid</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">kid</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然而以下这样写就有点过头了：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">foo</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kids</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-37">
<h5>遍历节点列表</h5>
<p>节点列表是通过给节点迭代器加一个过滤器来实现的。这表示获取他的属性，如length的时间复杂度为O(n)，通过length来遍历整个列表需要O(n^2)。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">paragraphs</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">paragraphs</span><span class="o">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">doSomething</span><span class="p">(</span><span class="n">paragraphs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这样写更好：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">paragraphs</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">getElementsByTagName</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">paragraph</span><span class="p">;</span> <span class="n">paragraph</span> <span class="o">=</span> <span class="n">paragraphs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">doSomething</span><span class="p">(</span><span class="n">paragraph</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这种方法对所有的集合和数组(只要数组不包含被认为是false值的元素) 都适用。</p>
<p>在上面的例子中，你也可以通过firstChild和nextSibling属性来遍历子节点。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">parentNode</span> <span class="o">=</span> <span class="n">document</span><span class="o">.</span><span class="n">getElementById</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">var</span> <span class="n">child</span> <span class="o">=</span> <span class="n">parentNode</span><span class="o">.</span><span class="n">firstChild</span><span class="p">;</span> <span class="n">child</span><span class="p">;</span> <span class="n">child</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">nextSibling</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">doSomething</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
<span id="document-google-typescript-styleguide/contents"></span><div class="section" id="typescript">
<h2>TypeScript 风格指南</h2>
<div class="toctree-wrapper compound">
<span id="document-google-typescript-styleguide/preface"></span><div class="section" id="section-1">
<h3>前言</h3>
<div class="section" id="section-2">
<span id="ts-introduction"></span><h4>简介</h4>
<p>这份风格指南基于谷歌的内部版本，并在此基础上做了一些修改，使其具有更广泛的适用性。指南并非定期自动部署，而是由志愿者们根据需求进行维护与更新。</p>
<p>指南中的内容包括代码规范与最佳实践两部分。读者可根据所在团队的需求加以参考和选用。</p>
<p>指南中对 <em>必须、禁止、应当、不应、可以</em> 等词语的用法遵循 <a class="reference external" href="https://datatracker.ietf.org/doc/html/rfc2119">RFC 2119</a> 中的定义。文中的所有示例均非适合实际项目的正式用法，只用于对指南中的内容加以说明。</p>
</div>
<div class="section" id="section-3">
<span id="ts-about"></span><h4>翻译信息</h4>
<div class="section" id="section-4">
<span id="ts-about-last-update"></span><h5>上次更新日期</h5>
<p>2021 年 09 月 02 日。</p>
</div>
<div class="section" id="section-5">
<span id="ts-about-author"></span><h5>作者</h5>
<ul class="simple">
<li><a class="reference external" href="https://github.com/tinkerrobot">TinkerRobot</a></li>
</ul>
</div>
<div class="section" id="section-6">
<span id="ts-about-original"></span><h5>原文链接</h5>
<p><a class="reference external" href="https://google.github.io/styleguide/tsguide.html">Google TypeScript Style Guide</a></p>
</div>
<div class="section" id="section-7">
<span id="ts-about-translation"></span><h5>中文版链接</h5>
<p><a class="reference external" href="https://zh-google-styleguide.readthedocs.io/en/latest/google-typescript-styleguide/">谷歌 TypeScript 风格指南</a></p>
</div>
<div class="section" id="section-8">
<span id="ts-about-changelog"></span><h5>修订历史</h5>
<ul class="simple">
<li><strong>2021 年 09 月 02 日：</strong> <a class="reference external" href="https://github.com/tinkerrobot">TinkerRobot</a> 提交了第一个版本。</li>
</ul>
</div>
</div>
</div>
<span id="document-google-typescript-styleguide/syntax"></span><div class="section" id="section-1">
<h3>语法规范</h3>
<div class="section" id="section-2">
<span id="ts-identifiers"></span><h4>标识符</h4>
<div class="section" id="section-3">
<span id="ts-naming"></span><h5>命名规范</h5>
<p>在 TypeScript 中，标识符只能使用 ASCII 码表中的字母、数字、下划线与 <code class="docutils literal notranslate"><span class="pre">(</span></code>。因此，合法的标识符可以使用正则表达式 <code class="docutils literal notranslate"><span class="pre">[\)\w]+</span></code> 进行匹配。根据标识符的用途不同，使用的命名法也不同，如下表所示：</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">命名法</th>
<th class="head">分类</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>帕斯卡命名法（ <code class="docutils literal notranslate"><span class="pre">UpperCamelCase</span></code> ）</td>
<td>类、接口、类型、枚举、装饰器、类型参数</td>
</tr>
<tr class="row-odd"><td>驼峰式命名法（ <code class="docutils literal notranslate"><span class="pre">lowerCamelCase</span></code> ）</td>
<td>变量、参数、函数、方法、属性、模块别名</td>
</tr>
<tr class="row-even"><td>全大写下划线命名法（ <code class="docutils literal notranslate"><span class="pre">CONSTANT_CASE</span></code>）</td>
<td>全局常量、枚举值</td>
</tr>
<tr class="row-odd"><td>私有成员命名法（ <code class="docutils literal notranslate"><span class="pre">#ident</span></code> ）</td>
<td>不允许使用</td>
</tr>
</tbody>
</table>
<div class="section" id="section-4">
<span id="ts-abbreviations"></span><h6>缩写</h6>
<p>缩写应被视为一个词。例如，应使用 <code class="docutils literal notranslate"><span class="pre">loadHttpUrl</span></code>，而非 <code class="docutils literal notranslate"><span class="pre">loadHTTPURL</span></code>。平台有特殊要求的标识符例外，如 <code class="docutils literal notranslate"><span class="pre">XMLHttpRequest</span></code>。</p>
</div>
<div class="section" id="section-5">
<span id="ts-dollar-sign"></span><h6>美元符号 $</h6>
<p>一般情况下，标识符不应使用 <cite>$</cite>，除非为了与第三方框架的命名规范保持一致。关于 <cite>$</cite> 的使用，可参见 <a class="reference internal" href="#ts-naming-style"><span class="std std-ref">命名风格</span></a> 一节对 <code class="docutils literal notranslate"><span class="pre">Observable</span></code> 类型的说明。</p>
</div>
<div class="section" id="section-6">
<span id="ts-type-parameters"></span><h6>类型参数</h6>
<p>形如 <code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> 的类型参数既可以使用单个大写字母（如 <code class="docutils literal notranslate"><span class="pre">T</span></code>），也可以使用帕斯卡命名法（如 <code class="docutils literal notranslate"><span class="pre">UpperCamelCase</span></code>）。</p>
</div>
<div class="section" id="section-7">
<span id="ts-test-names"></span><h6>测试用例</h6>
<p>无论是在 <a class="reference external" href="https://github.com/google/closure-library">Closure</a> 库的 <code class="docutils literal notranslate"><span class="pre">testSuites</span></code> 还是 <a class="reference external" href="https://xunit.net/">xUnit</a> 风格的测试框架中，都可以使用 <code class="docutils literal notranslate"><span class="pre">_</span></code> 作为标识符的分隔符，例如 <code class="docutils literal notranslate"><span class="pre">testX_whenY_doesZ()</span></code>。</p>
</div>
<div class="section" id="section-8">
<span id="ts-underscore-prefix-suffix"></span><h6><code class="docutils literal notranslate"><span class="pre">_</span></code> 前缀与后缀</h6>
<p>标识符禁止使用下划线 <code class="docutils literal notranslate"><span class="pre">_</span></code> 作为前缀或后缀。这也意味着，禁止使用单个下划线 <code class="docutils literal notranslate"><span class="pre">_</span></code> 作为标识符（例如：用来表示未被使用的参数）。</p>
<p>如果需要从数组或元组中取出某个或某几个特定的元素的话，可以在解构语句中插入额外的逗号，忽略掉不需要的元素：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>  <span class="c1">// a &lt;- 1, b &lt;- 10</span>
</pre></div>
</div>
</div>
<div class="section" id="section-9">
<span id="ts-imports"></span><h6>导入模块</h6>
<p>导入模块的命名空间时使用驼峰命名法（<code class="docutils literal notranslate"><span class="pre">lowerCamelCase</span></code>），文件名则使用蛇形命名法（<code class="docutils literal notranslate"><span class="pre">snake_case</span></code>）。例如：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">fooBar</span> <span class="nx">from</span> <span class="s1">&#39;./foo_bar&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>一些库可能会在导入命名空间时使用某种特定的前缀，这与这里规定的命名规范有所冲突。然而，由于其中的一些库已经被广泛使用，因此遵循它们的特殊规则反而能够获得更好的可读性。这些特例包括：</p>
<ul class="simple">
<li><a class="reference external" href="https://jquery.com/">jQuery</a>，使用 <code class="docutils literal notranslate"><span class="pre">$</span></code> 前缀。</li>
<li><a class="reference external" href="https://threejs.org/">three.js</a>，使用 <code class="docutils literal notranslate"><span class="pre">THREE</span></code> 前缀。</li>
</ul>
</div>
<div class="section" id="section-10">
<span id="ts-constants"></span><h6>常量</h6>
<p>常量命名（<code class="docutils literal notranslate"><span class="pre">CONSTANT_CASE</span></code>）表示某个值不可被修改。它还可以用于虽然技术上可以实现，但是用户不应当试图修改的值，比如并未进行深度冻结（deep frozen）的值。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">UNIT_SUFFIXES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;milliseconds&#39;</span><span class="o">:</span> <span class="s1">&#39;ms&#39;</span><span class="p">,</span>
    <span class="s1">&#39;seconds&#39;</span><span class="o">:</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span>
<span class="p">};</span>
<span class="c1">// UNIT_SUFFIXES 使用了常量命名，</span>
<span class="c1">// 这意味着用户不应试图修改它，</span>
<span class="c1">// 即使它实际上是一个可变的值。</span>
</pre></div>
</div>
<p>这里所说的常量，也包括类中的静态只读属性：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="kr">static</span> <span class="nx">readonly</span> <span class="nx">MY_SPECIAL_NUMBER</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

    <span class="nx">bar() {</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">Foo</span><span class="p">.</span><span class="nx">MY_SPECIAL_NUMBER</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-11">
<span id="ts-others"></span><h6>其他</h6>
<p>如果某个值在程序的整个运行生命周期中会被多次实例化或被用户以任何方式进行修改，则它必须使用驼峰式命名法。</p>
<p>如果某个值是作为某个接口的实现的箭头函数，则它也可以使用驼峰式命名法。</p>
</div>
</div>
<div class="section" id="section-12">
<span id="ts-aliases"></span><h5>别名</h5>
<p>在为一个已有的标识符创建具有局部作用域的别名时，别名的命名方式应当与现有的标识符和现有的命名规范保持一致。声明别名时，应使用 <code class="docutils literal notranslate"><span class="pre">const</span></code> （如果它是一个变量）或 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> （如果它是类里的一个字段）。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="p">{</span><span class="nx">Foo</span><span class="p">}</span> <span class="o">=</span> <span class="nx">SomeType</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">CAPACITY</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">Teapot</span> <span class="p">{</span>
    <span class="nx">readonly</span> <span class="nx">BrewStateEnum</span> <span class="o">=</span> <span class="nx">BrewStateEnum</span><span class="p">;</span>
    <span class="nx">readonly</span> <span class="nx">CAPACITY</span> <span class="o">=</span> <span class="nx">CAPACITY</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-13">
<span id="ts-naming-style"></span><h5>命名风格</h5>
<p>TypeScript 中的类型表达了丰富的信息，因此在起名时不应与类型中所携带的信息重复。（关于更多在起名时应避免的内容，可参见谷歌的 <a class="reference external" href="https://testing.googleblog.com/2017/10/code-health-identifiernamingpostforworl.html">Testing Blog</a>。）</p>
<p>这里有几个具体的例子：</p>
<ul class="simple">
<li>不要为私有属性或方法名添加下划线 <cite>_</cite> 前缀或后缀。</li>
<li>不要为可选参数添加 <cite>opt_</cite> 前缀。<ul>
<li>关于在存取器中的特例，参见后文 <a class="reference internal" href="contents.html#name-and-order-of-includes"><span class="std std-ref">1.5. #include 的路径及顺序</span></a> 。</li>
</ul>
</li>
<li>除非在项目中已成惯例，否则不要显式地标记接口类型（例如不要使用 <code class="docutils literal notranslate"><span class="pre">IMyInterface</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">MyFooInterface</span></code> ）。在为类添加接口时，接口名称中应包含创建这一接口的原因。（例如，在为类 <code class="docutils literal notranslate"><span class="pre">TodoItem</span></code> 创建一个将其转为 JSON 格式以用于存储或者序列化的接口时，可以将这一接口命名为 <code class="docutils literal notranslate"><span class="pre">TodoItemStorage</span></code> 。）</li>
<li>对于 <code class="docutils literal notranslate"><span class="pre">Observable</span></code> 类型的值，通常的惯例是使用 <code class="docutils literal notranslate"><span class="pre">$</span></code> 前缀将其与一般类型的值进行区分，使之不致混淆。各个团队可以在与项目内部的现有做法保持一致的前提下，自行决定是否采用这一做法。</li>
</ul>
</div>
<div class="section" id="section-14">
<span id="ts-descriptive-names"></span><h5>描述性命名</h5>
<p>命名应当具有描述性且易于读者理解。不要使用对项目以外的用户而言含糊不清或并不熟悉的缩写，不要通过删减单词中的字母来强行创造缩写。</p>
<p>这一规则的例外是，对不超过十行的作用域中的变量，以及内部 API 的参数，可以使用短变量名（例如 <code class="docutils literal notranslate"><span class="pre">i</span></code> 、 <code class="docutils literal notranslate"><span class="pre">j</span></code> 等只有单个字母的变量名）。</p>
</div>
</div>
<div class="section" id="section-15">
<span id="ts-file-encoding"></span><h4>文件编码</h4>
<p>使用 UTF-8 文件编码。</p>
<p>对于非 ASCII 字符，应使用实际的 Unicode 字符（例如 <code class="docutils literal notranslate"><span class="pre">∞</span></code> ）。对于非输出字符，使用对应的十六进制编码或 Unicode 转义编码（如 <code class="docutils literal notranslate"><span class="pre">\u221e</span></code> ），并添加注释进行说明。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！即使没有注释也十分易懂。</span>
<span class="kr">const</span> <span class="nx">units</span> <span class="o">=</span> <span class="s1">&#39;μs&#39;</span><span class="p">;</span>

<span class="c1">// 应当这样做！对非输出字符进行转义。</span>
<span class="kr">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="s1">&#39;\ufeff&#39;</span> <span class="o">+</span> <span class="nx">content</span><span class="p">;</span>  <span class="c1">// 字节顺序标记（Byte Order Mark，BOM）</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！即使加上注释也不太好读，而且容易出错。</span>
<span class="kr">const</span> <span class="nx">units</span> <span class="o">=</span> <span class="s1">&#39;\u03bcs&#39;</span><span class="p">;</span> <span class="c1">// Greek letter mu, &#39;s&#39;</span>

<span class="c1">// 不要省略注释！读者在缺少注释的情况下很难理解这个字符的含义。</span>
<span class="kr">const</span> <span class="nx">output</span> <span class="o">=</span> <span class="s1">&#39;\ufeff&#39;</span> <span class="o">+</span> <span class="nx">content</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-16">
<span id="ts-comments-documentation"></span><h4>注释与文档</h4>
<div class="section" id="jsdoc">
<span id="ts-jsdoc-vs-comments"></span><h5>用 JSDoc 还是 注释？</h5>
<p>TypesScript 中有两种类型的注释：JSDoc <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">...</span> <span class="pre">*/</span></code> 和普通注释 <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">...</span> <span class="pre">或者</span> <span class="pre">/*</span> <span class="pre">...</span> <span class="pre">*/</span></code> 。</p>
<ul class="simple">
<li>对于文档，也就是用户应当阅读的注释，使用 <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">JSDoc</span> <span class="pre">*/</span></code> 。</li>
<li>对于实现说明，也就是只和代码本身的实现细节有关的注释，使用 <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">行注释</span></code> 。</li>
</ul>
<p>JSDoc 注释能够为工具（例如编辑器或文档生成器）所识别，而普通注释只能供人阅读。</p>
</div>
<div class="section" id="jsdoc-1">
<span id="ts-jsdoc-rules-follow-the-js-style"></span><h5>JSDoc 规范</h5>
<p>JSDoc 的规范大部分遵循 JavaScript 风格指南中的规定。具体地说，遵循 JavaScript 风格指南中 <a class="reference internal" href="contents.html#js-comments"><span class="std std-ref">注释</span></a> 一节的规则。本节的剩余部分只对与这些规则不一致的部分进行说明。</p>
</div>
<div class="section" id="section-17">
<span id="ts-document-all-top-level-exports-of-modules"></span><h5>对所有导出的顶层模块进行注释</h5>
<p>使用 <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">JSDoc</span> <span class="pre">*/</span></code> 注释为代码的用户提供信息。这些注释应当言之有物，切忌仅仅将属性名或参数名重抄一遍。如果代码的审核人认为某个属性或方法的作用不能从它的名字上一目了然地看出来的话，这些属性和方法同样应当使用 <code class="docutils literal notranslate"><span class="pre">/**</span> <span class="pre">JSDoc</span> <span class="pre">*/</span></code> 注释添加说明文档，无论它们是否被导出，是公开还是私有的。</p>
</div>
<div class="section" id="typescript">
<span id="ts-omit-comments-that-are-redundant-with-ts"></span><h5>省略对于 TypeScript 而言多余的注释</h5>
<p>例如，不要在 <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&#64;return</span></code> 注释中声明类型，不要在使用了 <code class="docutils literal notranslate"><span class="pre">implements</span></code> 、 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 、 <code class="docutils literal notranslate"><span class="pre">private</span></code> 等关键字的地方添加 <code class="docutils literal notranslate"><span class="pre">&#64;implements</span></code> 、 <code class="docutils literal notranslate"><span class="pre">&#64;enum</span></code> 、 <code class="docutils literal notranslate"><span class="pre">&#64;private</span></code> 等注释。</p>
</div>
<div class="section" id="override">
<span id="ts-do-not-use-override"></span><h5>不要使用 <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code></h5>
<p>不要在 TypeScript 代码中使用 <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code> 注释。 <code class="docutils literal notranslate"><span class="pre">&#64;override</span></code> 并不会被编译器视为强制性约束，这会导致注释与实现上的不一致性。如果纯粹为了文档添加这一注释，反而令人困惑。</p>
</div>
<div class="section" id="section-18">
<span id="ts-make-comments-that-actually-add-information"></span><h5>注释必须言之有物</h5>
<p>虽然大多数情况下文档对代码十分有益，但对于那些并不用于导出的符号，有时其函数或参数的名称与类型便足以描述自身了。</p>
<p>注释切忌照抄参数类型和参数名，如下面的反面示例：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！这个注释没有任何有意义的内容。</span>
<span class="cm">/** @param fooBarService Foo 应用的 Bar 服务 */</span>
</pre></div>
</div>
<p>因此，只有当需要添加额外信息时才使用 <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 和 <code class="docutils literal notranslate"><span class="pre">&#64;return</span></code> 注释，其它情况下直接省略即可。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * 发送 POST 请求，开始煮咖啡</span>
<span class="cm"> * @param amountLitres 煮咖啡的量，注意和煮锅的尺寸对应！</span>
<span class="cm"> */</span>
<span class="nx">brew</span><span class="p">(</span><span class="nx">amountLitres</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">logger</span>: <span class="kt">Logger</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-19">
<span id="ts-parameter-property-comments"></span><h5>参数属性注释</h5>
<p>通过为构造函数的参数添加访问限定符，参数属性同时创建了构造函数参数和类成员。例如，如下的构造函数</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">(</span><span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">bar</span>: <span class="kt">Bar</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 类创建了 <code class="docutils literal notranslate"><span class="pre">Bar</span></code> 类型的成员 <code class="docutils literal notranslate"><span class="pre">bar</span></code> 。</p>
<p>如果要为这些成员添加文档，应使用 JSDoc 的 <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 注释，这样编辑器会在调用构造函数和访问属性时显示对应的文档描述信息。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="cm">/** 这个类演示了如何为参数属性添加文档 */</span>
<span class="kr">class</span> <span class="nx">ParamProps</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * @param percolator 煮咖啡所用的咖啡壶。</span>
<span class="cm">     * @param beans 煮咖啡所用的咖啡豆。</span>
<span class="cm">     */</span>
    <span class="kr">constructor</span><span class="p">(</span>
        <span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">percolator</span>: <span class="kt">Percolator</span><span class="p">,</span>
        <span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">beans</span>: <span class="kt">CoffeeBean</span><span class="p">[])</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="cm">/** 这个类演示了如何为普通成员添加文档 */</span>
<span class="kr">class</span> <span class="nx">OrdinaryClass</span> <span class="p">{</span>
    <span class="cm">/** 下次调用 brew() 时所用的咖啡豆。 */</span>
    <span class="nx">nextBean</span>: <span class="kt">CoffeeBean</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">initialBean</span>: <span class="kt">CoffeeBean</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">nextBean</span> <span class="o">=</span> <span class="nx">initialBean</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-20">
<span id="ts-comments-when-calling-a-function"></span><h5>函数调用注释</h5>
<p>如果有需要，可以在函数的调用点使用行内的 <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">块注释</span> <span class="pre">*/</span></code> 为参数添加文档，或者使用字面量对象为参数添加名称并在函数声明中进行解构。注释的格式和位置没有明确的规定。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用行内块注释为难以理解的参数添加说明：</span>
<span class="k">new</span> <span class="nx">Percolator</span><span class="p">().</span><span class="nx">brew</span><span class="p">(</span><span class="cm">/* amountLitres= */</span> <span class="mi">5</span><span class="p">);</span>

<span class="c1">// 或者使用字面量对象为参数命名，并在函数 brew 的声明中将参数解构：</span>
<span class="k">new</span> <span class="nx">Percolator</span><span class="p">().</span><span class="nx">brew</span><span class="p">({</span><span class="nx">amountLitres</span>: <span class="kt">5</span><span class="p">});</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="cm">/** 一个古老的咖啡壶 {@link CoffeeBrewer} */</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">Percolator</span> <span class="kr">implements</span> <span class="nx">CoffeeBrewer</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * 煮咖啡。</span>
<span class="cm">     * @param amountLitres 煮咖啡的量，注意必须和煮锅的尺寸对应！</span>
<span class="cm">     */</span>
    <span class="nx">brew</span><span class="p">(</span><span class="nx">amountLitres</span>: <span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 这个实现煮出来的咖啡味道差极了，不管了。</span>
        <span class="c1">// TODO(b/12345): 优化煮咖啡的过程。</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-21">
<span id="ts-place-documentation-prior-to-decorators"></span><h5>将文档置于装饰器之前</h5>
<p>文档、方法或者属性如果同时具有装饰器（例如 <code class="docutils literal notranslate"><span class="pre">&#64;Component</span></code>）和 JSDoc 注释，应当将 JSDoc 置于装饰器之前。</p>
<p>禁止将 JSDoc 置于装饰器和被装饰的对象之间。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！JSDoc 被放在装饰器 @Component 和类 FooComponent 中间了！</span>
<span class="kd">@Component</span><span class="p">({</span>
    <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
<span class="p">})</span>
<span class="cm">/** 打印 &quot;bar&quot; 的组件。 */</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">FooComponent</span> <span class="p">{}</span>
</pre></div>
</div>
<p>应当将 JSDoc 置于装饰器之前。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="cm">/** 打印 &quot;bar&quot; 的组件。 */</span>
<span class="kd">@Component</span><span class="p">({</span>
    <span class="nx">selector</span><span class="o">:</span> <span class="s1">&#39;foo&#39;</span><span class="p">,</span>
    <span class="nx">template</span><span class="o">:</span> <span class="s1">&#39;bar&#39;</span><span class="p">,</span>
<span class="p">})</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">FooComponent</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-google-typescript-styleguide/language"></span><div class="section" id="section-1">
<h3>语言特性</h3>
<div class="section" id="section-2">
<span id="ts-visibility"></span><h4>可见性</h4>
<p>限制属性、方法以及类型的可见性有助于代码解耦合。因此：</p>
<ul class="simple">
<li>应当尽可能限制符号的可见性。</li>
<li>可以将私有方法在同一文件中改写为独立于所有类以外的内部函数，并将私有属性移至单独的内部类中。</li>
<li>在 TypeScript 中，符号默认的可见性即为 <code class="docutils literal notranslate"><span class="pre">public</span></code> ，因此，除了在构造函数中声明公开（ <code class="docutils literal notranslate"><span class="pre">public</span></code> ）且非只读（ <code class="docutils literal notranslate"><span class="pre">readonly</span></code> ）的参数属性之外，不要使用 <code class="docutils literal notranslate"><span class="pre">public</span></code> 修饰符。</li>
</ul>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Bar</span><span class="p">();</span>  <span class="c1">// 不要这样做！不需要 public 修饰符！</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="kr">public</span> <span class="nx">readonly</span> <span class="nx">baz</span>: <span class="kt">Baz</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 不要这样做！readonly 修饰符已经表明了 baz 是默认 public 的属性，因此不需要 public 修饰符！</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="nx">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Bar</span><span class="p">();</span>  <span class="c1">// 应当这样做！将不需要的 public 修饰符省略！</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="kr">public</span> <span class="nx">baz</span>: <span class="kt">Baz</span><span class="p">)</span> <span class="p">{}</span>  <span class="c1">// 可以这样做！公开且非只读的参数属性允许使用 public 修饰符！</span>
<span class="p">}</span>
</pre></div>
</div>
<p>关于可见性，还可参见 <a class="reference internal" href="contents.html#ts-export-visibility"><span class="std std-ref">导出可见性</span></a> 一节。</p>
</div>
<div class="section" id="section-3">
<span id="ts-constructors"></span><h4>构造函数</h4>
<p>调用构造函数时必须使用括号，即使不传递任何参数。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">;</span>

<span class="c1">// 应当这样做！</span>
<span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Foo</span><span class="p">();</span>
</pre></div>
</div>
<p>没有必要提供一个空的或者仅仅调用父类构造函数的构造函数。在 ES2015 标准中，如果没有为类显式地提供构造函数，编译器会提供一个默认的构造函数。但是，含有参数属性、访问修饰符或参数装饰器的构造函数即使函数体为空也不能省略。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！没有必要声明一个空的构造函数！</span>
<span class="kr">class</span> <span class="nx">UnnecessaryConstructor</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！没有必要声明一个仅仅调用基类构造函数的构造函数！</span>
<span class="kr">class</span> <span class="nx">UnnecessaryConstructorOverride</span> <span class="kr">extends</span> <span class="nx">Base</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">super</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！默认构造函数由编译器提供即可！</span>
<span class="kr">class</span> <span class="nx">DefaultConstructor</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">// 应当这样做！含有参数属性的构造函数不能省略！</span>
<span class="kr">class</span> <span class="nx">ParameterProperties</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">(</span><span class="kr">private</span> <span class="nx">myService</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 应当这样做！含有参数装饰器的构造函数不能省略！</span>
<span class="kr">class</span> <span class="nx">ParameterDecorators</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">(</span><span class="kd">@SideEffectDecorator</span> <span class="nx">myService</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="c1">// 应当这样做！私有的构造函数不能省略！</span>
<span class="kr">class</span> <span class="nx">NoInstantiation</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="kr">constructor</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<span id="ts-class-members"></span><h4>类成员</h4>
<div class="section" id="private">
<span id="ts-no-private-fields"></span><h5><code class="docutils literal notranslate"><span class="pre">#private</span></code> 语法</h5>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">#private</span></code> 私有字段（又称私有标识符）语法声明私有成员。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span>// 不要这样做！
class Clazz {
    #ident = 1;
}
</pre></div>
</div>
<p>而应当使用 TypeScript 的访问修饰符。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">class</span> <span class="nx">Clazz</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="nx">ident</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为什么？因为私有字段语法会导致 TypeScipt 在编译为 JavaScript 时出现体积和性能问题。同时，ES2015 之前的标准都不支持私有字段语法，因此它限制了 TypeScript 最低只能被编译至 ES2015。另外，在进行静态类型和可见性检查时，私有字段语法相比访问修饰符并无明显优势。</p>
</div>
<div class="section" id="readonly">
<span id="ts-use-readonly"></span><h5>使用 <code class="docutils literal notranslate"><span class="pre">readonly</span></code></h5>
<p>对于不会在构造函数以外进行赋值的属性，应使用 <code class="docutils literal notranslate"><span class="pre">readonly</span></code> 修饰符标记。这些属性并不需要具有深层不可变性。</p>
</div>
<div class="section" id="section-5">
<h5>参数属性</h5>
<p>不要在构造函数中显式地对类成员进行初始化。应当使用 TypeScript 的 <a class="reference external" href="https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties">参数属性</a> 语法。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！重复的代码太多了！</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">barService</span>: <span class="kt">BarService</span><span class="p">;</span>

    <span class="kr">constructor</span><span class="p">(</span><span class="nx">barService</span>: <span class="kt">BarService</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">barService</span> <span class="o">=</span> <span class="nx">barService</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！简洁明了！</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">(</span><span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">barService</span>: <span class="kt">BarService</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果需要为参数属性添加文档，应使用 JSDoc 的 <code class="docutils literal notranslate"><span class="pre">&#64;param</span></code> 标签，参见 <a class="reference internal" href="contents.html#ts-parameter-property-comments"><span class="std std-ref">参数属性注释</span></a> 一节。</p>
</div>
<div class="section" id="section-6">
<h5>字段初始化</h5>
<p>如果某个成员并非参数属性，应当在声明时就对其进行初始化，这样有时可以完全省略掉构造函数。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！没有必要单独把初始化语句放在构造函数里！</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">userList</span>: <span class="kt">string</span><span class="p">[];</span>
    <span class="kr">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">userList</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！省略了构造函数！</span>
<span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">userList</span>: <span class="kt">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<span id="ts-properties-used-outside-of-class-lexical-scope"></span><h5>用于类的词法范围之外的属性</h5>
<p>如果一个属性被用于它们所在类的词法范围之外，例如用于模板（template）的 AngularJS 控制器（controller）属性，则禁止将其设为 <code class="docutils literal notranslate"><span class="pre">private</span></code> ，因为显然这些属性是用于外部的。</p>
<p>对于这类属性，应当将其设为 <code class="docutils literal notranslate"><span class="pre">public</span></code> ，如果有需要的话也可以使用 <code class="docutils literal notranslate"><span class="pre">protected</span></code> 。例如，Angular 和 Polymer 的模板属性应使用 <code class="docutils literal notranslate"><span class="pre">public</span></code> ，而 AngularJS 应使用 <code class="docutils literal notranslate"><span class="pre">protected</span></code> 。</p>
<p>此外，禁止在 TypeScript 代码中使用 <code class="docutils literal notranslate"><span class="pre">obj['foo']</span></code> 语法绕过可见性限制进行访问。</p>
<p>为什么？</p>
<p>如果一个属性被设为 <code class="docutils literal notranslate"><span class="pre">private</span></code>，就相当于向自动化工具和读者声明对这个属性的访问局限于类的内部。例如，用于查找未被使用的代码的工具可能会将一个私有属性标记为未使用，即使在其它文件中有代码设法绕过了可见性限制对其进行访问。</p>
<p>虽然 <code class="docutils literal notranslate"><span class="pre">obj['foo']</span></code> 可以绕过 TypeScript 编译器对可见性的检查，但是这种访问方法可能会由于调整了构建规则而失效。此外，它也违反了后文中所提到的 <a class="reference internal" href="#ts-optimization-compatibility-for-property-access"><span class="std std-ref">优化属性访问的兼容性</span></a> 规则。</p>
</div>
<div class="section" id="section-8">
<span id="ts-getters-and-setters-accessors"></span><h5>取值器与设值器（存取器）</h5>
<p>可以在类中使用存取器，其中取值器方法必须是纯函数（即结果必须是一致稳定的，且不能有副作用）。存取器还可以用于隐藏内部复杂的实现细节。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">(</span><span class="kr">private</span> <span class="nx">readonly</span> <span class="nx">someService</span>: <span class="kt">SomeService</span><span class="p">)</span> <span class="p">{}</span>

    <span class="nx">get</span> <span class="nx">someMember</span><span class="p">()</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">someService</span><span class="p">.</span><span class="nx">someVariable</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">set</span> <span class="nx">someMember</span><span class="p">(</span><span class="nx">newValue</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">someService</span><span class="p">.</span><span class="nx">someVariable</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果存取器被用于隐藏类内部的某个属性，则被隐藏的属性应当以诸如 <code class="docutils literal notranslate"><span class="pre">internal</span></code> 或 <code class="docutils literal notranslate"><span class="pre">wrapped</span></code> 此类的完整单词作为前缀或后缀。在使用这些私有属性时，应当尽可能地通过存取器进行访问。取值器和设值器二者至少要有一个是非平凡的，也就是说，存取器不能只用于传递属性值，更不能依赖这种存取器对属性进行隐藏。这种情况下，应当直接将属性设为 <code class="docutils literal notranslate"><span class="pre">public</span></code>。对于只有取值器没有设值器的属性，则应当考虑直接将其设为 <code class="docutils literal notranslate"><span class="pre">readonly</span></code>。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="nx">wrappedBar</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="nx">get</span> <span class="nx">bar() {</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">wrappedBar</span> <span class="o">||</span> <span class="s1">&#39;bar&#39;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">set</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">wrapped</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">wrappedBar</span> <span class="o">=</span> <span class="nx">wrapped</span><span class="p">.</span><span class="nx">trim</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Bar</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="nx">barInternal</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="c1">// 不要这样做！取值器和设值器都没有任何逻辑，这种情况下应当直接将属性 bar 设为 public。</span>
    <span class="nx">get</span> <span class="nx">bar() {</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">barInternal</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">set</span> <span class="nx">bar</span><span class="p">(</span><span class="nx">value</span>: <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">barInternal</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-9">
<span id="ts-primitive-types-wrapper-classes"></span><h4>原始类型与封装类</h4>
<p>在 TypeScript 中，不要实例化原始类型的封装类，例如 <code class="docutils literal notranslate"><span class="pre">String</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Boolean</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Number</span></code> 等。封装类有许多不合直觉的行为，例如 <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Boolean(false)</span></code> 在布尔表达式中会被求值为 <code class="docutils literal notranslate"><span class="pre">true</span></code>。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">String</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-10">
<span id="ts-array-constructor"></span><h4>数组构造函数</h4>
<p>在 TypeScript 中，禁止使用 <code class="docutils literal notranslate"><span class="pre">Array()</span></code> 构造函数（无论是否使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 关键字）。它有许多不合直觉又彼此矛盾的行为，例如：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！同样的构造函数，其构造方式却却完全不同！</span>
<span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="c1">// 参数 2 被视作数组的长度，因此返回的结果是 [undefined, undefined]</span>
<span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 参数 2, 3 被视为数组中的元素，返回的结果此时变成了 [2, 3]</span>
</pre></div>
</div>
<p>应当使用方括号对数组进行初始化，或者使用 <code class="docutils literal notranslate"><span class="pre">from</span></code> 构造一个具有确定长度的数组：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>

<span class="c1">// 等价于 Array(2)：</span>
<span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">[];</span>
<span class="nx">c</span><span class="p">.</span><span class="nx">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// 生成 [0, 0, 0, 0, 0]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">({</span><span class="nx">length</span>: <span class="kt">5</span><span class="p">}).</span><span class="nx">fill</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-11">
<span id="ts-type-coercion"></span><h4>强制类型转换</h4>
<p>在 TypeScript 中，可以使用 <code class="docutils literal notranslate"><span class="pre">String()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Boolean()</span></code> 函数（注意不能和 <code class="docutils literal notranslate"><span class="pre">new</span></code> 一起使用！）、模板字符串和 <code class="docutils literal notranslate"><span class="pre">!!</span></code> 运算符进行强制类型转换。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="kt">bool</span> <span class="o">=</span> <span class="nb">Boolean</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="nb">String</span><span class="p">(</span><span class="nx">aNumber</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">bool2</span> <span class="o">=</span> <span class="o">!!</span><span class="nx">str</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">str2</span> <span class="o">=</span> <span class="sb">`result: </span><span class="si">${</span><span class="nx">bool2</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
</pre></div>
</div>
<p>不建议通过字符串连接操作将类型强制转换为 <code class="docutils literal notranslate"><span class="pre">string</span></code> ，这会导致加法运算符两侧的运算对象具有不同的类型。</p>
<p>在将其它类型转换为数字时，必须使用 <code class="docutils literal notranslate"><span class="pre">Number()</span></code> 函数，并且，在类型转换有可能失败的场合，必须显式地检查其返回值是否为 <code class="docutils literal notranslate"><span class="pre">NaN</span></code> 。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">Number('')</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Number('</span> <span class="pre">')</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Number('\t')</span></code> 返回 <code class="docutils literal notranslate"><span class="pre">0</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">NaN</span></code> 。 <code class="docutils literal notranslate"><span class="pre">Number('Infinity')</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Number('-Infinity')</span></code> 分别返回 <code class="docutils literal notranslate"><span class="pre">Infinity</span></code> 和 <code class="docutils literal notranslate"><span class="pre">-Infinity</span></code> 。这些情况可能需要特殊处理。</p>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">aNumber</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">aNumber</span><span class="p">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(...);</span>  <span class="c1">// 如果输入字符串有可能无法被解析为数字，就需要处理返回 NaN 的情况。</span>
<span class="nx">assertFinite</span><span class="p">(</span><span class="nx">aNumber</span><span class="p">,</span> <span class="p">...);</span>                <span class="c1">// 如果输入字符串已经保证合法，可以在这里添加断言。</span>
</pre></div>
</div>
<p>禁止使用一元加法运算符 <code class="docutils literal notranslate"><span class="pre">+</span></code> 将字符串强制转换为数字。用这种方法进行解析有失败的可能，还有可能出现奇怪的边界情况。而且，这样的写法往往成为代码中的坏味道， <code class="docutils literal notranslate"><span class="pre">+</span></code> 在代码审核中非常容易被忽略掉。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="o">+</span><span class="nx">y</span><span class="p">;</span>
</pre></div>
</div>
<p>同样地，代码中也禁止使用 <code class="docutils literal notranslate"><span class="pre">parseInt</span></code> 或 <code class="docutils literal notranslate"><span class="pre">parseFloat</span></code> 进行转换，除非用于解析表示非十进制数字的字符串。因为这两个函数都会忽略字符串中的后缀，这有可能在无意间掩盖了一部分原本会发生错误的情形（例如将 <code class="docutils literal notranslate"><span class="pre">12</span> <span class="pre">dwarves</span></code> 解析成 <code class="docutils literal notranslate"><span class="pre">12</span></code>）。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">someString</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>  <span class="c1">// 无论传不传基数，</span>
<span class="kr">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">someString</span><span class="p">);</span>    <span class="c1">// 都很容易造成错误。</span>
</pre></div>
</div>
<p>对于需要解析非十进制数字的情况，在调用 <code class="docutils literal notranslate"><span class="pre">parseInt</span></code> 进行解析之前必须检查输入是否合法。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="sr">/^[a-fA-F0-9]+$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">someString</span><span class="p">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(...);</span>
<span class="c1">// 需要解析 16 进制数。</span>
<span class="c1">// tslint:disable-next-line:ban</span>
<span class="kr">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">someString</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>  <span class="c1">// 只允许在非十进制的情况下使用 parseInt。</span>
</pre></div>
</div>
<p>应当使用 <code class="docutils literal notranslate"><span class="pre">Number()</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Math.floor</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">Math.trunc</span></code> （如果支持的话）解析整数。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">someString</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">f</span><span class="p">))</span> <span class="nx">handleError</span><span class="p">();</span>
<span class="nx">f</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
</pre></div>
</div>
<p>不要在 <code class="docutils literal notranslate"><span class="pre">if</span></code> 、 <code class="docutils literal notranslate"><span class="pre">for</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">while</span></code> 的条件语句中显式地将类型转换为 <code class="docutils literal notranslate"><span class="pre">boolean</span></code> ，因为这里原本就会执行隐式的类型转换。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">foo</span>: <span class="kt">MyInterface</span><span class="o">|</span><span class="kc">null</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{...}</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!!</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{...}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">const</span> <span class="nx">foo</span>: <span class="kt">MyInterface</span><span class="o">|</span><span class="kc">null</span> <span class="o">=</span> <span class="p">...;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{...}</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{...}</span>
</pre></div>
</div>
<p>最后，在代码中使用显式和隐式的比较均可。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 显式地和 0 进行比较，没问题！</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{...}</span>

<span class="c1">// 依赖隐式类型转换，也没问题！</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{...}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-12">
<span id="ts-variables"></span><h4>变量</h4>
<p>必须使用 <code class="docutils literal notranslate"><span class="pre">const</span></code> 或 <code class="docutils literal notranslate"><span class="pre">let</span></code> 声明变量。尽可能地使用 <code class="docutils literal notranslate"><span class="pre">const</span></code> ，除非这个变量需要被重新赋值。禁止使用 <code class="docutils literal notranslate"><span class="pre">var</span></code> 。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">otherValue</span><span class="p">;</span>  <span class="c1">// 如果 foo 不可变，就使用 const。</span>
<span class="kd">let</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">someValue</span><span class="p">;</span>     <span class="c1">// 如果 bar 在之后会被重新赋值，就使用 let。</span>
</pre></div>
</div>
<p>与大多数其它编程语言类似，使用 <code class="docutils literal notranslate"><span class="pre">const</span></code> 和 <code class="docutils literal notranslate"><span class="pre">let</span></code> 声明的变量都具有块级作用域。与之相反的是，使用 <code class="docutils literal notranslate"><span class="pre">var</span></code> 声明的变量在 JavaScript 中具有函数作用域，这会造成许多难以理解的 bug，因此禁止在 TypeScript 中使用 <code class="docutils literal notranslate"><span class="pre">var</span></code> 。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这么做！</span>
<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">someValue</span><span class="p">;</span>
</pre></div>
</div>
<p>最后，变量必须在使用前进行声明。</p>
</div>
<div class="section" id="section-13">
<span id="ts-exceptions"></span><h4>异常</h4>
<p>在实例化异常对象时，必须使用 <code class="docutils literal notranslate"><span class="pre">new</span> <span class="pre">Error()</span></code> 语法而非调用 <code class="docutils literal notranslate"><span class="pre">Error()</span></code> 函数。虽然这两种方法都能够创建一个异常实例，但是使用 <code class="docutils literal notranslate"><span class="pre">new</span></code> 能够与代码中其它的对象实例化在形式上保持更好的一致性。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Foo is not a valid bar.&#39;</span><span class="p">);</span>

<span class="c1">// 不要这样做！</span>
<span class="k">throw</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">&#39;Foo is not a valid bar.&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-14">
<span id="ts-iterating-objects"></span><h4>对象迭代</h4>
<p>对对象使用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(...</span> <span class="pre">in</span> <span class="pre">...)</span></code> 语法进行迭代很容易出错，因为它同时包括了对象从原型链中继承得来的属性。因此，禁止使用裸的 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(...</span> <span class="pre">in</span> <span class="pre">...)</span></code> 语句。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">x</span> <span class="k">in</span> <span class="nx">someObj</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// x 可能包括 someObj 从原型中继承得到的属性。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在对对象进行迭代时，必须使用 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句对对象的属性进行过滤，或者使用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(...</span> <span class="pre">of</span> <span class="pre">Object.keys(...))</span></code> 。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">x</span> <span class="k">in</span> <span class="nx">someObj</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">someObj</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">x</span><span class="p">))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="c1">// 此时 x 必然是定义在 someObj 上的属性。</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">x</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">someObj</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 注意：这里使用的是 for _of_ 语法！</span>
    <span class="c1">// 此时 x 必然是定义在 someObj 上的属性。</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">someObj</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 注意：这里使用的是 for _of_ 语法！</span>
    <span class="c1">// 此时 key 必然是定义在 someObj 上的属性。</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-15">
<span id="ts-iterating-containers"></span><h4>容器迭代</h4>
<p>不要在数组上使用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(...</span> <span class="pre">in</span> <span class="pre">...)</span></code> 进行迭代。这是一个违反直觉的操作，因为它是对数组的下标而非元素进行迭代（还会将其强制转换为 <code class="docutils literal notranslate"><span class="pre">string</span></code> 类型）！</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">x</span> <span class="k">in</span> <span class="nx">someArray</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 这里的 x 是数组的下标！(还是 string 类型的！)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果要在数组上进行迭代，应当使用 <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(...</span> <span class="pre">of</span> <span class="pre">someArr)</span></code> 语句或者传统的 <code class="docutils literal notranslate"><span class="pre">for</span></code> 循环语句。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">someArr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 这里的x 是数组的元素。</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">someArr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 如果需要使用下标，就对下标进行迭代，否则就使用 for/of 循环。</span>
    <span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">someArr</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">x</span><span class="p">]</span> <span class="k">of</span> <span class="nx">someArr</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// 上面例子的另一种形式。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">Array.prototype.forEach</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Set.prototype.forEach</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Map.prototype.forEach</span></code> 。这些方法会使代码难以调试，还会令编译器的某些检查（例如可见性检查）失效。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="nx">someArr</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">someFn</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
<p>为什么？考虑下面这段代码：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nx">x</span>: <span class="kt">string</span><span class="o">|</span><span class="kc">null</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span>
<span class="nx">myArray</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">x</span><span class="p">.</span><span class="nx">charAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="p">});</span>
</pre></div>
</div>
<p>从读者的角度看，这段代码并没有什么问题： <code class="docutils literal notranslate"><span class="pre">x</span></code> 没有被初始化为 <code class="docutils literal notranslate"><span class="pre">null</span></code> ，并且在被访问之前也没有发生过任何变化。但是对编译器而言，它并不知道传给 <code class="docutils literal notranslate"><span class="pre">.forEach()</span></code> 的闭包 <code class="docutils literal notranslate"><span class="pre">()</span> <span class="pre">=&gt;</span> <span class="pre">{</span> <span class="pre">x.charAt(0);</span> <span class="pre">}</span></code> 会被立即执行。因此，编译器有理由认为闭包有可能在之后的某处代码中被调用，而到那时 <code class="docutils literal notranslate"><span class="pre">x</span></code> 已经被设为 <code class="docutils literal notranslate"><span class="pre">null</span></code> 。于是，这里出现了一个编译错误。与之等价的 <code class="docutils literal notranslate"><span class="pre">for-of</span></code> 形式的迭代就不会有任何问题。</p>
<p>读者可以在 <a class="reference external" href="https://www.typescriptlang.org/play?#code/DYUwLgBAHgXBDOYBOBLAdgcwD5oK7GAgF4IByAQwCMBjUgbgCgBtAXQDoAzAeyQFFzqACwAUwgJTEAfBADeDCNDZDySAIJhhABjGMAvjoYNQkAJ5xEqTDnyESFGvQbckEYdS5pEEAPoQuHCFYJOQUTJUEVdS0DXQYgA">这里</a> 对比这两个版本的代码。</p>
<p>在工程实践中，代码路径越复杂、越违背直觉，越容易在进行控制流分析时出现这类问题。</p>
</div>
<div class="section" id="section-16">
<span id="ts-using-the-spread-operator"></span><h4>展开运算符</h4>
<p>在复制数组或对象时，展开运算符 <code class="docutils literal notranslate"><span class="pre">[...foo]</span></code>、<code class="docutils literal notranslate"><span class="pre">{...bar}</span></code> 是一个非常方便的语法。使用展开运算符时，对于同一个键，后出现的值会取代先出现的值。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">num</span>: <span class="kt">1</span><span class="p">,</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">foo2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">...</span><span class="nx">foo</span><span class="p">,</span>
    <span class="nx">num</span>: <span class="kt">5</span><span class="p">,</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">foo3</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">num</span>: <span class="kt">5</span><span class="p">,</span>
    <span class="p">...</span><span class="nx">foo</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 对于 foo2 而言，1 先出现，5 后出现。</span>
<span class="nx">foo2</span><span class="p">.</span><span class="nx">num</span> <span class="o">===</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">// 对于 foo3 而言，5 先出现，1 后出现。</span>
<span class="nx">foo3</span><span class="p">.</span><span class="nx">num</span> <span class="o">===</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>在使用展开运算符时，被展开的值必须与被创建的值相匹配。也就是说，在创建对象时只能展开对象，在创建数组时只能展开可迭代类型。</p>
<p>禁止展开原始类型，包括 <code class="docutils literal notranslate"><span class="pre">null</span></code> 和 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span><span class="nx">num</span>: <span class="kt">7</span><span class="p">};</span>
<span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">{</span><span class="nx">num</span>: <span class="kt">5</span><span class="p">,</span> <span class="p">...(</span><span class="nx">shouldUseFoo</span> <span class="o">&amp;&amp;</span> <span class="nx">foo</span><span class="p">)};</span> <span class="c1">// 展开运算符有可能作用于 undefined。</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！这会创建出一个没有 length 属性的对象 {0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;}。</span>
<span class="kr">const</span> <span class="nx">fooStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">ids</span> <span class="o">=</span> <span class="p">{...</span><span class="nx">fooStrings</span><span class="p">};</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！在创建对象时展开对象。</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">shouldUseFoo</span> <span class="o">?</span> <span class="p">{</span><span class="nx">num</span>: <span class="kt">7</span><span class="p">}</span> <span class="o">:</span> <span class="p">{};</span>
<span class="kr">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="p">{</span><span class="nx">num</span>: <span class="kt">5</span><span class="p">,</span> <span class="p">...</span><span class="nx">foo</span><span class="p">};</span>

<span class="c1">// 应当这样做！在创建数组时展开数组。</span>
<span class="kr">const</span> <span class="nx">fooStrings</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">];</span>
<span class="kr">const</span> <span class="nx">ids</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">fooStrings</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">];</span>
</pre></div>
</div>
</div>
<div class="section" id="section-17">
<span id="ts-control-flow-statements-blocks"></span><h4>控制流语句 / 语句块</h4>
<p>多行控制流语句必须使用大括号。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doSomethingWith</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
    <span class="nx">andSomeMore</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">doSomethingWithALongMethodName</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="nx">x</span><span class="p">.</span><span class="nx">doFoo</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
    <span class="nx">doSomethingWithALongMethodName</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
</pre></div>
</div>
<p>这条规则的例外时，能够写在同一行的 <code class="docutils literal notranslate"><span class="pre">if</span></code> 语句可以省略大括号。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 可以这样做！</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="nx">x</span><span class="p">.</span><span class="nx">doFoo</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="switch">
<span id="ts-switch-statements"></span><h4><code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句</h4>
<p>所有的 <code class="docutils literal notranslate"><span class="pre">switch</span></code> 语句都必须包含一个 <code class="docutils literal notranslate"><span class="pre">default</span></code> 分支，即使这个分支里没有任何代码。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">switch</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">Y</span>:
        <span class="kt">doSomethingElse</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="c1">// 什么也不做。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>非空语句组（ <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">...</span></code> ）不允许越过分支向下执行（编译器会进行检查）：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不能这样做！</span>
<span class="k">switch</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">X</span>:
        <span class="kt">doSomething</span><span class="p">();</span>
        <span class="c1">// 不允许向下执行！</span>
    <span class="k">case</span> <span class="nx">Y</span><span class="o">:</span>
        <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>空语句组可以这样做：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 可以这样做！</span>
<span class="k">switch</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">X</span>:
    <span class="kt">case</span> <span class="nx">Y</span>:
        <span class="kt">doSomething</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span> <span class="c1">// 什么也不做。</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-18">
<span id="ts-equality-checks"></span><h4>相等性判断</h4>
<p>必须使用三等号（ <code class="docutils literal notranslate"><span class="pre">===</span></code> ）和对应的不等号（ <code class="docutils literal notranslate"><span class="pre">!==</span></code> ）。两等号会在比较的过程中进行类型转换，这非常容易导致难以理解的错误。并且在 JavaScript 虚拟机上，两等号的运行速度比三等号慢。参见 <a class="reference external" href="https://dorey.github.io/JavaScript-Equality-Table/">JavaScript 相等表</a> 。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span> <span class="o">||</span> <span class="nx">baz</span> <span class="o">!=</span> <span class="nx">bam</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 由于发生了类型转换，会导致难以理解的行为。</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span> <span class="o">===</span> <span class="s1">&#39;bar&#39;</span> <span class="o">||</span> <span class="nx">baz</span> <span class="o">!==</span> <span class="nx">bam</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 一切都很好！</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>例外</strong>：和 <code class="docutils literal notranslate"><span class="pre">null</span></code> 字面量的比较可以使用 <code class="docutils literal notranslate"><span class="pre">==</span></code> 和 <code class="docutils literal notranslate"><span class="pre">!=</span></code> 运算符，这样能够同时覆盖 <code class="docutils literal notranslate"><span class="pre">null</span></code> 和 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 两种情况。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 可以这样做！</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 不管 foo 是 null 还是 undefined 都会执行到这里。</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-19">
<span id="ts-function-declarations"></span><h4>函数声明</h4>
<p>使用 <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">foo()</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 的形式声明具名函数，包括嵌套在其它作用域中，例如其它函数内部的函数。</p>
<p>不要使用将函数表达式赋值给局部变量的写法（例如 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">function()</span> <span class="pre">{...};</span></code> ）。TypeScript 本身已不允许重新绑定函数，所以在函数声明中使用 <code class="docutils literal notranslate"><span class="pre">const</span></code> 来阻止重写函数是没有必要的。</p>
<p><strong>例外</strong>：如果函数需要访问外层作用域的 <code class="docutils literal notranslate"><span class="pre">this</span></code> ，则应当使用将箭头函数赋值给变量的形式代替函数声明的形式。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kd">function</span> <span class="nx">foo() {</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="c1">// 在有上一段代码中的函数声明的情况下，下面这段代码无法通过编译：</span>
<span class="nx">foo</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">;</span>  <span class="c1">// 错误：赋值表达式的左侧不合法。</span>

<span class="c1">// 因此像这样进行函数声明是没有必要的。</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>请注意这里所说的函数声明（ <code class="docutils literal notranslate"><span class="pre">function</span> <span class="pre">foo()</span> <span class="pre">{}</span></code> ）和下面要讨论的函数表达式（ <code class="docutils literal notranslate"><span class="pre">doSomethingWith(function()</span> <span class="pre">{});</span></code> ）之间的区别。</p>
<p>顶层箭头函数可以用于显式地声明这一函数实现了一个接口。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">SearchFunction</span> <span class="p">{</span>
    <span class="p">(</span><span class="nx">source</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">subString</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">fooSearch</span>: <span class="kt">SearchFunction</span> <span class="o">=</span> <span class="p">(</span><span class="nx">source</span><span class="p">,</span> <span class="nx">subString</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="section-20">
<span id="ts-function-expressions"></span><h4>函数表达式</h4>
<div class="section" id="section-21">
<span id="ts-use-arrow-functions-in-expressions"></span><h5>在表达式中使用箭头函数</h5>
<p>不要使用 ES6 之前使用 <code class="docutils literal notranslate"><span class="pre">function</span></code> 关键字定义函数表达式的版本。应当使用箭头函数。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="nx">bar</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">doSomething</span><span class="p">();</span> <span class="p">})</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="nx">bar</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">})</span>
</pre></div>
</div>
<p>只有当函数需要动态地重新绑定 <code class="docutils literal notranslate"><span class="pre">this</span></code> 时，才能使用 <code class="docutils literal notranslate"><span class="pre">function</span></code> 关键字声明函数表达式，但是通常情况下代码中不应当重新绑定 <code class="docutils literal notranslate"><span class="pre">this</span></code> 。常规函数（相对于箭头函数和方法而言）不应当访问 <code class="docutils literal notranslate"><span class="pre">this</span></code> 。</p>
</div>
<div class="section" id="section-22">
<span id="ts-expression-bodies-vs-block-bodies"></span><h5>表达式函数体 和 代码块函数体</h5>
<p>使用箭头函数时，应当根据具体情况选择表达式或者代码块作为函数体。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 使用函数声明的顶层函数。</span>
<span class="kd">function</span> <span class="nx">someFunction() {</span>
    <span class="c1">// 使用代码块函数体的箭头函数，也就是使用 =&gt; { } 的函数，没问题：</span>
    <span class="kr">const</span> <span class="nx">receipts</span> <span class="o">=</span> <span class="nx">books</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">b</span>: <span class="kt">Book</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="kr">const</span> <span class="nx">receipt</span> <span class="o">=</span> <span class="nx">payMoney</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">price</span><span class="p">);</span>
        <span class="nx">recordTransaction</span><span class="p">(</span><span class="nx">receipt</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">receipt</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="c1">// 如果用到了函数的返回值的话，使用表达式函数体也没问题：</span>
    <span class="kr">const</span> <span class="nx">longThings</span> <span class="o">=</span> <span class="nx">myValues</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">v</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nb">String</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span>

    <span class="kd">function</span> <span class="nx">payMoney</span><span class="p">(</span><span class="nx">amount</span>: <span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 函数声明也没问题，但是不要在函数中访问 this。</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>只有在确实需要用到函数返回值的情况下才能使用表达式函数体。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！如果不需要函数返回值的话，应当使用代码块函数体（{ ... }）。</span>
<span class="nx">myPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！使用代码块函数体。</span>
<span class="nx">myPromise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 应当这样做！即使需要函数返回值，也可以为了可读性使用代码块函数体。</span>
<span class="kr">const</span> <span class="nx">transformed</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">].</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">intermediate</span> <span class="o">=</span> <span class="nx">someComplicatedExpr</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
    <span class="kr">const</span> <span class="nx">more</span> <span class="o">=</span> <span class="nx">acrossManyLines</span><span class="p">(</span><span class="nx">intermediate</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">worthWrapping</span><span class="p">(</span><span class="nx">more</span><span class="p">);</span>
<span class="p">});</span>
</pre></div>
</div>
</div>
<div class="section" id="this">
<span id="ts-rebinding-this"></span><h5>重新绑定 <code class="docutils literal notranslate"><span class="pre">this</span></code></h5>
<p>不要在函数表达式中使用 <code class="docutils literal notranslate"><span class="pre">this</span></code> ，除非它们明确地被用于重新绑定 <code class="docutils literal notranslate"><span class="pre">this</span></code> 指针。大多数情况下，使用箭头函数或者显式指定函数参数都能够避免重新绑定 <code class="docutils literal notranslate"><span class="pre">this</span></code> 的需求。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kd">function</span> <span class="nx">clickHandler() {</span>
    <span class="c1">// 这里的 this 到底指向什么？</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">&#39;Hello&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 不要这样做！this 指针被隐式地设为 document.body。</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="nx">clickHandler</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！在箭头函数中显式地对对象进行引用。</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span> <span class="p">};</span>

<span class="c1">// 可以这样做！函数显式地接收一个参数。</span>
<span class="kr">const</span> <span class="nx">setTextFn</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span>: <span class="kt">HTMLElement</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">e</span><span class="p">.</span><span class="nx">textContent</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span><span class="p">;</span> <span class="p">};</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="nx">setTextFn</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-23">
<span id="ts-arrow-functions-as-properties"></span><h5>使用箭头函数作为属性</h5>
<p>通常情况下，类不应该将任何属性初始化为箭头函数。箭头函数属性需要调用函数意识到被调用函数的 <code class="docutils literal notranslate"><span class="pre">this</span></code> 已经被绑定了，这让 <code class="docutils literal notranslate"><span class="pre">this</span></code> 的指向变得令人费解，也让对应的调用和引用在形式上看着似乎是不正确的，也就是说，需要额外的信息才能确认这样的使用方式是正确的。在调用实例方法时，必须使用箭头函数的形式（例如 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">handler</span> <span class="pre">=</span> <span class="pre">(x)</span> <span class="pre">=&gt;</span> <span class="pre">{</span> <span class="pre">this.listener(x);</span> <span class="pre">};</span></code> ）。此外，不允许持有或传递实例方法的引用（例如不要使用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">handler</span> <span class="pre">=</span> <span class="pre">this.listener;</span> <span class="pre">handler(x);</span></code> 的写法）。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">在一些特殊的情况下，例如需要将函数绑定到模板时，使用箭头函数作为属性是很有用的做法，同时还能令代码的可读性提高。因此，在这些情况下对于这条规则可视具体情况加以变通。此外， <a class="reference internal" href="#ts-event-handlers"><span class="std std-ref">事件句柄</span></a> 一节中有相关讨论。</p>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">class</span> <span class="nx">DelayHandler</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 这里有个问题，回调函数里的 this 指针不会被保存。</span>
        <span class="c1">// 因此回调函数里的 this 不再是 DelayHandler 的实例了。</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">patienceTracker</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">private</span> <span class="nx">patienceTracker() {</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">waitedPatiently</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！一般而言不应当使用箭头函数作为属性。</span>
<span class="kr">class</span> <span class="nx">DelayHandler</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 不要这样做！这里看起来就是像是忘记了绑定 this 指针。</span>
        <span class="nx">setTimeout</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">patienceTracker</span><span class="p">,</span> <span class="mi">5000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">private</span> <span class="nx">patienceTracker</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">waitedPatiently</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！在调用时显式地处理 this 指针的指向问题。</span>
<span class="kr">class</span> <span class="nx">DelayHandler</span> <span class="p">{</span>
    <span class="kr">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// 在这种情况下，应尽可能使用匿名函数。</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">patienceTracker</span><span class="p">();</span>
        <span class="p">},</span> <span class="mi">5000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">private</span> <span class="nx">patienceTracker() {</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">waitedPatiently</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-24">
<span id="ts-event-handlers"></span><h5>事件句柄</h5>
<p>对于事件句柄，如果它不需要被卸载的话，可以使用箭头函数的形式，例如事件是由类自身发送的情况。如果句柄必须被卸载，则应当使用箭头函数属性，因为箭头函数属性能够自动正确地捕获 <code class="docutils literal notranslate"><span class="pre">this</span></code> 指针，并且能够提供一个用于卸载的稳定引用。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！事件句柄可以使用匿名函数或者箭头函数属性的形式。</span>
<span class="kr">class</span> <span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">onAttached() {</span>
        <span class="c1">// 事件是由类本身发送的，因此这个句柄不需要卸载。</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">listener</span><span class="p">();</span>
        <span class="p">});</span>
        <span class="c1">// 这里的 this.listener 是一个稳定引用，因此可以在之后被卸载。</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;onbeforeunload&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">listener</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">onDetached() {</span>
        <span class="c1">// 这个事件是由 window 发送的。如果不卸载这个句柄，this.listener</span>
        <span class="c1">// 会因为绑定了 this 而保存对 this 的引用，从而导致内存泄漏。</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s1">&#39;onbeforeunload&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">listener</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 使用箭头函数作为属性能够自动地正确绑定 this 指针。</span>
    <span class="kr">private</span> <span class="nx">listener</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">confirm</span><span class="p">(</span><span class="s1">&#39;Do you want to exit the page?&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>不要在注册事件句柄的表达式中使用 <code class="docutils literal notranslate"><span class="pre">bind</span></code> ，这会创建一个无法卸载的临时引用。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！对句柄使用 bind 会创建一个无法卸载的临时引用。</span>
<span class="kr">class</span> <span class="nx">Component</span> <span class="p">{</span>
    <span class="nx">onAttached() {</span>
        <span class="c1">// 这里创建了一个无法卸载的临时引用。</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;onbeforeunload&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">listener</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="nx">onDetached() {</span>
        <span class="c1">// 这里的 bind 创建了另一个引用，所以这一行代码实际上没有实现任何功能。</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">removeEventListener</span><span class="p">(</span><span class="s1">&#39;onbeforeunload&#39;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">listener</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="k">this</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="kr">private</span> <span class="nx">listener() {</span>
        <span class="nx">confirm</span><span class="p">(</span><span class="s1">&#39;Do you want to exit the page?&#39;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-25">
<span id="ts-automatic-semicolon-insertion"></span><h4>自动分号插入</h4>
<p>不要依赖自动分号插入（ASI），必须显式地使用分号结束每一个语句。这能够避免由于不正确的分号插入所导致的 Bug，也能够更好地兼容对 ASI 支持有限的工具（例如 clang-format）。</p>
</div>
<div class="section" id="ts-ignore">
<span id="ts-ts-ignore"></span><h4><code class="docutils literal notranslate"><span class="pre">&#64;ts-ignore</span></code></h4>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">&#64;ts-ignore</span></code> 。表面上看，这是一个“解决”编译错误的简单方法，但实际上，编译错误往往是由其它更大的问题导致的，因此正确的做法是直接解决这些问题本身。</p>
<p>举例来说，如果使用 <code class="docutils literal notranslate"><span class="pre">&#64;ts-ignore</span></code> 关闭了一个类型错误，那么便很难推断其它相关代码最终会接收到何种类型。对于许多与类型相关的错误， <a class="reference internal" href="contents.html#ts-any-type"><span class="std std-ref">any 类型</span></a> 一节有一些关于如何正确使用 <code class="docutils literal notranslate"><span class="pre">any</span></code> 的有用的建议。</p>
</div>
<div class="section" id="section-26">
<span id="ts-type-and-non-nullability-assertions"></span><h4>类型断言与非空断言</h4>
<p>类型断言（ <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">as</span> <span class="pre">SomeType</span></code> ）和非空断言（ <code class="docutils literal notranslate"><span class="pre">y!</span></code> ）是不安全的。这两种语法只能够绕过编译器，而并不添加任何运行时断言检查，因此有可能导致程序在运行时崩溃。</p>
<p>因此，除非有明显或确切的理由，否则 <em>不应</em> 使用类型断言和非空断言。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="p">(</span><span class="nx">x</span> <span class="kr">as</span> <span class="nx">Foo</span><span class="p">).</span><span class="nx">foo</span><span class="p">();</span>

<span class="nx">y</span><span class="o">!</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>
</pre></div>
</div>
<p>如果希望对类型和非空条件进行断言，最好的做法是显式地编写运行时检查。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>

<span class="c1">// 这里假定 Foo 是一个类。</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="k">instanceof</span> <span class="nx">Foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">x</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">y</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>有时根据代码中的上下文可以确定某个断言必然是安全的。在这种情况下， <em>应当</em> 添加注释详细地解释为什么这一不安全的行为可以被接受：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 可以这样做！</span>

<span class="c1">// x 是一个 Foo 类型的示例，因为……</span>
<span class="p">(</span><span class="nx">x</span> <span class="kr">as</span> <span class="nx">Foo</span><span class="p">).</span><span class="nx">foo</span><span class="p">();</span>

<span class="c1">// y 不可能是 null，因为……</span>
<span class="nx">y</span><span class="o">!</span><span class="p">.</span><span class="nx">bar</span><span class="p">();</span>
</pre></div>
</div>
<p>如果使用断言的理由很明显，注释就不是必需的。例如，生成的协议代码总是可空的，但有时根据上下文可以确认其中某些特定的由后端提供的字段必然不为空。在这些情况下应当根据具体场景加以判断和变通。</p>
<div class="section" id="section-27">
<span id="ts-type-assertions-syntax"></span><h5>类型断言语法</h5>
<p>类型断言必须使用 <code class="docutils literal notranslate"><span class="pre">as</span></code> 语法，不要使用尖括号语法，这样能强制保证在断言外必须使用括号。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">Foo</span><span class="o">&gt;</span><span class="nx">z</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">Foo</span><span class="o">&gt;</span><span class="nx">z</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="p">(</span><span class="nx">z</span> <span class="kr">as</span> <span class="nx">Foo</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-28">
<span id="ts-type-assertions-and-object-literals"></span><h5>类型断言和对象字面量</h5>
<p>使用类型标记（ <code class="docutils literal notranslate"><span class="pre">:</span> <span class="pre">Foo</span></code> ）而非类型断言（ <code class="docutils literal notranslate"><span class="pre">as</span> <span class="pre">Foo</span></code> ）标明对象字面量的类型。在日后对接口的字段类型进行修改时，前者能够帮助程序员发现 Bug。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="nx">bar</span>: <span class="kt">number</span><span class="p">;</span>
    <span class="nx">baz?</span>: <span class="kt">string</span><span class="p">;</span>  <span class="c1">// 这个字段曾经的名称是“bam”，后来改名为“baz”。</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">bar</span>: <span class="kt">123</span><span class="p">,</span>
    <span class="nx">bam</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">,</span>  <span class="c1">// 如果使用类型断言，改名之后这里并不会报错！</span>
<span class="p">}</span> <span class="kr">as</span> <span class="nx">Foo</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">func() {</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="nx">bar</span>: <span class="kt">123</span><span class="p">,</span>
        <span class="nx">bam</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">,</span>  <span class="c1">// 如果使用类型断言，改名之后这里也不会报错！</span>
    <span class="p">}</span> <span class="kr">as</span> <span class="nx">Foo</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-29">
<span id="ts-member-property-declarations"></span><h4>成员属性声明</h4>
<p>接口和类的声明必须使用 <code class="docutils literal notranslate"><span class="pre">;</span></code> 分隔每个成员声明。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="nx">memberA</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">memberB</span>: <span class="kt">number</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为了与类的写法保持一致，不要在接口中使用 <code class="docutils literal notranslate"><span class="pre">,</span></code> 分隔字段。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">interface</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="nx">memberA</span>: <span class="kt">string</span><span class="p">,</span>
    <span class="nx">memberB</span>: <span class="kt">number</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>然而，内联对象类型声明必须使用 <code class="docutils literal notranslate"><span class="pre">,</span></code> 作为分隔符。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="nx">type</span> <span class="nx">SomeTypeAlias</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">memberA</span>: <span class="kt">string</span><span class="p">,</span>
    <span class="nx">memberB</span>: <span class="kt">number</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">someProperty</span><span class="o">:</span> <span class="p">{</span><span class="nx">memberC</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">memberD</span>: <span class="kt">number</span><span class="p">};</span>
</pre></div>
</div>
<div class="section" id="section-30">
<span id="ts-optimization-compatibility-for-property-access"></span><h5>优化属性访问的兼容性</h5>
<p>不要混用方括号属性访问和句点属性访问两种形式。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="c1">// 必须从两种形式中选择其中一种，以保证整个程序的一致性。</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="s1">&#39;someField&#39;</span><span class="p">]);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">someField</span><span class="p">);</span>
</pre></div>
</div>
<p>代码应当尽可能为日后的属性重命名需求进行优化，并且为所有程序外部的对象属性声明对应的字段。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！声明一个对应的接口。</span>
<span class="kr">declare</span> <span class="kr">interface</span> <span class="nx">ServerInfoJson</span> <span class="p">{</span>
    <span class="nx">appVersion</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">user</span>: <span class="kt">UserJson</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">serverResponse</span><span class="p">)</span> <span class="kr">as</span> <span class="nx">ServerInfoJson</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">appVersion</span><span class="p">);</span> <span class="c1">// 这里是类型安全的，如果需要重命名也是安全的！</span>
</pre></div>
</div>
</div>
<div class="section" id="section-31">
<span id="ts-optimization-compatibility-for-module-object-imports"></span><h5>优化模块对象导入的兼容性</h5>
<p>导入模块对象时应当直接访问对象上的属性，而不要传递对象本身的引用，以保证模块能够被分析和优化。也可以将导入的模块视作命名空间，参见 <a class="reference internal" href="contents.html#ts-module-versus-destructuring-imports"><span class="std std-ref">选择模块导入还是解构导入？</span></a> 一节。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">method1</span><span class="p">,</span> <span class="nx">method2</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;utils&#39;</span><span class="p">;</span>
<span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="nx">readonly</span> <span class="nx">utils</span> <span class="o">=</span> <span class="p">{</span><span class="nx">method1</span><span class="p">,</span> <span class="nx">method2</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">utils</span> <span class="nx">from</span> <span class="s1">&#39;utils&#39;</span><span class="p">;</span>
<span class="kr">class</span> <span class="nx">A</span> <span class="p">{</span>
    <span class="nx">readonly</span> <span class="nx">utils</span> <span class="o">=</span> <span class="nx">utils</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-32">
<span id="ts-optimization-exception"></span><h5>例外情况</h5>
<p>这里所提到的优化规则适用于所有的 Web 应用，但不需要强制应用于只运行在服务端的程序。不过，出于代码整洁性的考虑，这里仍然强烈建议声明所有的类型，并且避免混用两种属性访问的形式。</p>
</div>
</div>
<div class="section" id="section-33">
<span id="ts-enums"></span><h4>枚举</h4>
<p>对于枚举类型，必须使用 <code class="docutils literal notranslate"><span class="pre">enum</span></code> 关键字，但不要使用 <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span></code> 。TypeScript 的枚举类型本身就是不可变的， <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">enum</span></code> 的写法是另一种独立的语言特性，其目的是让枚举对 JavaScript 程序员透明。</p>
</div>
<div class="section" id="debugger">
<span id="ts-debugger-statements"></span><h4><code class="docutils literal notranslate"><span class="pre">debugger</span></code> 语句</h4>
<p>不允许在生产环境代码中添加 <code class="docutils literal notranslate"><span class="pre">debugger</span></code> 语句。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kd">function</span> <span class="nx">debugMe() {</span>
    <span class="kr">debugger</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-34">
<span id="ts-decorators"></span><h4>装饰器</h4>
<p>装饰器以 <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> 为前缀，例如 <code class="docutils literal notranslate"><span class="pre">&#64;MyDecorator</span></code> 。</p>
<p>不要定义新的装饰器，只使用框架中已定义的装饰器，例如：</p>
<ul class="simple">
<li>Angular（例如 <code class="docutils literal notranslate"><span class="pre">&#64;Component</span></code> 、 <code class="docutils literal notranslate"><span class="pre">&#64;NgModule</span></code> 等等）</li>
<li>Polymer（例如 <code class="docutils literal notranslate"><span class="pre">&#64;property</span></code> 等等）</li>
</ul>
<p>为什么？</p>
<p>通常情况下，应当避免使用装饰器。这是由于装饰器是一个实验性功能，仍然处于 TC39 委员会的提案阶段，且目前存在已知的无法被修复的 Bug。</p>
<p>使用装饰器时，装饰器必须紧接被装饰的符号，中间不允许有空行。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="cm">/** JSDoc 注释应当位于装饰器之前 */</span>
<span class="kd">@Component</span><span class="p">({...})</span>  <span class="c1">// 装饰器之后不能有空行。</span>
<span class="kr">class</span> <span class="nx">MyComp</span> <span class="p">{</span>
    <span class="kd">@Input</span><span class="p">()</span> <span class="nx">myField</span>: <span class="kt">string</span><span class="p">;</span>  <span class="c1">// 字段的装饰器和和字段位于同一行……</span>

    <span class="kd">@Input</span><span class="p">()</span>
    <span class="nx">myOtherField</span>: <span class="kt">string</span><span class="p">;</span>  <span class="c1">// ……或位于字段之前。</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-typescript-styleguide/source_organization"></span><div class="section" id="section-1">
<h3>代码管理</h3>
<div class="section" id="section-2">
<span id="ts-modules"></span><h4>模块</h4>
<div class="section" id="section-3">
<span id="import-paths"></span><h5>导入路径</h5>
<p>TypeScript 代码必须使用路径进行导入。这里的路径既可以是相对路径，以 <code class="docutils literal notranslate"><span class="pre">.</span></code> 或 <code class="docutils literal notranslate"><span class="pre">..</span></code> 开头，也可以是从项目根目录开始的绝对路径，如 <code class="docutils literal notranslate"><span class="pre">root/path/to/file</span></code> 。</p>
<p>在引用逻辑上属于同一项目的文件时，应使用相对路径 <code class="docutils literal notranslate"><span class="pre">./foo</span></code> ，不要使用绝对路径 <code class="docutils literal notranslate"><span class="pre">path/to/foo</span></code> 。</p>
<p>应尽可能地限制父层级的数量（避免出现诸如 <code class="docutils literal notranslate"><span class="pre">../../../</span></code> 的路径），过多的层级会导致模块和路径结构难以理解。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="p">{</span><span class="nx">Symbol1</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;google3/path/from/root&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">Symbol2</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;../parent/file&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">Symbol3</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./sibling&#39;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<span id="namespaces-vs-modules"></span><h5>用 命名空间 还是 模块？</h5>
<p>在 TypeScript 有两种组织代码的方式：命名空间（namespace）和模块（module）。</p>
<p>不允许使用命名空间，在 TypeScript 中必须使用模块（即 <a class="reference external" href="http://exploringjs.com/es6/ch_modules.html">ES6 模块</a> ）。也就是说，在引用其它文件中的代码时必须以 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">{foo}</span> <span class="pre">from</span> <span class="pre">'bar'</span></code> 的形式进行导入和导出。</p>
<p>不允许使用 <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">Foo</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 的形式组织代码。命名空间只能在所用的外部第三方库有要求时才能使用。如果需要在语义上对代码划分命名空间，应当通过分成不同文件的方式实现。</p>
<p>不允许在导入时使用 <code class="docutils literal notranslate"><span class="pre">require</span></code> 关键字（形如 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">require('...');</span></code> ）。应当使用 ES6 的模块语法。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！不要使用命名空间！</span>
<span class="nx">namespace</span> <span class="nx">Rocket</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">launch() {</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 不要这样做！不要使用 &lt;reference&gt; ！</span>
<span class="c1">/// &lt;reference path=&quot;...&quot;/&gt;</span>

<span class="c1">// 不要这样做！不要使用 require() ！</span>
<span class="kr">import</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;mydep&#39;</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">TypeScript 的命名空间早期也被称为内部模块并使用 <code class="docutils literal notranslate"><span class="pre">module</span></code> 关键字，形如 <code class="docutils literal notranslate"><span class="pre">module</span> <span class="pre">Foo</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> 。不要使用这种用法。任何时候都应当使用 ES6 的导入语法。</p>
</div>
</div>
</div>
<div class="section" id="section-5">
<span id="ts-exports"></span><h4>导出</h4>
<p>代码中必须使用具名的导出声明。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// Use named exports:</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>不要使用默认导出，这样能保证所有的导入语句都遵循统一的范式：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！不要使用默认导出！</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>为什么？因为默认导出并不为被导出的符号提供一个标准的名称，这增加了维护的难度和降低可读性的风险，同时并未带来明显的益处。如下面的例子所示：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 默认导出会造成如下的弊端</span>
<span class="kr">import</span> <span class="nx">Foo</span> <span class="nx">from</span> <span class="s1">&#39;./bar&#39;</span><span class="p">;</span>  <span class="c1">// 这个语句是合法的。</span>
<span class="kr">import</span> <span class="nx">Bar</span> <span class="nx">from</span> <span class="s1">&#39;./bar&#39;</span><span class="p">;</span>  <span class="c1">// 这个语句也是合法的。</span>
</pre></div>
</div>
<p>具名导出的一个优势是，当代码中试图导入一个并未被导出的符号时，这段代码会报错。例如，假设在 <code class="docutils literal notranslate"><span class="pre">foo.ts</span></code> 中有如下的导出声明：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="s1">&#39;blah&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">foo</span><span class="p">;</span>
</pre></div>
</div>
<p>如果在 <code class="docutils literal notranslate"><span class="pre">bar.ts</span></code> 中有如下的导入语句：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 编译错误！</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">fizz</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>会导致编译错误： <code class="docutils literal notranslate"><span class="pre">error</span> <span class="pre">TS2614:</span> <span class="pre">Module</span> <span class="pre">'&quot;./foo&quot;'</span> <span class="pre">has</span> <span class="pre">no</span> <span class="pre">exported</span> <span class="pre">member</span> <span class="pre">'fizz'</span></code> 。反之，如果在 <code class="docutils literal notranslate"><span class="pre">bar.ts</span></code> 中的导入语句为：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！这定义了一个多余的变量 fizz！</span>
<span class="kr">import</span> <span class="nx">fizz</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>结果是 <code class="docutils literal notranslate"><span class="pre">fizz</span> <span class="pre">===</span> <span class="pre">foo</span></code> ，这往往不符合预期，且难以调试。</p>
<p>此外，默认导出会鼓励程序员将所有内容全部置于一个巨大的对象当中，这个对象实际上充当了命名空间的角色：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="kr">static</span> <span class="nx">SOME_CONSTANT</span> <span class="o">=</span> <span class="p">...</span>
    <span class="kr">static</span> <span class="nx">someHelpfulFunction() {</span> <span class="p">...</span> <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>显然，这个文件中具有文件作用域，它可以被用做命名空间。但是，这里创建了第二个作用域——类 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> ，这个类在其它文件中具有歧义：它既可以被视为类型，又可以被视为值。</p>
<p>因此，应当使用文件作用域作为实质上的命名空间，同时使用具名的导出声明：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">SOME_CONSTANT</span> <span class="o">=</span> <span class="p">...</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">someHelpfulFunction</span><span class="p">()</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">Foo</span> <span class="p">{</span>
    <span class="c1">// 只有类 Foo 中的内容</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="section-6">
<span id="ts-export-visibility"></span><h5>导出可见性</h5>
<p>TypeScript 不支持限制导出符号的可见性。因此，不要导出不用于模块以外的符号。一般来说，应当尽量减小模块的外部 API 的规模。</p>
</div>
<div class="section" id="section-7">
<span id="ts-mutable-exports"></span><h5>可变导出</h5>
<p>虽然技术上可以实现，但是可变导出会造成难以理解和调试的代码，尤其是对于在多个模块中经过了多次重新导出的符号。这条规则的一个例子是，不允许使用 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">let</span></code> 。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">export</span> <span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">// 在纯 ES6 环境中，变量 foo 是一个可变值，导入了 foo 的代码会观察到它的值在一秒钟之后发生了改变。</span>
<span class="c1">// 在 TypeScript 中，如果 foo 被另一个文件重新导出了，导入该文件的代码则不会观察到变化。</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">1000</span> <span class="cm">/* ms */</span><span class="p">);</span>
</pre></div>
</div>
<p>如果确实需要允许外部代码对可变值进行访问，应当提供一个显式的取值器。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kd">let</span> <span class="nx">foo</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">foo</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="p">},</span> <span class="mi">1000</span> <span class="cm">/* ms */</span><span class="p">);</span>
<span class="c1">// 使用显式的取值器对可变导出进行访问。</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">getFoo() {</span> <span class="k">return</span> <span class="nx">foo</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
</div>
<p>有一种常见的编程情景是，要根据某种特定的条件从两个值中选取其中一个进行导出：先检查条件，然后导出。这种情况下，应当保证模块中的代码执行完毕后，导出的结果就是确定的。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">pickApi() {</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">useOtherApi</span><span class="p">())</span> <span class="k">return</span> <span class="nx">OtherApi</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">RegularApi</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">SomeApi</span> <span class="o">=</span> <span class="nx">pickApi</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="section-8">
<span id="ts-container-classes"></span><h5>容器类</h5>
<p>不要为了实现命名空间创建含有静态方法或属性的容器类。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">export</span> <span class="kr">class</span> <span class="nx">Container</span> <span class="p">{</span>
    <span class="kr">static</span> <span class="nx">FOO</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kr">static</span> <span class="nx">bar() {</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>应当将这些方法和属性设为单独导出的常数和函数。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">FOO</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kr">export</span> <span class="kd">function</span> <span class="nx">bar() {</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-9">
<span id="ts-imports-source-organization"></span><h4>导入</h4>
<p>在 ES6 和 TypeScript 中，导入语句共有四种变体：</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="32%" />
<col width="37%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">导入类型</th>
<th class="head">示例</th>
<th class="head">用途</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>模块</td>
<td><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">*</span> <span class="pre">as</span> <span class="pre">foo</span> <span class="pre">from</span> <span class="pre">'...';</span></code></td>
<td>TypeScript 导入方式</td>
</tr>
<tr class="row-odd"><td>解构</td>
<td><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">{SomeThing}</span> <span class="pre">from</span> <span class="pre">'...';</span></code></td>
<td>TypeScript 导入方式</td>
</tr>
<tr class="row-even"><td>默认</td>
<td><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">SomeThing</span> <span class="pre">from</span> <span class="pre">'...';</span></code></td>
<td>只用于外部代码的特殊需求</td>
</tr>
<tr class="row-odd"><td>副作用</td>
<td><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">'...';</span></code></td>
<td>只用于加载某些库的副作用（例如自定义元素）</td>
</tr>
</tbody>
</table>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！从这两种变体中选择较合适的一种（见下文）。</span>
<span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">ng</span> <span class="nx">from</span> <span class="s1">&#39;@angular/core&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">Foo</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span>

<span class="c1">// 只在有需要时使用默认导入。</span>
<span class="kr">import</span> <span class="nx">Button</span> <span class="nx">from</span> <span class="s1">&#39;Button&#39;</span><span class="p">;</span>

<span class="c1">// 有时导入某些库是为了其代码执行时的副作用。</span>
<span class="kr">import</span> <span class="s1">&#39;jasmine&#39;</span><span class="p">;</span>
<span class="kr">import</span> <span class="s1">&#39;@polymer/paper-button&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="section" id="section-10">
<span id="ts-module-versus-destructuring-imports"></span><h5>选择模块导入还是解构导入？</h5>
<p>根据使用场景的不同，模块导入和解构导入分别有其各自的优势。</p>
<p>虽然模块导入语句中出现了通配符 <code class="docutils literal notranslate"><span class="pre">*</span></code> ，但模块导入并不能因此被视为其它语言中的通配符导入。相反地，模块导入语句为整个模块提供了一个名称，模块中的所有符号都通过这个名称进行访问，这为代码提供了更好的可读性，同时令模块中的所有符号可以进行自动补全。模块导入减少了导入语句的数量（模块中的所有符号都可以使用），降低了命名冲突的出现几率，同时还允许为被导入的模块提供一个简洁的名称。在从一个大型 API 中导入多个不同的符号时，模块导入语句尤其有用。</p>
<p>解构导入语句则为每一个被导入的符号提供一个局部的名称，这样在使用被导入的符号时，代码可以更简洁。对那些十分常用的符号，例如 Jasmine 的 <code class="docutils literal notranslate"><span class="pre">describe</span></code> 和 <code class="docutils literal notranslate"><span class="pre">it</span></code> 来说，这一点尤其有用。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！无意义地使用命名空间中的名称使得导入语句过于冗长。</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">TableViewItem</span><span class="p">,</span> <span class="nx">TableViewHeader</span><span class="p">,</span> <span class="nx">TableViewRow</span><span class="p">,</span> <span class="nx">TableViewModel</span><span class="p">,</span>
<span class="nx">TableViewRenderer</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./tableview&#39;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">item</span>: <span class="kt">TableViewItem</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！使用模块作为命名空间。</span>
<span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">tableview</span> <span class="nx">from</span> <span class="s1">&#39;./tableview&#39;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">item</span>: <span class="kt">tableview.Item</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="o">*</span> <span class="kr">as</span> <span class="nx">testing</span> <span class="nx">from</span> <span class="s1">&#39;./testing&#39;</span><span class="p">;</span>

<span class="c1">// 所有的测试都只会重复地使用相同的三个函数。</span>
<span class="c1">// 如果只需要导入少数几个符号，而这些符号的使用频率又非常高的话，</span>
<span class="c1">// 也可以考虑使用解构导入语句直接导入这几个符号（见下文）。</span>
<span class="nx">testing</span><span class="p">.</span><span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">testing</span><span class="p">.</span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">testing</span><span class="p">.</span><span class="nx">expect</span><span class="p">(...);</span>
    <span class="nx">testing</span><span class="p">.</span><span class="nx">expect</span><span class="p">(...);</span>
<span class="p">});</span>
<span class="p">});</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这样做更好！为这几个常用的函数提供局部变量名。</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">describe</span><span class="p">,</span> <span class="nx">it</span><span class="p">,</span> <span class="nx">expect</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./testing&#39;</span><span class="p">;</span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">it</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">expect</span><span class="p">(...);</span>
    <span class="nx">expect</span><span class="p">(...);</span>
<span class="p">});</span>
<span class="p">});</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="section-11">
<span id="ts-renaming-imports"></span><h5>重命名导入</h5>
<p>在代码中，应当通过使用模块导入或重命名导出解决命名冲突。此外，在需要时，也可以使用重命名导入（例如 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">{SomeThing</span> <span class="pre">as</span> <span class="pre">SomeOtherThing}</span></code> ）。</p>
<p>在以下几种情况下，重命名导入可能较为有用：</p>
<ol class="arabic simple">
<li>避免与其它导入的符号产生命名冲突。</li>
<li>被导入符号的名称是自动生成的。</li>
<li>被导入符号的名称不能清晰地描述其自身，需要通过重命名提高代码的可读性，如将 RxJS 的 <code class="docutils literal notranslate"><span class="pre">from</span></code> 函数重命名为 <code class="docutils literal notranslate"><span class="pre">observableFrom</span></code> 。</li>
</ol>
</div>
<div class="section" id="import-type-export-type">
<span id="ts-import-export-type"></span><h5><code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">type</span></code></h5>
<p>不要使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">type</span> <span class="pre">...</span> <span class="pre">from</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">type</span> <span class="pre">...</span> <span class="pre">from</span></code> 。</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">这一规则不适用于导出类型定义，如 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">type</span> <span class="pre">Foo</span> <span class="pre">=</span> <span class="pre">...;</span></code> 。</p>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">import</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">Foo</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="nx">type</span> <span class="p">{</span><span class="nx">Bar</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./bar&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>应当使用常规的导入语句。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">import</span> <span class="p">{</span><span class="nx">Foo</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./foo&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="p">{</span><span class="nx">Bar</span><span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;./bar&#39;</span><span class="p">;</span>
</pre></div>
</div>
<p>TypeScript 的工具链会自动区分用作类型的符号和用作值的符号。对于类型引用，工具链不会生成运行时加载的代码。这样做的原因是为了提供更好的开发体验，否则在 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">type</span></code> 和 <code class="docutils literal notranslate"><span class="pre">import</span></code> 之间反复切换会非常繁琐。同时， <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">type</span></code> 并不提供任何保证，因为代码仍然可以通过其它的途径导入同一个依赖。</p>
<p>如果需要在运行时加载代码以执行其副作用，应使用 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">'...'</span></code> ，参见 <a class="reference internal" href="#ts-imports-source-organization"><span class="std std-ref">导入</span></a> 一节。</p>
<p>使用 <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">type</span></code> 似乎可以避免将某个用作值的符号导出为 API。然而，和 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">type</span></code> 类似， <code class="docutils literal notranslate"><span class="pre">export</span> <span class="pre">type</span></code> 也不提供任何保证，因为外部代码仍然可以通过其它途径导入。如果需要拆分对 API 作为值的使用和作为类型的使用，并保证二者不被混用的话，应当显式地将其拆分成不同的符号，例如 <code class="docutils literal notranslate"><span class="pre">UserService</span></code> 和 <code class="docutils literal notranslate"><span class="pre">AjaxUserService</span></code> ，这样不容易造成错误，同时能更好地表达设计思路。</p>
</div>
</div>
<div class="section" id="section-12">
<span id="ts-organize-by-feature"></span><h4>根据特征组织代码</h4>
<p>应当根据特征而非类型组织代码。例如，一个在线商城的代码应当按照 <code class="docutils literal notranslate"><span class="pre">products</span></code> ， <code class="docutils literal notranslate"><span class="pre">checkout</span></code> ， <code class="docutils literal notranslate"><span class="pre">backend</span></code> 等分类，而不是 <code class="docutils literal notranslate"><span class="pre">views</span></code> ， <code class="docutils literal notranslate"><span class="pre">models</span></code> ， <code class="docutils literal notranslate"><span class="pre">controllers</span></code> 。</p>
</div>
</div>
<span id="document-google-typescript-styleguide/type_system"></span><div class="section" id="section-1">
<h3>类型系统</h3>
<div class="section" id="section-2">
<span id="ts-type-inference"></span><h4>类型推导</h4>
<p>对于所有类型的表达式（包括变量、字段、返回值，等等），都可以依赖 TypeScript 编译器所实现的类型推导。 google3 编译器会拒绝所有缺少类型记号又无法推导出其类型的代码，以保证所有的代码都具有类型（即使其中可能包括显式的 <code class="docutils literal notranslate"><span class="pre">any</span></code> 类型）。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>  <span class="c1">// x 的类型可以推导得出.</span>
</pre></div>
</div>
<p>当变量或参数被初始化为 <code class="docutils literal notranslate"><span class="pre">string</span></code> ， <code class="docutils literal notranslate"><span class="pre">number</span></code> ， <code class="docutils literal notranslate"><span class="pre">boolean</span></code> ， <code class="docutils literal notranslate"><span class="pre">RegExp</span></code> 正则表达式字面量或 <code class="docutils literal notranslate"><span class="pre">new</span></code> 表达式时，由于明显能够推导出类型，因此应当省略类型记号。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！添加 boolean 记号对提高可读性没有任何帮助！</span>
<span class="kr">const</span> <span class="nx">x</span>: <span class="kt">boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！Set 类型显然可以从初始化语句中推导得出。</span>
<span class="kr">const</span> <span class="nx">x</span>: <span class="kt">Set</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！依赖 TypeScript 的类型推导。</span>
<span class="kr">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
<p>对于更为复杂的表达式，类型记号有助于提高代码的可读性。此时是否使用类型记号应当由代码审查员决定。</p>
<div class="section" id="section-3">
<span id="ts-return-types"></span><h5>返回类型</h5>
<p>代码的作者可以自由决定是否在函数和方法中使用类型记号标明返回类型。代码审查员 <em>可以</em> 要求对难以理解的复杂返回类型使用类型记号进行阐明。项目内部 <em>可以</em> 自行规定必须标明返回值，本文作为一个通用的 TypeScript 风格指南，不做硬性要求。</p>
<p>显式地标明函数和方法的返回值有两个优点：</p>
<ul class="simple">
<li>能够生成更精确的文档，有助于读者理解代码。</li>
<li>如果未来改变了函数的返回类型的话，可以让因此导致的潜在的错误更快地暴露出来。</li>
</ul>
</div>
</div>
<div class="section" id="null-undefined">
<span id="ts-null-vs-undefined"></span><h4>Null 还是 Undefined ？</h4>
<p>TypeScript 支持 <code class="docutils literal notranslate"><span class="pre">null</span></code> 和 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 类型。可空类型可以通过联合类型实现，例如 <code class="docutils literal notranslate"><span class="pre">string</span> <span class="pre">|</span> <span class="pre">null</span></code> 。对于 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 也是类似的。对于 <code class="docutils literal notranslate"><span class="pre">null</span></code> 和 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 的联合类型，并无特殊的语法。</p>
<p>TypeScript 代码中可以使用 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">null</span></code> 标记缺少的值，这里并无通用的规则约定应当使用其中的某一种。许多 JavaScript API 使用 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> （例如 <code class="docutils literal notranslate"><span class="pre">Map.get</span></code> ），然而 DOM 和 Google API 中则更多地使用 <code class="docutils literal notranslate"><span class="pre">null</span></code> （例如 <code class="docutils literal notranslate"><span class="pre">Element.getAttribute</span></code> ），因此，对于 <code class="docutils literal notranslate"><span class="pre">null</span></code> 和 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 的选择取决于当前的上下文。</p>
<div class="section" id="section-4">
<span id="ts-nullable-undefined-type-aliases"></span><h5>可空/未定义类型别名</h5>
<p><em>不允许</em> 为包括 <code class="docutils literal notranslate"><span class="pre">|null</span></code> 或 <code class="docutils literal notranslate"><span class="pre">|undefined</span></code> 的联合类型创建类型别名。这种可空的别名通常意味着空值在应用中会被层层传递，并且它掩盖了导致空值出现的源头。另外，这种别名也让类或接口中的某个值何时有可能为空变得不确定。</p>
<p>因此，代码 <em>必须</em> 在使用别名时才允许添加 <code class="docutils literal notranslate"><span class="pre">|null</span></code> 或者 <code class="docutils literal notranslate"><span class="pre">|undefined</span></code> 。同时，代码 <em>应当</em> 在空值出现位置的附近对其进行处理。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！不要在创建别名的时候包含 undefined ！</span>
<span class="nx">type</span> <span class="nx">CoffeeResponse</span> <span class="o">=</span> <span class="nx">Latte</span><span class="o">|</span><span class="nx">Americano</span><span class="o">|</span><span class="kc">undefined</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">CoffeeService</span> <span class="p">{</span>
    <span class="nx">getLatte</span><span class="p">()</span><span class="o">:</span> <span class="nx">CoffeeResponse</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！在使用别名的时候联合 undefined ！</span>
<span class="nx">type</span> <span class="nx">CoffeeResponse</span> <span class="o">=</span> <span class="nx">Latte</span><span class="o">|</span><span class="nx">Americano</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">CoffeeService</span> <span class="p">{</span>
    <span class="nx">getLatte</span><span class="p">()</span><span class="o">:</span> <span class="nx">CoffeeResponse</span><span class="o">|</span><span class="kc">undefined</span> <span class="p">{</span> <span class="p">...</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这样做更好！使用断言对可能的空值进行处理！</span>
<span class="nx">type</span> <span class="nx">CoffeeResponse</span> <span class="o">=</span> <span class="nx">Latte</span><span class="o">|</span><span class="nx">Americano</span><span class="p">;</span>

<span class="kr">class</span> <span class="nx">CoffeeService</span> <span class="p">{</span>
    <span class="nx">getLatte</span><span class="p">()</span><span class="o">:</span> <span class="nx">CoffeeResponse</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">assert</span><span class="p">(</span><span class="nx">fetchResponse</span><span class="p">(),</span> <span class="s1">&#39;Coffee maker is broken, file a ticket&#39;</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="undefined">
<span id="ts-optionals-vs-undefined-type"></span><h5>可选参数 还是 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 类型？</h5>
<p>TypeScript 支持使用 <code class="docutils literal notranslate"><span class="pre">?</span></code> 创建可选参数和可选字段，例如：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">CoffeeOrder</span> <span class="p">{</span>
    <span class="nx">sugarCubes</span>: <span class="kt">number</span><span class="p">;</span>
    <span class="nx">milk?</span>: <span class="kt">Whole</span><span class="o">|</span><span class="nx">LowFat</span><span class="o">|</span><span class="nx">HalfHalf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">pourCoffee</span><span class="p">(</span><span class="nx">volume?</span>: <span class="kt">Milliliter</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>可选参数实际上隐式地向类型中联合了 <code class="docutils literal notranslate"><span class="pre">|undefined</span></code> 。不同之处在于，在构造类实例或调用方法时，可选参数可以被直接省略。例如， <code class="docutils literal notranslate"><span class="pre">{sugarCubes:</span> <span class="pre">1}</span></code> 是一个合法的 <code class="docutils literal notranslate"><span class="pre">CoffeeOrder</span></code> ，因为 <code class="docutils literal notranslate"><span class="pre">milk</span></code> 字段是可选的。</p>
<p>应当使用可选字段（对于类或者接口）和可选参数而非联合 <code class="docutils literal notranslate"><span class="pre">|undefined</span></code> 类型。</p>
<p>对于类，应当尽可能避免使用可选字段，尽可能初始化每一个字段。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">MyClass</span> <span class="p">{</span>
    <span class="nx">field</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-5">
<span id="ts-structural-types-vs-nominal-types"></span><h4>结构类型 与 指名类型</h4>
<p>TypeScript 的类型系统使用的是结构类型而非指名类型。具体地说，一个值，如果它拥有某个类型的所有属性，且所有属性的类型能够递归地一一匹配，则这个值与这个类型也是匹配的。</p>
<p>在代码中，可以在适当的场景使用结构类型。具体地说，在测试代码之外，应当使用接口而非类对结构类型进行定义。在测试代码中，由于经常要创建 Mock 对象用于测试，此时不引入额外的接口往往较为方便。</p>
<p>在提供基于结构类型的实现时，应当在符号的声明位置显式地包含其类型，使类型检查和错误检测能够更准确地工作。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">const</span> <span class="nx">foo</span>: <span class="kt">Foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">a</span>: <span class="kt">123</span><span class="p">,</span>
    <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">badFoo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">a</span>: <span class="kt">123</span><span class="p">,</span>
    <span class="nx">b</span><span class="o">:</span> <span class="s1">&#39;abc&#39;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为什么要这样做？</p>
<p>这是因为在上文中， <code class="docutils literal notranslate"><span class="pre">badFoo</span></code> 对象的类型依赖于类型推导。 <code class="docutils literal notranslate"><span class="pre">badFoo</span></code> 对象中可能添加额外的字段，此时类型推导的结果就有可能发生变化。</p>
<p>如果将 <code class="docutils literal notranslate"><span class="pre">badFoo</span></code> 传给接收 <code class="docutils literal notranslate"><span class="pre">Foo</span></code> 类型参数的函数，错误提示会出现在函数调用的位置，而非对象声明的位置。在大规模的代码仓库中修改接口时，这一点区别会很重要。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
    <span class="nx">sound</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">makeSound</span><span class="p">(</span><span class="nx">animal</span>: <span class="kt">Animal</span><span class="p">)</span> <span class="p">{}</span>

<span class="cm">/**</span>
<span class="cm"> * &#39;cat&#39; 的类型会被推导为 &#39;{sound: string}&#39;</span>
<span class="cm"> */</span>
<span class="kr">const</span> <span class="nx">cat</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">sound</span><span class="o">:</span> <span class="s1">&#39;meow&#39;</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * &#39;cat&#39; 的类型并不满足函数参数的要求，</span>
<span class="cm"> * 因此 TypeScript 编译器会在这里报错，</span>
<span class="cm"> * 而这里有可能离 &#39;cat&#39; 的定义相当远。</span>
<span class="cm"> */</span>
<span class="nx">makeSound</span><span class="p">(</span><span class="nx">cat</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Horse 具有结构类型，因此这里会提示类型错误，而函数调用点不会报错。</span>
<span class="cm"> * 这是因为 &#39;horse&#39; 不满足接口 &#39;Animal&#39; 的类型约定。</span>
<span class="cm"> */</span>
<span class="kr">const</span> <span class="nx">horse</span>: <span class="kt">Animal</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">sound</span><span class="o">:</span> <span class="s1">&#39;niegh&#39;</span><span class="p">,</span>
<span class="p">};</span>

<span class="kr">const</span> <span class="nx">dog</span>: <span class="kt">Animal</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">sound</span><span class="o">:</span> <span class="s1">&#39;bark&#39;</span><span class="p">,</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;MrPickles&#39;</span><span class="p">,</span>
<span class="p">};</span>

<span class="nx">makeSound</span><span class="p">(</span><span class="nx">dog</span><span class="p">);</span>
<span class="nx">makeSound</span><span class="p">(</span><span class="nx">horse</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<span id="ts-interface-vs-type-aliases"></span><h4>接口 还是 类型别名？</h4>
<p>TypeScript 支持使用 <a class="reference external" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases">类型别名</a> 为类型命名。这一功能可以用于基本类型、联合类型、元组以及其它类型。</p>
<p>然而，当需要声明用于对象的类型时，应当使用接口，而非对象字面量表达式的类型别名。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nx">firstName</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">lastName</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="nx">type</span> <span class="nx">User</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">firstName</span>: <span class="kt">string</span><span class="p">,</span>
    <span class="nx">lastName</span>: <span class="kt">string</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为什么？</p>
<p>这两种形式是几乎等价的，因此，基于从两个形式中只选择其中一种以避免项目中出现变种的原则，这里选择了更常见的接口形式。另外，这里选择接口还有一个 <a class="reference external" href="https://ncjamieson.com/prefer-interfaces/">有趣的技术原因</a> 。这篇博文引用了 TypeScript 团队负责人的话：“老实说，我个人的意见是对于任何可以建模的对象都应当使用接口。相比之下，使用类型别名没有任何优势，尤其是类型别名有许多的显示和性能问题”。</p>
</div>
<div class="section" id="array-t">
<span id="ts-array-type"></span><h4><code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> 类型</h4>
<p>对于简单类型（名称中只包含字母、数字和点 <code class="docutils literal notranslate"><span class="pre">.</span></code> 的类型），应当使用数组的语法糖 <code class="docutils literal notranslate"><span class="pre">T[]</span></code> ，而非更长的 <code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> 形式。</p>
<p>对于其它复杂的类型，则应当使用较长的 <code class="docutils literal notranslate"><span class="pre">Array&lt;T&gt;</span></code> 。</p>
<p>这条规则也适用于 <code class="docutils literal notranslate"><span class="pre">readonly</span> <span class="pre">T[]</span></code> 和 <code class="docutils literal notranslate"><span class="pre">ReadonlyArray&lt;T&gt;</span></code> 。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">const</span> <span class="nx">a</span>: <span class="kt">string</span><span class="p">[];</span>
<span class="kr">const</span> <span class="nx">b</span>: <span class="kt">readonly</span> <span class="kt">string</span><span class="p">[];</span>
<span class="kr">const</span> <span class="nx">c</span>: <span class="kt">ns.MyObj</span><span class="p">[];</span>
<span class="kr">const</span> <span class="nx">d</span>: <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">|</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">e</span>: <span class="kt">ReadonlyArray</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">|</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">f</span>: <span class="kt">Array</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">;</span>            <span class="c1">// 语法糖写法更短。</span>
<span class="kr">const</span> <span class="nx">g</span>: <span class="kt">ReadonlyArray</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">h</span><span class="o">:</span> <span class="p">{</span><span class="nx">n</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">s</span>: <span class="kt">string</span><span class="p">}[];</span> <span class="c1">// 大括号和中括号让这行代码难以阅读。</span>
<span class="kr">const</span> <span class="nx">i</span><span class="o">:</span> <span class="p">(</span><span class="kt">string</span><span class="o">|</span><span class="kt">number</span><span class="p">)[];</span>
<span class="kr">const</span> <span class="nx">j</span>: <span class="kt">readonly</span> <span class="p">(</span><span class="kt">string</span><span class="o">|</span><span class="kt">number</span><span class="p">)[];</span>
</pre></div>
</div>
</div>
<div class="section" id="key-string-number">
<span id="ts-indexable-type"></span><h4>索引类型 <code class="docutils literal notranslate"><span class="pre">{[key:</span> <span class="pre">string]:</span> <span class="pre">number}</span></code></h4>
<p>在 JavaScript 中，使用对象作为关联数组（又称“映射表”、“哈希表”或者“字典”）是一种常见的做法：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">const</span> <span class="nx">fileSizes</span><span class="o">:</span> <span class="p">{[</span><span class="nx">fileName</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">}</span> <span class="o">=</span> <span class="p">{};</span>
<span class="nx">fileSizes</span><span class="p">[</span><span class="s1">&#39;readme.txt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">541</span><span class="p">;</span>
</pre></div>
</div>
<p>在 TypeScript 中，应当为键提供一个有意义的标签名。（当然，这个标签只有在文档中有实际意义，在其它场合是无用的。）</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">users</span><span class="o">:</span> <span class="p">{[</span><span class="nx">key</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">}</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kr">const</span> <span class="nx">users</span><span class="o">:</span> <span class="p">{[</span><span class="nx">userName</span>: <span class="kt">string</span><span class="p">]</span><span class="o">:</span> <span class="kt">number</span><span class="p">}</span> <span class="o">=</span> <span class="p">...;</span>
</pre></div>
</div>
<p>然而，相比使用上面的这种形式，在 TypeScript 中应当考虑使用 ES6 新增的 <code class="docutils literal notranslate"><span class="pre">Map</span></code> 与 <code class="docutils literal notranslate"><span class="pre">Set</span></code> 类型。因为 JavaScript 对象有一些 <a class="reference external" href="http://2ality.com/2012/01/objects-as-maps.html">令人困惑又不符合预期的行为</a> ，而 ES6 的新增类型能够更明确地表达程序员的设计思路。此外， <code class="docutils literal notranslate"><span class="pre">Map</span></code> 类型的键和 <code class="docutils literal notranslate"><span class="pre">Set</span></code> 类型的元素都允许使用 <code class="docutils literal notranslate"><span class="pre">string</span></code> 以外的其他类型。</p>
<p>TypeScript 内建的 <code class="docutils literal notranslate"><span class="pre">Record&lt;Keys,</span> <span class="pre">ValueType&gt;</span></code> 允许使用已定义的一组键创建类型。它与关联数组的不同之处在于键是静态确定的。关于它的使用建议，参见 <a class="reference internal" href="#ts-mapped-conditional-types"><span class="std std-ref">映射类型与条件类型</span></a> 一节。</p>
</div>
<div class="section" id="section-7">
<span id="ts-mapped-conditional-types"></span><h4>映射类型与条件类型</h4>
<p>TypeScript 中的 <a class="reference external" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types">映射类型</a> 与 <a class="reference external" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#conditional-types">条件类型</a> 让程序员能够在已有类型的基础上构建出新的类型。在 TypeScript 的标准库中有许多类型运算符都是基于这一机制（例如 <code class="docutils literal notranslate"><span class="pre">Record</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Partial</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Readonly</span></code> 等等）。</p>
<p>TypeScript 类型系统的这一特性让创建新类型变得简洁，还程序员在设计代码抽象时，既能实现强大的功能，同时海能保证类型安全。然而，它们也有一些缺点：</p>
<ul class="simple">
<li>相较于显式地指定属性与类型间关系（例如使用接口和继承，参见下文中的例子），类型运算符需要读者在头脑中自行对后方的类型表达式进行求值。本质上说，这增加了程序的理解难度，尤其是在类型推导和类型表达式有可能横跨数个文件的情况下。</li>
<li>映射类型与条件类型的求值模型并没有明确的规范，且经常随着 TypeScript 编译器的版本更新而发生变化，因此并不总是易于理解，尤其是与类型推导一同使用时。因此，代码有可能只是碰巧能够通过编译或者给出正确的结果。在这种情况下，使用类型运算符增加了代码未来的维护成本。</li>
<li>映射类型与条件类型最为强大之处在于，它们能够从复杂且/或推导的类型中派生出新的类型。然而从另一方面看，这样做也很容易导致程序难于理解与维护。</li>
<li>有些语法工具并不能够很好地支持类型系统的这一特性。例如，一些 IDE 的“查找引用”功能（以及依赖于它的“重命名重构”）无法发现位于 <code class="docutils literal notranslate"><span class="pre">Pick&lt;T,</span> <span class="pre">Keys&gt;</span></code> 类型中的属性，因而在查找结果中不会将其设为高亮。</li>
</ul>
<p>因此，推荐的代码规范如下：</p>
<ul class="simple">
<li>任何使用都应当使用最简单的类型构造方式进行表达。</li>
<li>一定程度的重复或冗余，往往好过复杂的类型表达式带来的长远维护成本。</li>
<li>映射类型和条件类型必须在符合上述理念的情况下使用。</li>
</ul>
<p>例如，TypeScript 内建的 <code class="docutils literal notranslate"><span class="pre">Pick&lt;T,</span> <span class="pre">Keys&gt;</span></code> 类型允许以类型 <code class="docutils literal notranslate"><span class="pre">T</span></code> 的子集创建新的类型。然而，使用接口和继承的方式实现往往更易于理解。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
    <span class="nx">shoeSize</span>: <span class="kt">number</span><span class="p">;</span>
    <span class="nx">favoriteIcecream</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">favoriteChocolate</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// FoodPreferences 类型拥有 favoriteIcecream 和 favoriteChocolate，但不包括 shoeSize。</span>
<span class="nx">type</span> <span class="nx">FoodPreferences</span> <span class="o">=</span> <span class="nx">Pick</span><span class="o">&lt;</span><span class="nx">User</span><span class="p">,</span> <span class="s1">&#39;favoriteIcecream&#39;</span><span class="o">|</span><span class="s1">&#39;favoriteChocolate&#39;</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>这种写法等价于显式地写出 <code class="docutils literal notranslate"><span class="pre">FoodPreferences</span></code> 的属性：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">FoodPreferences</span> <span class="p">{</span>
    <span class="nx">favoriteIcecream</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">favoriteChocolate</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>为了减少重复，可以让 <code class="docutils literal notranslate"><span class="pre">User</span></code> 继承 <code class="docutils literal notranslate"><span class="pre">FoodPreferences</span></code> ，或者在 <code class="docutils literal notranslate"><span class="pre">User</span></code> 中嵌套一个类型为 <code class="docutils literal notranslate"><span class="pre">FoodPrefences</span></code> 的字段（这样做可能更好）：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kr">interface</span> <span class="nx">FoodPreferences</span> <span class="p">{</span> <span class="cm">/* 同上 */</span> <span class="p">}</span>

<span class="kr">interface</span> <span class="nx">User</span> <span class="kr">extends</span> <span class="nx">FoodPreferences</span> <span class="p">{</span>
    <span class="nx">shoeSize</span>: <span class="kt">number</span><span class="p">;</span>
    <span class="c1">// 这样 User 也包括了 FoodPreferences 的字段。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用接口让属性的分类变得清晰，IDE 的支持更完善，方便进一步优化，同时使得代码更易于理解。</p>
</div>
<div class="section" id="any">
<span id="ts-any-type"></span><h4><code class="docutils literal notranslate"><span class="pre">any</span></code> 类型</h4>
<p>TypeScript 的 <code class="docutils literal notranslate"><span class="pre">any</span></code> 类型是所有其它类型的超类，又是所有其它类型的子类，同时还允许解引用一切属性。因此，使用 <code class="docutils literal notranslate"><span class="pre">any</span></code> 十分危险——它会掩盖严重的程序错误，并且它从根本上破坏了对应的值“具有静态属性”的原则。</p>
<p>尽可能 <em>不要</em> 使用 <code class="docutils literal notranslate"><span class="pre">any</span></code> 。如果出现了需要使用 <code class="docutils literal notranslate"><span class="pre">any</span></code> 的场景，可以考虑下列的解决方案：</p>
<ul class="simple">
<li><a class="reference internal" href="#ts-provide-a-more-specific-type"><span class="std std-ref">提供一个更具体的类型</span></a></li>
<li><a class="reference internal" href="#ts-using-unknown-over-any"><span class="std std-ref">使用 unknown 而非 any</span></a></li>
<li><a class="reference internal" href="#ts-suppress-the-lint-warning"><span class="std std-ref">关闭 Lint 工具对 any 的警告</span></a></li>
</ul>
<div class="section" id="section-8">
<span id="ts-provide-a-more-specific-type"></span><h5>提供一个更具体的类型</h5>
<p>使用接口、内联对象类型、或者类型别名：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 声明接口类型以表示服务端发送的 JSON。</span>
<span class="kr">declare</span> <span class="kr">interface</span> <span class="nx">MyUserJson</span> <span class="p">{</span>
    <span class="nx">name</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">email</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 对重复出现的类型使用类型别名。</span>
<span class="nx">type</span> <span class="nx">MyType</span> <span class="o">=</span> <span class="kt">number</span><span class="o">|</span><span class="kt">string</span><span class="p">;</span>

<span class="c1">// 或者对复杂的返回类型使用内联对象类型。</span>
<span class="kd">function</span> <span class="nx">getTwoThings</span><span class="p">()</span><span class="o">:</span> <span class="p">{</span><span class="nx">something</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">other</span>: <span class="kt">string</span><span class="p">}</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="p">{</span><span class="nx">something</span><span class="p">,</span> <span class="nx">other</span><span class="p">};</span>
<span class="p">}</span>

<span class="c1">// 使用泛型，有些库在这种情况下可能会使用 any 表示</span>
<span class="c1">// 这里并不考虑函数所作用于的参数类型。</span>
<span class="c1">// 注意，对于这种写法，“只有泛型的返回类型”一节有更详细的规范。</span>
<span class="kd">function</span> <span class="nx">nicestElement</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">items</span>: <span class="kt">T</span><span class="p">[])</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
    <span class="c1">// 在 items 中查找最棒的元素。</span>
    <span class="c1">// 这里还可以进一步为泛型参数 T 添加限制，例如 &lt;T extends HTMLElement&gt;。</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="unknown-any">
<span id="ts-using-unknown-over-any"></span><h5>使用 <code class="docutils literal notranslate"><span class="pre">unknown</span></code> 而非 <code class="docutils literal notranslate"><span class="pre">any</span></code></h5>
<p><code class="docutils literal notranslate"><span class="pre">any</span></code> 类型的值可以赋给其它任何类型，还可以对其解引用任意属性。一般来说，这个行为不是必需的，也不符合期望，此时代码试图表达的内容其实是“该类型是未知的”。在这种情况下，应当使用内建的 <code class="docutils literal notranslate"><span class="pre">unknown</span></code> 类型。它能够表达相同的语义，并且，因为 <code class="docutils literal notranslate"><span class="pre">unknown</span></code> 不能解引用任意属性，它较 <code class="docutils literal notranslate"><span class="pre">any</span></code> 而言更为安全。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="c1">// 可以将任何值（包括 null 和 undefined）赋给 val，</span>
<span class="c1">// 但在缩窄类型或者类型转换之前并不能使用它。</span>
<span class="kr">const</span> <span class="nx">val</span>: <span class="kt">unknown</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">const</span> <span class="nx">danger</span>: <span class="kt">any</span> <span class="o">=</span> <span class="nx">value</span> <span class="cm">/* 这是任意一个表达式的结果 */</span><span class="p">;</span>
<span class="nx">danger</span><span class="p">.</span><span class="nx">whoops</span><span class="p">();</span>  <span class="c1">// 完全未经检查的访问！</span>
</pre></div>
</div>
</div>
<div class="section" id="lint-any">
<span id="ts-suppress-the-lint-warning"></span><h5>关闭 Lint 工具对 <code class="docutils literal notranslate"><span class="pre">any</span></code> 的警告</h5>
<p>有时使用 <code class="docutils literal notranslate"><span class="pre">any</span></code> 是合理的，例如用于在测试中构造 Mock 对象。在这种情况下，应当添加注释关闭 Lint 工具对此的警告，并添加文档对使用 any 的合理性进行说明。</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 这个测试只需要部分地实现 BookService，否则测试会失败。</span>
<span class="c1">// 所以，这里有意地使用了一个不安全的部分实现 Mock 对象。</span>
<span class="c1">// tslint:disable-next-line:no-any</span>
<span class="kr">const</span> <span class="nx">mockBookService</span> <span class="o">=</span> <span class="p">({</span><span class="nx">get() {</span> <span class="k">return</span> <span class="nx">mockBook</span><span class="p">;</span> <span class="p">}}</span> <span class="kr">as</span> <span class="nx">any</span><span class="p">)</span> <span class="kr">as</span> <span class="nx">BookService</span><span class="p">;</span>
<span class="c1">// 购物车在这个测试里并未使用。</span>
<span class="c1">// tslint:disable-next-line:no-any</span>
<span class="kr">const</span> <span class="nx">component</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyComponent</span><span class="p">(</span><span class="nx">mockBookService</span><span class="p">,</span> <span class="cm">/* unused ShoppingCart */</span> <span class="kc">null</span> <span class="kr">as</span> <span class="nx">any</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-9">
<span id="ts-tuple-types"></span><h4>元组类型</h4>
<p>应当使用元组类型代替常见的 <code class="docutils literal notranslate"><span class="pre">Pair</span></code> 类型的写法：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 不要这样做！</span>
<span class="kr">interface</span> <span class="nx">Pair</span> <span class="p">{</span>
    <span class="nx">first</span>: <span class="kt">string</span><span class="p">;</span>
    <span class="nx">second</span>: <span class="kt">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">splitInHalf</span><span class="p">(</span><span class="nx">input</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">Pair</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="p">{</span><span class="nx">first</span>: <span class="kt">x</span><span class="p">,</span> <span class="nx">second</span>: <span class="kt">y</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="c1">// 应当这样做！</span>
<span class="kd">function</span> <span class="nx">splitInHalf</span><span class="p">(</span><span class="nx">input</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="p">[</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">]</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// 这样使用:</span>
<span class="kr">const</span> <span class="p">[</span><span class="nx">leftHalf</span><span class="p">,</span> <span class="nx">rightHalf</span><span class="p">]</span> <span class="o">=</span> <span class="nx">splitInHalf</span><span class="p">(</span><span class="s1">&#39;my string&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>然而通常情况下，为属性提供一个有意义的名称往往能让代码更加清晰。</p>
<p>如果为此声明一个接口过于繁重的话，可以使用内联对象字面量类型：</p>
<div class="highlight-typescript notranslate"><div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">splitHostPort</span><span class="p">(</span><span class="nx">address</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="p">{</span><span class="nx">host</span>: <span class="kt">string</span><span class="p">,</span> <span class="nx">port</span>: <span class="kt">number</span><span class="p">}</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// 这样使用:</span>
<span class="kr">const</span> <span class="nx">address</span> <span class="o">=</span> <span class="nx">splitHostPort</span><span class="p">(</span><span class="nx">userAddress</span><span class="p">);</span>
<span class="nx">use</span><span class="p">(</span><span class="nx">address</span><span class="p">.</span><span class="nx">port</span><span class="p">);</span>

<span class="c1">// 也可以使用解构进行形如元组的操作：</span>
<span class="kr">const</span> <span class="p">{</span><span class="nx">host</span><span class="p">,</span> <span class="nx">port</span><span class="p">}</span> <span class="o">=</span> <span class="nx">splitHostPort</span><span class="p">(</span><span class="nx">userAddress</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-10">
<span id="ts-wrapper-types"></span><h4>包装类型</h4>
<p>不要使用如下几种类型，它们是 JavaScript 中基本类型的包装类型：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">String</span></code> 、 <code class="docutils literal notranslate"><span class="pre">Boolean</span></code> 和 <code class="docutils literal notranslate"><span class="pre">Number</span></code> 。它们的含义和对应的基本类型 <code class="docutils literal notranslate"><span class="pre">string</span></code> 、 <code class="docutils literal notranslate"><span class="pre">boolean</span></code> 和 <code class="docutils literal notranslate"><span class="pre">number</span></code> 略有不同。任何时候，都应当使用后者。</li>
<li><code class="docutils literal notranslate"><span class="pre">Object</span></code> 。它和 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 与 <code class="docutils literal notranslate"><span class="pre">object</span></code> 类似，但包含的范围略微更大。应当使用 <code class="docutils literal notranslate"><span class="pre">{}</span></code> 表示“包括除 <code class="docutils literal notranslate"><span class="pre">null</span></code> 和 <code class="docutils literal notranslate"><span class="pre">undefined</span></code> 之外所有类型”的类型，使用 <code class="docutils literal notranslate"><span class="pre">object</span></code> 表示“所有基本类型以外”的类型（这里的“所有基本类型”包括上文中提到的基本类型， <code class="docutils literal notranslate"><span class="pre">symbol</span></code> 和 <code class="docutils literal notranslate"><span class="pre">bigint</span></code> ）。</li>
</ul>
<p>此外，不要将包装类型用作构造函数。</p>
</div>
<div class="section" id="section-11">
<span id="ts-return-type-only-generics"></span><h4>只有泛型的返回类型</h4>
<p>不要创建返回类型只有泛型的 API。如果现有的 API 中存在这种情况，使用时应当显式地标明泛型参数类型。</p>
</div>
</div>
<span id="document-google-typescript-styleguide/consistency"></span><div class="section" id="section-1">
<h3>一致性</h3>
<p>对于本文中并未明确解释的任何与代码风格有关的问题，都应当与同一文件中其它代码的现有写法 <strong>保持一致</strong> 。如果问题仍未得到解决，则应当参考同一文件夹下其它文件的写法。</p>
<div class="section" id="section-2">
<span id="ts-goals"></span><h4>目标</h4>
<p>通常情况下，程序员自己是最了解他们的代码需求的人。所以，对于那些答案不唯一、而且最优解取决于实际场景的问题，一般应当由当事人根据情况自行决定解决方案。因此，对于这类问题，默认回答往往都是“不管了”。</p>
<p>以下几点则是其中的特例，它们解释了为什么要在这篇风格指南中编写全局性的规范。对于程序员自行规定的代码风格，应当根据以下几个原则对其进行评估：</p>
<ol class="arabic simple">
<li><strong>应当避免使用已知的会导致问题的代码范式，尤其是对于这门语言的新手而言</strong></li>
</ol>
<p>例如：</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">any</span></code> 是一个容易被误用的类型（某个变量 <em>真的</em> 可以既是一个数字，同时还可以作为函数被调用吗？），因此关于它的用法，指南中提出了一些建议。</li>
<li>TypeScript 的命名空间会为闭包优化带来问题。</li>
<li>在文件名中使用句点 <code class="docutils literal notranslate"><span class="pre">.</span></code> 会让导入语句的样式变得不美观且令人困惑。</li>
<li>类中的静态函数对优化十分不友好，同样的功能完全可以由文件级函数实现。</li>
<li>不熟悉 <code class="docutils literal notranslate"><span class="pre">private</span></code> 关键字的用户会试图使用下划线将函数名变得混乱难懂。</li>
</ul>
<ol class="arabic simple" start="2">
<li><strong>跨项目的代码应当保持一致的用法</strong></li>
</ol>
<p>如果有两种语义上等价只是形式上不同的写法，应当只选择其中的一种，以避免代码中发生无意义的发散演化，同时也避免在代码审查的过程中进行无意义的争辩。</p>
<p>除此之外，还应当尽可能与 JavaScript 的代码风格保持一致，因为大部分程序员都会同时使用两种语言。</p>
<p>例如：</p>
<ul class="simple">
<li>变量名的首字母大小写风格。</li>
<li><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">as</span> <span class="pre">T</span></code> 语法和等价的 <code class="docutils literal notranslate"><span class="pre">&lt;T&gt;x</span></code> 语法（后者不允许使用）。</li>
<li><code class="docutils literal notranslate"><span class="pre">Array&lt;[number,</span> <span class="pre">number]&gt;</span></code> 和 <code class="docutils literal notranslate"><span class="pre">[number,</span> <span class="pre">number][]</span></code> 。</li>
</ul>
<ol class="arabic simple" start="3">
<li><strong>代码应当具有长期可维护性</strong></li>
</ol>
<p>代码的生命周期往往比其原始作者为其工作的时间要长，而 TypeScript 团队必须保证谷歌的所有工作在未来依然能顺利进行。</p>
<p>例如：</p>
<ul class="simple">
<li>使用自动化工具修改代码，所有的代码均经过自动格式化以符合空格样式的规范。</li>
<li>规定了一组 Clousure 编译器标识，使 TS 代码库在编写过程中无需考虑编译选项的问题，也让用户能够安全地使用共享库。</li>
<li>代码在使用其它库时必须进行导入（严格依赖），以便依赖项中的重构不会改变其用户的依赖项。</li>
<li>用户必须编写测试。如果没有测试，就无法保证对语言或 google3 库中的改动不会破坏用户现有的代码。</li>
</ul>
<ol class="arabic simple" start="4">
<li><strong>代码审查员应当着力于提高代码质量，而非强制推行各种规则</strong></li>
</ol>
<p>如果能够将规范实现为自动化检查工具，这通常都是一个好的做法。这对上文中的第三条原则也有所帮助。</p>
<p>对于确实无关紧要的问题，例如语言中十分罕见的边界情况，或者避免了一个不太可能发生的 Bug ，等等，不妨直接无视之。</p>
</div>
</div>
</div>
</div>
<span id="document-google-html-css-styleguide/contents"></span><div class="section" id="html-css">
<span id="html-css-contents"></span><h2>HTML/CSS 风格指南 - 内容目录</h2>
<div class="toctree-wrapper compound">
<span id="document-google-html-css-styleguide/background"></span><div class="section" id="section-1">
<h3>背景</h3>
<p>本文档定义了HTML/CSS的排版以及风格的规则。旨在促进合作编程、提高代码质量并且支持基本的架构。它适用于原生的HTML和CSS文件，包括GSS文件。只要保证代码的整体质量，就可以很容易地使用工具进行混淆、压缩和合并。</p>
</div>
<span id="document-google-html-css-styleguide/general_style_rules"></span><div class="section" id="section-1">
<h3>整体样式规则</h3>
<div class="section" id="section-2">
<h4>协议</h4>
<p>嵌入式资源省略协议头。</p>
<p>省略图片、媒体文件、样式表以及脚本的URL协议头部分（http:、https:），不使用这两个协议的文件则不省略。
省略协议头，即让URL变成相对地址，可以避免协议混合及小文件重复下载。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;http://www.google.com/js/gweb/analytics/autotrack.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;//www.google.com/js/gweb/analytics/autotrack.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
</div>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="p">.</span><span class="nc">example</span> <span class="p">{</span>
 <span class="k">background</span><span class="p">:</span> <span class="nb">url</span><span class="p">(</span><span class="sx">http://www.google.com/images/example</span><span class="p">);</span>
<span class="p">}</span>

<span class="c">/* 推荐 */</span>
<span class="p">.</span><span class="nc">example</span> <span class="p">{</span>
  <span class="k">background</span><span class="p">:</span> <span class="nb">url</span><span class="p">(</span><span class="sx">//www.google.com/images/example</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-html-css-styleguide/general_formatting_rules"></span><div class="section" id="section-1">
<h3>总体排版规则</h3>
<div class="section" id="section-2">
<h4>缩进</h4>
<p>每次缩进使用两个空格。</p>
<p>不使用TAB键或者混合使用TAB键和空格进行缩进。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
 <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Fantastic
 <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Great
<span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</pre></div>
</div>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="nc">example</span> <span class="p">{</span>
 <span class="k">color</span><span class="p">:</span> <span class="kc">blue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h4>大小写</h4>
<p>只使用小写字母。</p>
<p>所有的代码都使用小写字母：适用于HTML元素、属性、属性值（除了text/CDATA）、CSS选择器、属性名以及属性值（字符串除外）。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">A</span> <span class="na">HREF</span><span class="o">=</span><span class="s">&quot;/&quot;</span><span class="p">&gt;</span>Home<span class="p">&lt;/</span><span class="nt">A</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;google.png&quot;</span> <span class="na">alt</span><span class="o">=</span><span class="s">&quot;Google&quot;</span><span class="p">&gt;</span>
</pre></div>
</div>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="nt">color</span><span class="o">:</span> <span class="p">#</span><span class="nn">E5E5E5</span><span class="o">;</span>

<span class="c">/* 推荐 */</span>
<span class="nt">color</span><span class="o">:</span> <span class="p">#</span><span class="nn">e5e5e5</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>尾部的空格</h4>
<p>删除尾部的空格。</p>
<p>尾部的空格是多余的，不删除则形成无意义的文件差异。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>What?_

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Yes please.
</pre></div>
</div>
</div>
</div>
<span id="document-google-html-css-styleguide/general_meta_rules"></span><div class="section" id="section-1">
<h3>整体的元数据规则</h3>
<div class="section" id="section-2">
<h4>编码</h4>
<p>使用UTF-8无BOM编码。</p>
<p>让你的编辑器使用无字节顺序标记的UTF-8编码。</p>
<p>在HTML模板和文档中使用 <code class="docutils literal notranslate"><span class="pre">&lt;meta</span> <span class="pre">charset=”utf-8”&gt;</span></code> 指定编码。不需要为样式表指定编码，它默认是UTF-8。</p>
<p>（想了解更多关于应该何时并如何指定编码，请查看 <a class="reference external" href="http://www.w3.org/International/tutorials/tutorial-char-enc/">Handling character encodings in HTML and CSS</a>）</p>
</div>
<div class="section" id="section-3">
<h4>注释</h4>
<p>在需要时尽可能去解释你的代码。</p>
<p>用注释去解释你的代码，包括它的应用范围、用途、此方案的选择理由等。</p>
<p>（这一条是可选的，没必要为每个文件写上详细的注释，会增重HTML/CSS的代码，主要取决于项目的复杂度。）</p>
</div>
<div class="section" id="section-4">
<h4>处理内容</h4>
<p>用TODO标记待办事宜和处理内容。</p>
<p>只用TODO来标记待办事宜，不要使用其他格式，例如&#64;&#64;。</p>
<p>在括号里添加联系方式（姓名或邮箱），格式为TODO（联系方式）。</p>
<p>在冒号后面添加处理内容，格式为TODO：处理内容。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span>{# TODO(john.doe): 重新处理水平居中 #}
<span class="p">&lt;</span><span class="nt">center</span><span class="p">&gt;</span>Test<span class="p">&lt;/</span><span class="nt">center</span><span class="p">&gt;</span>

<span class="c">&lt;!-- TODO: 移除可选的标签 --&gt;</span>
<span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
 <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Apples<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
 <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Oranges<span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-html-css-styleguide/html_style_rules"></span><div class="section" id="html">
<h3>HTML样式规则</h3>
<div class="section" id="section-1">
<h4>文档类型</h4>
<p>使用HTML5。</p>
<p>HTML5（HTML语法）是所有HTML文档的首选： <code class="docutils literal notranslate"><span class="pre">&lt;!DOCTYPE</span> <span class="pre">html&gt;</span></code> 。</p>
<p>（推荐使用HTML，即text/html。不要使用XHTML。XHTML，即 <a class="reference external" href="http://hixie.ch/advocacy/xhtml">application/xhtml+xml</a>，缺乏浏览器和基础结构的支持，并且优化的空间比HTML小。）
虽然HTML闭合标签没有问题，但是不要自闭合空标签。即写 <code class="docutils literal notranslate"><span class="pre">&lt;br&gt;</span></code> 而不是 <code class="docutils literal notranslate"><span class="pre">&lt;br</span> <span class="pre">/&gt;</span></code> 。</p>
</div>
<div class="section" id="html-1">
<h4>HTML合法性</h4>
<p>在可能的情况下使用合法的HTML。</p>
<p>使用合法的HTML代码，除非由于文件大小导致的不可达到的性能目标而不能使用。</p>
<p>利用已用工具对合法性进行测试，例如 <a class="reference external" href="http://validator.w3.org/nu/">W3C HTML validator</a>。</p>
<p>使用合法的HTML是一个可度量的基准质量属性，该属性有助于了解技术需求和约束，从而确保合理的HTML使用。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Test<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">article</span><span class="p">&gt;</span>This is only a test.

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&quot;utf-8&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Test<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">article</span><span class="p">&gt;</span>This is only a test.<span class="p">&lt;/</span><span class="nt">article</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-2">
<h4>语义化</h4>
<p>根据HTML的目的使用它。</p>
<p>根据元素（有时被错误的叫做“标签”）被创造的用途使用他们。比如，对标题使用标题元素，对段落使用 <code class="docutils literal notranslate"><span class="pre">p</span></code> 元素，对锚点使用 <code class="docutils literal notranslate"><span class="pre">a</span></code> 元素等。</p>
<p>语义化的使用HTML对于可访问性、复用性和代码的高效性等因素非常重要。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">onclick</span><span class="o">=</span><span class="s">&quot;goToRecommendations();&quot;</span><span class="p">&gt;</span>All recommendations<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;recommendations/&quot;</span><span class="p">&gt;</span>All recommendations<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h4>多媒体降级</h4>
<p>为多媒体提供替代内容。</p>
<p>对于图片、视频、通过 <code class="docutils literal notranslate"><span class="pre">canvas</span></code> 实现的动画等多媒体来说，确保提供可访问的替代内容。对于图片，可提供有意义的替代文本（ <code class="docutils literal notranslate"><span class="pre">alt</span></code> ）；对于视频和音频，如有条件可提供对白和字幕。</p>
<p>提供替代内容对辅助功能很重要：没有 <code class="docutils literal notranslate"><span class="pre">alt</span></code> ，一位盲人用户很难知道一张图片的内容，其他用户可能不能了解视频和音频的内容。
（对于 <code class="docutils literal notranslate"><span class="pre">alt</span></code> 属性会引起冗余的图片和你不打算添加CSS的纯粹装饰性的图片，不用添加替代文本，写成 <code class="docutils literal notranslate"><span class="pre">alt=&quot;&quot;</span></code> 即可。）</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;spreadsheet.png&quot;</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;spreadsheet.png&quot;</span> <span class="na">alt</span><span class="o">=</span><span class="s">&quot;Spreadsheet screenshot.&quot;</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>关注点分离</h4>
<p>将结构、表现、行为分离。</p>
<p>严格保持结构（标识），表现（样式），行为（脚本）分离，尽量使三者之间的相互影响最小。</p>
<p>就是说，确保文档和模板只包含HTML，并且HTML只用来表现结构。把任何表现性的东西都移到样式表，任何行为性的东西都移到脚本中。</p>
<p>此外，尽可能少的从文档和模板中引用样式表和脚本来减少三者的相互影响。</p>
<p>结构、表现、行为分离对维护非常重要。更改HTML文档和模板总是比更新样式表和脚本成本更高。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>HTML sucks<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;base.css&quot;</span> <span class="na">media</span><span class="o">=</span><span class="s">&quot;screen&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;grid.css&quot;</span> <span class="na">media</span><span class="o">=</span><span class="s">&quot;screen&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;print.css&quot;</span> <span class="na">media</span><span class="o">=</span><span class="s">&quot;print&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">h1</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;font-size: 1em;&quot;</span><span class="p">&gt;</span>HTML sucks<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>I’ve read about this on a few sites but now I’m sure:
  <span class="p">&lt;</span><span class="nt">u</span><span class="p">&gt;</span>HTML is stupid!!1<span class="p">&lt;/</span><span class="nt">u</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">center</span><span class="p">&gt;</span>I can’t believe there’s no way to control the styling of
  my website without doing everything all over again!<span class="p">&lt;/</span><span class="nt">center</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>My first CSS-only redesign<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">link</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;stylesheet&quot;</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;default.css&quot;</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">h1</span><span class="p">&gt;</span>My first CSS-only redesign<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>I’ve read about this on a few sites but today I’m actually
  doing it: separating concerns and avoiding anything in the HTML of
  my website that is presentational.
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>It’s awesome!
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>实体引用</h4>
<p>不要使用实体引用。</p>
<p>假设文件、编辑器和团队之间使用相同的编码（UTF-8），则没有必要使用例如 <code class="docutils literal notranslate"><span class="pre">&amp;mdash;</span></code> 、 <code class="docutils literal notranslate"><span class="pre">&amp;rdquo;</span></code> 或 <code class="docutils literal notranslate"><span class="pre">&amp;#x263a;</span></code> 这样的实体引用。</p>
<p>唯一的例外适用于HTML中具有特殊意义的字符（比如&lt;和&amp;），和控制或者隐藏的字符（比如不换行空格）。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
The currency symbol for the Euro is <span class="ni">&amp;ldquo;&amp;eur;&amp;rdquo;</span>.

<span class="c">&lt;!-- 推荐 --&gt;</span>
The currency symbol for the Euro is &quot;€&quot;.
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h4>可选的标签</h4>
<p>省略可选的标签（可选）。</p>
<p>为了优化文件大小和可扫描，考虑省略可选标签。 <a class="reference external" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#syntax-tag-omission">HTML5规范</a> 定义了哪些标签可以被省略。</p>
<p>（这种方法可能要求一段宽限期去建立一个更加广泛的准则，因为它和Web开发人员通常所了解的有着显著不同。考虑到一致性和简单性，最好省略所有可选标签。）</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
 <span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
   <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Spending money, spending bytes<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
 <span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
 <span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
   <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Sic.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
 <span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Saving money, saving bytes<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Qed.
</pre></div>
</div>
</div>
<div class="section" id="type">
<h4>type属性</h4>
<p>为样式表和脚本省略 <code class="docutils literal notranslate"><span class="pre">type</span></code> 属性。</p>
<p>引用样式表（除非不是使用CSS）和脚本（除非不是使用JavaScript）不要使用type属性。</p>
<p>HTML5将 <a class="reference external" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/semantics.html#attr-style-type">text/css</a> 和 <a class="reference external" href="http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#attr-script-type">text/javascript</a> 设置为默认值，在这种情况下指定type属性并不必要。甚至同样兼容老版本的浏览器。</p>
</div>
</div>
<span id="document-google-html-css-styleguide/html_formatting_rules"></span><div class="section" id="html">
<h3>HTML格式规则</h3>
<div class="section" id="section-1">
<h4>常规格式化</h4>
<p>对每个块、列表、表格元素都另起一行，每个子元素都缩进。</p>
<p>每个块元素、列表元素或表格元素另起一行，而不必考虑元素的样式（因CSS可以改变元素的 <code class="docutils literal notranslate"><span class="pre">display</span></code> 属性）。</p>
<p>同样的，如果他们是块、列表或者表格元素的子元素，则将之缩进。</p>
<p>（如果你遇到列表项之间有空白的问题，可以把所有 <code class="docutils literal notranslate"><span class="pre">li</span></code> 元素放到一行。Linter鼓励抛出警告而不是错误。）</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">blockquote</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;&lt;</span><span class="nt">em</span><span class="p">&gt;</span>Space<span class="p">&lt;/</span><span class="nt">em</span><span class="p">&gt;</span>, the final frontier.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">blockquote</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Moe
  <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Larry
  <span class="p">&lt;</span><span class="nt">li</span><span class="p">&gt;</span>Curly
<span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>

<span class="p">&lt;</span><span class="nt">table</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">thead</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">tr</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">th</span> <span class="na">scope</span><span class="o">=</span><span class="s">&quot;col&quot;</span><span class="p">&gt;</span>Income
      <span class="p">&lt;</span><span class="nt">th</span> <span class="na">scope</span><span class="o">=</span><span class="s">&quot;col&quot;</span><span class="p">&gt;</span>Taxes
  <span class="p">&lt;</span><span class="nt">tbody</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">tr</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>$ 5.00
      <span class="p">&lt;</span><span class="nt">td</span><span class="p">&gt;</span>$ 4.50
<span class="p">&lt;/</span><span class="nt">table</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="html-1">
<h4>HTML引号</h4>
<p>当引用属性值时，使用双引号。</p>
<p>使用双引号而不是单引号来包裹属性值。</p>
<div class="highlight-html notranslate"><div class="highlight"><pre><span></span><span class="c">&lt;!-- 不推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">a</span> <span class="na">class</span><span class="o">=</span><span class="s">&#39;maia-button maia-button-secondary&#39;</span><span class="p">&gt;</span>Sign in<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>

<span class="c">&lt;!-- 推荐 --&gt;</span>
<span class="p">&lt;</span><span class="nt">a</span> <span class="na">class</span><span class="o">=</span><span class="s">&quot;maia-button maia-button-secondary&quot;</span><span class="p">&gt;</span>Sign in<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-html-css-styleguide/css_style_rules"></span><div class="section" id="css">
<h3>css样式规则</h3>
<div class="section" id="css-1">
<h4>CSS有效性</h4>
<p>尽可能使用有效的CSS。</p>
<p>使用有效的CSS代码，除非在处理css验证器bug或者是专有的语法时。</p>
<p>使用诸如 <a class="reference external" href="http://jigsaw.w3.org/css-validator/">W3C CSS validator</a> 等工具验证测试。</p>
<p>使用有效的CSS代码是一个可衡量CSS代码质量的指标，可帮你找出不起作用可被删除的CSS代码，从而确保CSS的合理使用。</p>
</div>
<div class="section" id="idclass">
<h4>id与class的命名</h4>
<p>使用有意义的或者通用的id和class名称</p>
<p>用能反映出元素目的或者通用的id、class名称，代替那些很表象的、难懂的名称。</p>
<p>如果名称需要是易懂的，或不容易被修改，应该首选特定的或者能反映出元素目的的名称。</p>
<p>通用的名称适用于非特殊元素或与兄弟元素无区别的元素。他们常被称为“辅助元素”。</p>
<p>使用功能性或者通用的名称，可减少不必要的文档或者模板变化。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐：无意义 */</span>
<span class="p">#</span><span class="nn">yee-1901</span> <span class="p">{}</span>


<span class="c">/* 不推荐：表象 */</span>
<span class="p">.</span><span class="nc">button-green</span> <span class="p">{}</span>
<span class="p">.</span><span class="nc">clear</span> <span class="p">{}</span>

<span class="c">/* 推荐：具体的 */</span>
<span class="p">#</span><span class="nn">gallery</span> <span class="p">{}</span>
<span class="p">#</span><span class="nn">login</span> <span class="p">{}</span>
<span class="p">.</span><span class="nc">video</span> <span class="p">{}</span>

<span class="c">/* 推荐：通用的 */</span>
<span class="p">.</span><span class="nc">aux</span> <span class="p">{}</span>
<span class="p">.</span><span class="nc">alt</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="idclass-1">
<h4>id与class的命名规范</h4>
<p>ID和class命名要尽可能简短，但必要的话就别怕长。</p>
<p>尽可能简洁地传达id或者class名称的含义。</p>
<p>使用简洁的id或者class名称有助于提高可读性和代码效率。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="p">#</span><span class="nn">navigation</span> <span class="p">{}</span>
<span class="p">.</span><span class="nc">atr</span> <span class="p">{}</span>

<span class="c">/* 推荐 */</span>
<span class="p">#</span><span class="nn">nav</span> <span class="p">{}</span>
<span class="p">.</span><span class="nc">author</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-1">
<h4>选择器的类型</h4>
<p>应当避免在id和class前添加类型选择器。</p>
<p>除了必要情况下（例如辅助的类），不要将元素与id或class名称结合做为选择器。</p>
<p>避免不必要的祖先选择器也是出于 <a class="reference external" href="http://www.stevesouders.com/blog/2009/06/18/simplifying-css-selectors/">性能原因</a> 的考虑。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="nt">ul</span><span class="p">#</span><span class="nn">example</span> <span class="p">{}</span>
<span class="nt">div</span><span class="p">.</span><span class="nc">error</span> <span class="p">{}</span>

<span class="c">/* 推荐 */</span>
<span class="p">#</span><span class="nn">example</span> <span class="p">{}</span>
<span class="p">.</span><span class="nc">error</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-2">
<h4>简写属性</h4>
<p>尽可能使用简写的属性书写方式。</p>
<p>CSS提供了多种属性 <a class="reference external" href="http://www.w3.org/TR/CSS21/about.html#shorthand">简写</a> 的方式（如 <code class="docutils literal notranslate"><span class="pre">font</span></code> ），即使只显式设置一个值，也应该尽可能地使用。</p>
<p>使用简写属性有助于提高代码效率及可读性。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="nt">border-top-style</span><span class="o">:</span> <span class="nt">none</span><span class="o">;</span>
<span class="nt">font-family</span><span class="o">:</span> <span class="nt">palatino</span><span class="o">,</span> <span class="nt">georgia</span><span class="o">,</span> <span class="nt">serif</span><span class="o">;</span>
<span class="nt">font-size</span><span class="o">:</span> <span class="nt">100</span><span class="o">%;</span>
<span class="nt">line-height</span><span class="o">:</span> <span class="nt">1</span><span class="p">.</span><span class="nc">6</span><span class="o">;</span>
<span class="nt">padding-bottom</span><span class="o">:</span> <span class="nt">2em</span><span class="o">;</span>
<span class="nt">padding-left</span><span class="o">:</span> <span class="nt">1em</span><span class="o">;</span>
<span class="nt">padding-right</span><span class="o">:</span> <span class="nt">1em</span><span class="o">;</span>
<span class="nt">padding-top</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>

<span class="c">/* 推荐 */</span>
<span class="nt">border-top</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
<span class="nt">font</span><span class="o">:</span> <span class="nt">100</span><span class="o">%/</span><span class="nt">1</span><span class="p">.</span><span class="nc">6</span> <span class="nt">palatino</span><span class="o">,</span> <span class="nt">georgia</span><span class="o">,</span> <span class="nt">serif</span><span class="o">;</span>
<span class="nt">padding</span><span class="o">:</span> <span class="nt">0</span> <span class="nt">1em</span> <span class="nt">2em</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h4>0与单位</h4>
<p>省略“0”后的单位。</p>
<p>除非必需，否则0后不要加单位。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="nt">margin</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
<span class="nt">padding</span><span class="o">:</span> <span class="nt">0</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>前导0</h4>
<p>省略前导“0”值。</p>
<p>在-1至1之间的值无需保留整数位的0。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="nt">font-size</span><span class="o">:</span> <span class="p">.</span><span class="nc">8em</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>十六进制表示法</h4>
<p>在可能的情况下使用3个字符的十六进制表示法。</p>
<p>对于可用3字符十六进制表示的颜色值，按此规则书写更短、更简洁。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="nt">color</span><span class="o">:</span> <span class="p">#</span><span class="nn">eebbcc</span><span class="o">;</span>

<span class="c">/* 推荐 */</span>
<span class="nt">color</span><span class="o">:</span> <span class="p">#</span><span class="nn">ebc</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h4>前缀选择器</h4>
<p>加特定应用前缀（可选）</p>
<p>大型项目中以及嵌入在其它项目或外部网站上的代码需要给id和class添加前缀（命名空间）。使用短的、独特的标识符，并在其后跟一个破折号。
使用命名空间有助于防止命名冲突，可以让维护变得简单，例如在搜索和替换操作时。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="nc">adw-help</span> <span class="p">{}</span> <span class="c">/* AdWords */</span>
<span class="p">#</span><span class="nn">maia-note</span> <span class="p">{}</span> <span class="c">/* Maia */</span>
</pre></div>
</div>
</div>
<div class="section" id="idclass-2">
<h4>id与class名称分隔符</h4>
<p>用连字符分隔ID和类名中的单词。</p>
<p>选择器中的词语和缩写中不要使用除了连字符以外的任何字符（包括空字符），以提高可理解性和可读性。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐: 单词未分开 */</span>
<span class="p">.</span><span class="nc">demoimage</span> <span class="p">{}</span>

<span class="c">/* 不推荐：使用下划线而不是连字符 */</span>
<span class="p">.</span><span class="nc">error_status</span> <span class="p">{}</span>

<span class="c">/* 推荐 */</span>
<span class="p">#</span><span class="nn">video-id</span> <span class="p">{}</span>
<span class="p">.</span><span class="nc">ads-sample</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
<div class="section" id="hacks">
<h4>Hacks</h4>
<p>请先尝试其他的方法，避免用户代理检测以及CSS的“hacks”。</p>
<p>进行用户代理检测或使用特殊的CSS选择器及hacks看起来是处理样式差异的捷径。但为了实现和保持高效性以及代码的可维护性，这两种方案应该放到最后考虑。换句话说，用户代理检测和使用hacks会增大项目推进的阻力，所以从项目的长远利益考虑应尽力避免。一旦允许并无顾忌地使用用户代理检测和hacks便很容易滥用，最终一发而不可收。</p>
</div>
</div>
<span id="document-google-html-css-styleguide/css_formatting_rules"></span><div class="section" id="css">
<h3>CSS格式化规则</h3>
<div class="section" id="section-1">
<h4>声明顺序</h4>
<p>按字母顺序排列声明。</p>
<p>css文件书写按字母顺序排列的方式，容易记忆和维护，以达到一致的代码。</p>
<p>在排序时忽略浏览器特定的前缀。但是，特定CSS属性的多个浏览器前缀应按字母顺序排列（如-moz书写在-webkit前面）。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="nt">background</span><span class="o">:</span> <span class="nt">fuchsia</span><span class="o">;</span>
<span class="nt">border</span><span class="o">:</span> <span class="nt">1px</span> <span class="nt">solid</span><span class="o">;</span>
<span class="nt">-moz-border-radius</span><span class="o">:</span> <span class="nt">4px</span><span class="o">;</span>
<span class="nt">-webkit-border-radius</span><span class="o">:</span> <span class="nt">4px</span><span class="o">;</span>
<span class="nt">border-radius</span><span class="o">:</span> <span class="nt">4px</span><span class="o">;</span>
<span class="nt">color</span><span class="o">:</span> <span class="nt">black</span><span class="o">;</span>
<span class="nt">text-align</span><span class="o">:</span> <span class="nt">center</span><span class="o">;</span>
<span class="nt">text-indent</span><span class="o">:</span> <span class="nt">2em</span><span class="o">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-2">
<h4>块内容的缩进</h4>
<p>缩进块内容。</p>
<p>将包括嵌套及声明的 <a class="reference external" href="http://www.w3.org/TR/CSS21/syndata.html#block">块内容</a> 进行缩进，以体现层次并提高可读性。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="p">@</span><span class="k">media</span> <span class="nt">screen</span><span class="o">,</span> <span class="nt">projection</span> <span class="p">{</span>

  <span class="nt">html</span> <span class="p">{</span>
    <span class="k">background</span><span class="p">:</span> <span class="mh">#fff</span><span class="p">;</span>
    <span class="k">color</span><span class="p">:</span> <span class="mh">#444</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h4>声明结束</h4>
<p>每个属性后使用分号结束。</p>
<p>以分号结束每个属性，提高一致性和可扩展性。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="p">.</span><span class="nc">test</span> <span class="p">{</span>
  <span class="k">display</span><span class="p">:</span> <span class="kc">block</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span>
<span class="p">}</span>

<span class="c">/* 推荐 */</span>
<span class="p">.</span><span class="nc">test</span> <span class="p">{</span>
  <span class="k">display</span><span class="p">:</span> <span class="kc">block</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="css-1">
<h4>CSS属性名结束</h4>
<p>属性名称的冒号后有一个空格。</p>
<p>为保证一致性，在属性名与属性值之间添加一个空格（但是属性名和冒号间没有空格）。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="nt">h3</span> <span class="p">{</span>
  <span class="k">font-weight</span><span class="p">:</span><span class="kc">bold</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 推荐 */</span>
<span class="nt">h3</span> <span class="p">{</span>
  <span class="k">font-weight</span><span class="p">:</span> <span class="kc">bold</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h4>声明块间隔</h4>
<p>在选择器和后面的声明块之间使用一个空格。</p>
<p>最后一个选择器与表示 <a class="reference external" href="http://www.w3.org/TR/CSS21/syndata.html#rule-sets">声名块</a> 开始的左大花括号在同行，中间有一个字符空格。</p>
<p>表示开始的左大花括号和选择器在同行。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐：缺少空间 */</span>
<span class="p">#</span><span class="nn">video</span><span class="p">{</span>
  <span class="k">margin-top</span><span class="p">:</span> <span class="mi">1</span><span class="kt">em</span><span class="p">;</span>
<span class="p">}</span>


<span class="c">/* 不推荐：不必要的换行符 */</span>
<span class="p">#</span><span class="nn">video</span>
<span class="p">{</span>
  <span class="k">margin-top</span><span class="p">:</span> <span class="mi">1</span><span class="kt">em</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 推荐 */</span>
<span class="p">#</span><span class="nn">video</span> <span class="p">{</span>
  <span class="k">margin-top</span><span class="p">:</span> <span class="mi">1</span><span class="kt">em</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h4>选择器及声明分离</h4>
<p>每个选择器和声明独立成行。</p>
<p>总是让每个选择器和声明单独成行。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="nt">a</span><span class="p">:</span><span class="nd">focus</span><span class="o">,</span> <span class="nt">a</span><span class="p">:</span><span class="nd">active</span> <span class="p">{</span>
  <span class="k">position</span><span class="p">:</span> <span class="kc">relative</span><span class="p">;</span> <span class="k">top</span><span class="p">:</span> <span class="mi">1</span><span class="kt">px</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 推荐 */</span>
<span class="nt">h1</span><span class="o">,</span>
<span class="nt">h2</span><span class="o">,</span>
<span class="nt">h3</span> <span class="p">{</span>
  <span class="k">font-weight</span><span class="p">:</span> <span class="kc">normal</span><span class="p">;</span>
  <span class="k">line-height</span><span class="p">:</span> <span class="mf">1.2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="css-2">
<h4>CSS代码块分离</h4>
<p>使用新空行分离规则。</p>
<p>始终把一个空行（两个换行符）放在代码块规则之间。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="nt">html</span> <span class="p">{</span>
  <span class="k">background</span><span class="p">:</span> <span class="mh">#fff</span><span class="p">;</span>
<span class="p">}</span>


<span class="nt">body</span> <span class="p">{</span>
  <span class="k">margin</span><span class="p">:</span> <span class="kc">auto</span><span class="p">;</span>
  <span class="k">width</span><span class="p">:</span> <span class="mi">50</span><span class="kt">%</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="css-3">
<h4>CSS引号</h4>
<p>属性选择器和属性值中使用单引号。</p>
<p>在属性选择器及属性值中使用单引号（’’）而不是双引号（””）。在 <code class="docutils literal notranslate"><span class="pre">url（）</span></code> 中不要使用引号。</p>
<p>特例：如果你确实需要定义 <code class="docutils literal notranslate"><span class="pre">&#64;charset</span></code> ，由于 <a class="reference external" href="http://www.w3.org/TR/CSS21/syndata.html#charset">不允许使用单引号</a> ，故请使用双引号。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* 不推荐 */</span>
<span class="p">@</span><span class="k">import</span> <span class="nt">url</span><span class="o">(</span><span class="s2">&quot;//www.google.com/css/maia.css&quot;</span><span class="o">)</span><span class="p">;</span>

<span class="nt">html</span> <span class="p">{</span>
  <span class="k">font-family</span><span class="p">:</span> <span class="s2">&quot;open sans&quot;</span><span class="p">,</span> <span class="n">arial</span><span class="p">,</span> <span class="kc">sans-serif</span><span class="p">;</span>
<span class="p">}</span>

<span class="c">/* 推荐 */</span>
<span class="p">@</span><span class="k">import</span> <span class="nt">url</span><span class="o">(//</span><span class="nt">www</span><span class="p">.</span><span class="nc">google</span><span class="p">.</span><span class="nc">com</span><span class="o">/</span><span class="nt">css</span><span class="o">/</span><span class="nt">maia</span><span class="p">.</span><span class="nc">css</span><span class="o">)</span><span class="p">;</span>

<span class="nt">html</span> <span class="p">{</span>
  <span class="k">font-family</span><span class="p">:</span> <span class="s1">&#39;open sans&#39;</span><span class="p">,</span> <span class="n">arial</span><span class="p">,</span> <span class="kc">sans-serif</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-html-css-styleguide/css_meta_rules"></span><div class="section" id="css">
<h3>CSS元规则</h3>
<div class="section" id="section-1">
<h4>分段规则</h4>
<p>组的分段由一段注释完成（可选）。</p>
<p>尽可能地用注释来将css分段，段与段之间采用新行。</p>
<div class="highlight-css notranslate"><div class="highlight"><pre><span></span><span class="c">/* Header */</span>

<span class="p">#</span><span class="nn">adw-header</span> <span class="p">{}</span>

<span class="c">/* Footer */</span>

<span class="p">#</span><span class="nn">adw-footer</span> <span class="p">{}</span>

<span class="c">/* Gallery */</span>

<span class="p">.</span><span class="nc">adw-gallery</span> <span class="p">{}</span>
</pre></div>
</div>
</div>
</div>
<span id="document-google-html-css-styleguide/parting_words"></span><div class="section" id="section-1">
<h3>赠言</h3>
<p>请与周围保持一致。</p>
<p>如果你正在编辑代码，花几分钟时间看看上下文代码的格式，确定他们的编码风格。如果在上下文代码中，算术运算符前后有空格，或注释前后添加了“#”，你也应该这样做。</p>
<p>编写这个风格指导的目标是让人们可以专注于“我们在讨论什么”而不是“我们该怎么描述”。我们提供了一些通用的编码规范，大家就可以基于这些规范而继续，但特定情况下的规范也同样重要。如果你在一个文件中添加的代码看上去跟其他代码明显不同，你就把阅读此文件的人的节奏打乱了。避免这种情况出现。</p>
</div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 
      
        <span class="commit">
          Revision <code>0bbeb813</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/en/latest/">latest</a></dd>
        
          <dd><a href="/en/stable/">stable</a></dd>
        
          <dd><a href="/en/dev/">dev</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//zh-google-styleguide.readthedocs.io/_/downloads/en/latest/pdf/">pdf</a></dd>
        
          <dd><a href="//zh-google-styleguide.readthedocs.io/_/downloads/en/latest/htmlzip/">html</a></dd>
        
          <dd><a href="//zh-google-styleguide.readthedocs.io/_/downloads/en/latest/epub/">epub</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/zh-google-styleguide/?fromdocs=zh-google-styleguide">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/zh-google-styleguide/?fromdocs=zh-google-styleguide">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
   

</body>
</html>